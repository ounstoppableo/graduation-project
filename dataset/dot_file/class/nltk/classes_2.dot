digraph "classes_nltk" {
rankdir=BT
charset="utf-8"
"nltk.classify.weka.ARFF_Formatter" [color="black", fontcolor="black", label=<{ARFF_Formatter|<br ALIGN="LEFT"/>|data_section(tokens, labeled)<br ALIGN="LEFT"/>format(tokens)<br ALIGN="LEFT"/>from_train(tokens)<br ALIGN="LEFT"/>header_section()<br ALIGN="LEFT"/>labels()<br ALIGN="LEFT"/>write(outfile, tokens)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.sem.boxer.AbstractBoxerDrs" [color="black", fontcolor="black", label=<{AbstractBoxerDrs|<br ALIGN="LEFT"/>|atoms()<br ALIGN="LEFT"/>clean()<br ALIGN="LEFT"/>renumber_sentences(f)<br ALIGN="LEFT"/>variable_types()<br ALIGN="LEFT"/>variables()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.ccg.api.AbstractCCGCategory" [color="black", fontcolor="black", label=<{AbstractCCGCategory|<br ALIGN="LEFT"/>|<I>can_unify</I>(other)<br ALIGN="LEFT"/><I>is_function</I>()<br ALIGN="LEFT"/><I>is_primitive</I>()<br ALIGN="LEFT"/><I>is_var</I>()<br ALIGN="LEFT"/><I>substitute</I>(substitutions)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.parse.chart.AbstractChartRule" [color="black", fontcolor="black", label=<{AbstractChartRule|<br ALIGN="LEFT"/>|<I>apply</I>(chart, grammar)<br ALIGN="LEFT"/>apply_everywhere(chart, grammar)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.collocations.AbstractCollocationFinder" [color="black", fontcolor="black", label=<{AbstractCollocationFinder|ngram_fd<br ALIGN="LEFT"/>word_fd<br ALIGN="LEFT"/>|above_score(score_fn, min_score)<br ALIGN="LEFT"/>apply_freq_filter(min_freq)<br ALIGN="LEFT"/>apply_ngram_filter(fn)<br ALIGN="LEFT"/>apply_word_filter(fn)<br ALIGN="LEFT"/>from_documents(documents)<br ALIGN="LEFT"/>nbest(score_fn, n)<br ALIGN="LEFT"/>score_ngrams(score_fn)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.draw.util.AbstractContainerWidget" [color="black", fontcolor="black", label=<{AbstractContainerWidget|<br ALIGN="LEFT"/>|child()<br ALIGN="LEFT"/>set_child(child)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.util.AbstractLazySequence" [color="black", fontcolor="black", label=<{AbstractLazySequence|<br ALIGN="LEFT"/>|count(value)<br ALIGN="LEFT"/>index(value, start, stop)<br ALIGN="LEFT"/><I>iterate_from</I>(start)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.tree.AbstractParentedTree" [color="black", fontcolor="black", label=<{AbstractParentedTree|<br ALIGN="LEFT"/>|append(child)<br ALIGN="LEFT"/>extend(children)<br ALIGN="LEFT"/>insert(index, child)<br ALIGN="LEFT"/>pop(index)<br ALIGN="LEFT"/>remove(child)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.sem.logic.AbstractVariableExpression" [color="black", fontcolor="black", label=<{AbstractVariableExpression|variable<br ALIGN="LEFT"/>|findtype(variable)<br ALIGN="LEFT"/>predicates()<br ALIGN="LEFT"/>replace(variable, expression, replace_bound, alpha_convert)<br ALIGN="LEFT"/>simplify()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.tag.sequential.AffixTagger" [color="black", fontcolor="black", label=<{AffixTagger|json_tag : str<br ALIGN="LEFT"/>|context(tokens, index, history)<br ALIGN="LEFT"/>decode_json_obj(obj)<br ALIGN="LEFT"/>encode_json_obj()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.inference.tableau.Agenda" [color="black", fontcolor="black", label=<{Agenda|sets : tuple<br ALIGN="LEFT"/>|clone()<br ALIGN="LEFT"/>mark_alls_fresh()<br ALIGN="LEFT"/>mark_neqs_fresh()<br ALIGN="LEFT"/>pop_first()<br ALIGN="LEFT"/>put(expression, context)<br ALIGN="LEFT"/>put_all(expressions)<br ALIGN="LEFT"/>put_atoms(atoms)<br ALIGN="LEFT"/>replace_all(old, new)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.corpus.reader.aligned.AlignedCorpusReader" [color="black", fontcolor="black", label=<{AlignedCorpusReader|<br ALIGN="LEFT"/>|aligned_sents(fileids)<br ALIGN="LEFT"/>raw(fileids)<br ALIGN="LEFT"/>sents(fileids)<br ALIGN="LEFT"/>words(fileids)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.align.api.AlignedSent" [color="black", fontcolor="black", label=<{AlignedSent|alignment<br ALIGN="LEFT"/>mots<br ALIGN="LEFT"/>words<br ALIGN="LEFT"/>|alignment_error_rate(reference, possible)<br ALIGN="LEFT"/>invert()<br ALIGN="LEFT"/>precision(reference)<br ALIGN="LEFT"/>recall(reference)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.corpus.reader.aligned.AlignedSentCorpusView" [color="black", fontcolor="black", label=<{AlignedSentCorpusView|<br ALIGN="LEFT"/>|read_block(stream)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.align.api.Alignment" [color="black", fontcolor="black", label=<{Alignment|<br ALIGN="LEFT"/>|invert()<br ALIGN="LEFT"/>range(positions)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.sem.logic.AllExpression" [color="black", fontcolor="black", label=<{AllExpression|<br ALIGN="LEFT"/>|getQuantifier()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.corpus.reader.bracket_parse.AlpinoCorpusReader" [color="black", fontcolor="black", label=<{AlpinoCorpusReader|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"nltk.sem.drt.AnaphoraResolutionException" [color="black", fontcolor="red", label=<{AnaphoraResolutionException|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"nltk.sem.logic.AndExpression" [color="black", fontcolor="black", label=<{AndExpression|<br ALIGN="LEFT"/>|getOp()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.metrics.agreement.AnnotationTask" [color="black", fontcolor="black", label=<{AnnotationTask|C : set<br ALIGN="LEFT"/>I : set<br ALIGN="LEFT"/>K : set<br ALIGN="LEFT"/>data : list<br ALIGN="LEFT"/>distance<br ALIGN="LEFT"/>|Ae_kappa(cA, cB)<br ALIGN="LEFT"/>Ao(cA, cB)<br ALIGN="LEFT"/>Do_Kw(max_distance)<br ALIGN="LEFT"/>Do_Kw_pairwise(cA, cB, max_distance)<br ALIGN="LEFT"/>Do_alpha()<br ALIGN="LEFT"/>N(k, i, c)<br ALIGN="LEFT"/>Nck(c, k)<br ALIGN="LEFT"/>Nik(i, k)<br ALIGN="LEFT"/>Nk(k)<br ALIGN="LEFT"/>S()<br ALIGN="LEFT"/>agr(cA, cB, i, data)<br ALIGN="LEFT"/>alpha()<br ALIGN="LEFT"/>avg_Ao()<br ALIGN="LEFT"/>kappa()<br ALIGN="LEFT"/>kappa_pairwise(cA, cB)<br ALIGN="LEFT"/>load_array(array)<br ALIGN="LEFT"/>multi_kappa()<br ALIGN="LEFT"/>pi()<br ALIGN="LEFT"/>weighted_kappa(max_distance)<br ALIGN="LEFT"/>weighted_kappa_pairwise(cA, cB, max_distance)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.sem.logic.AnyType" [color="black", fontcolor="black", label=<{AnyType|first<br ALIGN="LEFT"/>second<br ALIGN="LEFT"/>|matches(other)<br ALIGN="LEFT"/>resolve(other)<br ALIGN="LEFT"/>str()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.sem.linearlogic.ApplicationExpression" [color="black", fontcolor="black", label=<{ApplicationExpression|argument<br ALIGN="LEFT"/>bindings<br ALIGN="LEFT"/>function<br ALIGN="LEFT"/>|simplify(bindings)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.sem.logic.ApplicationExpression" [color="black", fontcolor="black", label=<{ApplicationExpression|args<br ALIGN="LEFT"/>argument<br ALIGN="LEFT"/>function<br ALIGN="LEFT"/>pred<br ALIGN="LEFT"/>type<br ALIGN="LEFT"/>|constants()<br ALIGN="LEFT"/>findtype(variable)<br ALIGN="LEFT"/>is_atom()<br ALIGN="LEFT"/>predicates()<br ALIGN="LEFT"/>simplify()<br ALIGN="LEFT"/>uncurry()<br ALIGN="LEFT"/>visit(function, combinator)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.sem.evaluate.Assignment" [color="black", fontcolor="black", label=<{Assignment|domain<br ALIGN="LEFT"/>variant : NoneType, list<br ALIGN="LEFT"/>|add(var, val)<br ALIGN="LEFT"/>copy()<br ALIGN="LEFT"/>purge(var)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.sem.linearlogic.AtomicExpression" [color="black", fontcolor="black", label=<{AtomicExpression|dependencies : NoneType, list<br ALIGN="LEFT"/>name<br ALIGN="LEFT"/>|compile_neg(index_counter, glueFormulaFactory)<br ALIGN="LEFT"/>compile_pos(index_counter, glueFormulaFactory)<br ALIGN="LEFT"/>initialize_labels(fstruct)<br ALIGN="LEFT"/>simplify(bindings)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.corpus.reader.framenet.AttrDict" [color="black", fontcolor="black", label=<{AttrDict|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"nltk.corpus.reader.bnc.BNCCorpusReader" [color="black", fontcolor="black", label=<{BNCCorpusReader|<br ALIGN="LEFT"/>|sents(fileids, strip_space, stem)<br ALIGN="LEFT"/>tagged_sents(fileids, c5, strip_space, stem)<br ALIGN="LEFT"/>tagged_words(fileids, c5, strip_space, stem)<br ALIGN="LEFT"/>words(fileids, strip_space, stem)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.corpus.reader.bnc.BNCSentence" [color="black", fontcolor="black", label=<{BNCSentence|num<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"nltk.corpus.reader.bnc.BNCWordView" [color="black", fontcolor="black", label=<{BNCWordView|author : NoneType, str<br ALIGN="LEFT"/>editor : NoneType, str<br ALIGN="LEFT"/>resps : NoneType, str<br ALIGN="LEFT"/>tags_to_ignore : set<br ALIGN="LEFT"/>title : NoneType, str<br ALIGN="LEFT"/>|handle_elt(elt, context)<br ALIGN="LEFT"/>handle_header(elt, context)<br ALIGN="LEFT"/>handle_sent(elt)<br ALIGN="LEFT"/>handle_word(elt)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.ccg.combinator.BackwardCombinator" [color="black", fontcolor="black", label=<{BackwardCombinator|<br ALIGN="LEFT"/>|can_combine(left, right)<br ALIGN="LEFT"/>combine(left, right)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.ccg.chart.BackwardTypeRaiseRule" [color="black", fontcolor="black", label=<{BackwardTypeRaiseRule|NUMEDGES : int<br ALIGN="LEFT"/>|apply(chart, grammar, left_edge, right_edge)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.inference.api.BaseModelBuilderCommand" [color="black", fontcolor="black", label=<{BaseModelBuilderCommand|<br ALIGN="LEFT"/>|build_model(verbose)<br ALIGN="LEFT"/>get_model_builder()<br ALIGN="LEFT"/>model(format)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.inference.api.BaseProverCommand" [color="black", fontcolor="black", label=<{BaseProverCommand|<br ALIGN="LEFT"/>|decorate_proof(proof_string, simplify)<br ALIGN="LEFT"/>get_prover()<br ALIGN="LEFT"/>proof(simplify)<br ALIGN="LEFT"/>prove(verbose)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.inference.api.BaseTheoremToolCommand" [color="black", fontcolor="black", label=<{BaseTheoremToolCommand|<br ALIGN="LEFT"/>|add_assumptions(new_assumptions)<br ALIGN="LEFT"/>assumptions()<br ALIGN="LEFT"/>goal()<br ALIGN="LEFT"/>print_assumptions()<br ALIGN="LEFT"/>retract_assumptions(retracted, debug)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.sem.logic.BasicType" [color="black", fontcolor="black", label=<{BasicType|<br ALIGN="LEFT"/>|matches(other)<br ALIGN="LEFT"/>resolve(other)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.metrics.association.BigramAssocMeasures" [color="black", fontcolor="black", label=<{BigramAssocMeasures|<br ALIGN="LEFT"/>|chi_sq(n_ii, n_ix_xi_tuple, n_xx)<br ALIGN="LEFT"/>dice(n_ii, n_ix_xi_tuple, n_xx)<br ALIGN="LEFT"/>fisher()<br ALIGN="LEFT"/>phi_sq()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.collocations.BigramCollocationFinder" [color="black", fontcolor="black", label=<{BigramCollocationFinder|window_size : int<br ALIGN="LEFT"/>|from_words(words, window_size)<br ALIGN="LEFT"/>score_ngram(score_fn, w1, w2)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.tag.sequential.BigramTagger" [color="black", fontcolor="black", label=<{BigramTagger|json_tag : str<br ALIGN="LEFT"/>|decode_json_obj(obj)<br ALIGN="LEFT"/>encode_json_obj()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.ccg.chart.BinaryCombinatorRule" [color="black", fontcolor="black", label=<{BinaryCombinatorRule|NUMEDGES : int<br ALIGN="LEFT"/>|apply(chart, grammar, left_edge, right_edge)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.sem.logic.BinaryExpression" [color="black", fontcolor="black", label=<{BinaryExpression|first<br ALIGN="LEFT"/>second<br ALIGN="LEFT"/>type<br ALIGN="LEFT"/>|findtype(variable)<br ALIGN="LEFT"/>visit(function, combinator)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.classify.maxent.BinaryMaxentFeatureEncoding" [color="black", fontcolor="black", label=<{BinaryMaxentFeatureEncoding|<br ALIGN="LEFT"/>|describe(f_id)<br ALIGN="LEFT"/>encode(featureset, label)<br ALIGN="LEFT"/>labels()<br ALIGN="LEFT"/>length()<br ALIGN="LEFT"/>train(train_toks, count_cutoff, labels)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.inference.resolution.BindingDict" [color="black", fontcolor="black", label=<{BindingDict|d : dict<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"nltk.sem.linearlogic.BindingDict" [color="black", fontcolor="black", label=<{BindingDict|d : dict<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"nltk.inference.resolution.BindingException" [color="black", fontcolor="red", label=<{BindingException|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"nltk.tokenize.regexp.BlanklineTokenizer" [color="black", fontcolor="black", label=<{BlanklineTokenizer|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"nltk.parse.bllip.BllipParser" [color="black", fontcolor="black", label=<{BllipParser|rrp<br ALIGN="LEFT"/>|from_unified_model_dir(model_dir, parser_options, reranker_options)<br ALIGN="LEFT"/>parse(sentence)<br ALIGN="LEFT"/>tagged_parse(word_and_tag_pairs)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.sem.logic.BooleanExpression" [color="black", fontcolor="black", label=<{BooleanExpression|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"nltk.parse.chart.BottomUpChartParser" [color="black", fontcolor="black", label=<{BottomUpChartParser|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"nltk.app.chartparser_app.BottomUpEdgeRule" [color="black", fontcolor="black", label=<{BottomUpEdgeRule|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"nltk.parse.chart.BottomUpLeftCornerChartParser" [color="black", fontcolor="black", label=<{BottomUpLeftCornerChartParser|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"nltk.app.chartparser_app.BottomUpLeftCornerEdgeRule" [color="black", fontcolor="black", label=<{BottomUpLeftCornerEdgeRule|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"nltk.parse.chart.BottomUpPredictCombineRule" [color="black", fontcolor="black", label=<{BottomUpPredictCombineRule|NUM_EDGES : int<br ALIGN="LEFT"/>|apply(chart, grammar, edge)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.parse.chart.BottomUpPredictRule" [color="black", fontcolor="black", label=<{BottomUpPredictRule|NUM_EDGES : int<br ALIGN="LEFT"/>|apply(chart, grammar, edge)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.parse.pchart.BottomUpProbabilisticChartParser" [color="black", fontcolor="black", label=<{BottomUpProbabilisticChartParser|beam_size : int<br ALIGN="LEFT"/>|grammar()<br ALIGN="LEFT"/>parse(tokens)<br ALIGN="LEFT"/><I>sort_queue</I>(queue, chart)<br ALIGN="LEFT"/>trace(trace)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.draw.util.BoxWidget" [color="black", fontcolor="black", label=<{BoxWidget|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"nltk.sem.boxer.Boxer" [color="black", fontcolor="black", label=<{Boxer|<br ALIGN="LEFT"/>|interpret(input, discourse_id, question, verbose)<br ALIGN="LEFT"/>interpret_multi(input, discourse_id, question, verbose)<br ALIGN="LEFT"/>interpret_multi_sents(inputs, discourse_ids, question, verbose)<br ALIGN="LEFT"/>interpret_sents(inputs, discourse_ids, question, verbose)<br ALIGN="LEFT"/>set_bin_dir(bin_dir, verbose)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.sem.boxer.BoxerCard" [color="black", fontcolor="black", label=<{BoxerCard|type<br ALIGN="LEFT"/>value<br ALIGN="LEFT"/>var<br ALIGN="LEFT"/>|renumber_sentences(f)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.sem.boxer.BoxerDrs" [color="black", fontcolor="black", label=<{BoxerDrs|conds<br ALIGN="LEFT"/>consequent : NoneType<br ALIGN="LEFT"/>label<br ALIGN="LEFT"/>refs<br ALIGN="LEFT"/>|atoms()<br ALIGN="LEFT"/>clean()<br ALIGN="LEFT"/>renumber_sentences(f)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.sem.boxer.BoxerDrsParser" [color="black", fontcolor="black", label=<{BoxerDrsParser|discourse_id : NoneType<br ALIGN="LEFT"/>|attempt_adjuncts(expression, context)<br ALIGN="LEFT"/>get_all_symbols()<br ALIGN="LEFT"/>get_next_token_variable(description)<br ALIGN="LEFT"/>handle(tok, context)<br ALIGN="LEFT"/>nullableIntToken()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.sem.boxer.BoxerEq" [color="black", fontcolor="black", label=<{BoxerEq|var1<br ALIGN="LEFT"/>var2<br ALIGN="LEFT"/>|atoms()<br ALIGN="LEFT"/>renumber_sentences(f)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.sem.boxer.BoxerIndexed" [color="black", fontcolor="black", label=<{BoxerIndexed|discourse_id<br ALIGN="LEFT"/>sent_index<br ALIGN="LEFT"/>word_indices<br ALIGN="LEFT"/>|atoms()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.sem.boxer.BoxerNamed" [color="black", fontcolor="black", label=<{BoxerNamed|name<br ALIGN="LEFT"/>sense<br ALIGN="LEFT"/>type<br ALIGN="LEFT"/>var<br ALIGN="LEFT"/>|change_var(var)<br ALIGN="LEFT"/>clean()<br ALIGN="LEFT"/>renumber_sentences(f)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.sem.boxer.BoxerNot" [color="black", fontcolor="black", label=<{BoxerNot|drs<br ALIGN="LEFT"/>|atoms()<br ALIGN="LEFT"/>clean()<br ALIGN="LEFT"/>renumber_sentences(f)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.sem.boxer.BoxerOr" [color="black", fontcolor="black", label=<{BoxerOr|drs1<br ALIGN="LEFT"/>drs2<br ALIGN="LEFT"/>|atoms()<br ALIGN="LEFT"/>clean()<br ALIGN="LEFT"/>renumber_sentences(f)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.sem.boxer.BoxerOutputDrsParser" [color="black", fontcolor="black", label=<{BoxerOutputDrsParser|discourse_id : NoneType<br ALIGN="LEFT"/>quote_chars : list<br ALIGN="LEFT"/>sentence_id_offset : NoneType<br ALIGN="LEFT"/>|attempt_adjuncts(expression, context)<br ALIGN="LEFT"/>get_all_symbols()<br ALIGN="LEFT"/>handle(tok, context)<br ALIGN="LEFT"/>handle_condition(tok, indices)<br ALIGN="LEFT"/>handle_drs(tok)<br ALIGN="LEFT"/>parse(data, signature)<br ALIGN="LEFT"/>parse_condition(indices)<br ALIGN="LEFT"/>parse_drs()<br ALIGN="LEFT"/>parse_index()<br ALIGN="LEFT"/>parse_variable()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.sem.boxer.BoxerPred" [color="black", fontcolor="black", label=<{BoxerPred|name<br ALIGN="LEFT"/>pos<br ALIGN="LEFT"/>sense<br ALIGN="LEFT"/>var<br ALIGN="LEFT"/>|change_var(var)<br ALIGN="LEFT"/>clean()<br ALIGN="LEFT"/>renumber_sentences(f)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.sem.boxer.BoxerProp" [color="black", fontcolor="black", label=<{BoxerProp|drs<br ALIGN="LEFT"/>var<br ALIGN="LEFT"/>|atoms()<br ALIGN="LEFT"/>clean()<br ALIGN="LEFT"/>referenced_labels()<br ALIGN="LEFT"/>renumber_sentences(f)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.sem.boxer.BoxerRel" [color="black", fontcolor="black", label=<{BoxerRel|rel<br ALIGN="LEFT"/>sense<br ALIGN="LEFT"/>var1<br ALIGN="LEFT"/>var2<br ALIGN="LEFT"/>|clean()<br ALIGN="LEFT"/>renumber_sentences(f)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.sem.boxer.BoxerWhq" [color="black", fontcolor="black", label=<{BoxerWhq|ans_types<br ALIGN="LEFT"/>drs1<br ALIGN="LEFT"/>drs2<br ALIGN="LEFT"/>variable<br ALIGN="LEFT"/>|atoms()<br ALIGN="LEFT"/>clean()<br ALIGN="LEFT"/>renumber_sentences(f)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.corpus.reader.bracket_parse.BracketParseCorpusReader" [color="black", fontcolor="black", label=<{BracketParseCorpusReader|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"nltk.draw.util.BracketWidget" [color="black", fontcolor="black", label=<{BracketWidget|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"nltk.tag.brill.BrillTagger" [color="black", fontcolor="black", label=<{BrillTagger|json_tag : str<br ALIGN="LEFT"/>|batch_tag_incremental(sequences, gold)<br ALIGN="LEFT"/>decode_json_obj(obj)<br ALIGN="LEFT"/>encode_json_obj()<br ALIGN="LEFT"/>print_template_statistics(test_stats, printunused)<br ALIGN="LEFT"/>rules()<br ALIGN="LEFT"/>tag(tokens)<br ALIGN="LEFT"/>train_stats(statistic)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.tag.brill_trainer.BrillTaggerTrainer" [color="black", fontcolor="black", label=<{BrillTaggerTrainer|<br ALIGN="LEFT"/>|train(train_sents, max_rules, min_score, min_acc)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.tag.brill_trainer_orig.BrillTaggerTrainer" [color="black", fontcolor="black", label=<{BrillTaggerTrainer|<br ALIGN="LEFT"/>|train(train_sents, max_rules, min_score, min_acc)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.tbl.template.BrillTemplateI" [color="black", fontcolor="black", label=<{BrillTemplateI|<br ALIGN="LEFT"/>|<I>applicable_rules</I>(tokens, i, correctTag)<br ALIGN="LEFT"/><I>get_neighborhood</I>(token, index)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.data.BufferedGzipFile" [color="black", fontcolor="black", label=<{BufferedGzipFile|SIZE : int<br ALIGN="LEFT"/>|close()<br ALIGN="LEFT"/>flush(lib_mode)<br ALIGN="LEFT"/>read(size)<br ALIGN="LEFT"/>write(data, size)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.ccg.chart.CCGChart" [color="black", fontcolor="black", label=<{CCGChart|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"nltk.ccg.chart.CCGChartParser" [color="black", fontcolor="black", label=<{CCGChartParser|<br ALIGN="LEFT"/>|lexicon()<br ALIGN="LEFT"/>parse(tokens)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.ccg.chart.CCGEdge" [color="black", fontcolor="black", label=<{CCGEdge|<br ALIGN="LEFT"/>|categ()<br ALIGN="LEFT"/>dot()<br ALIGN="LEFT"/>end()<br ALIGN="LEFT"/>is_complete()<br ALIGN="LEFT"/>is_incomplete()<br ALIGN="LEFT"/>length()<br ALIGN="LEFT"/>lhs()<br ALIGN="LEFT"/>nextsym()<br ALIGN="LEFT"/>rhs()<br ALIGN="LEFT"/>rule()<br ALIGN="LEFT"/>span()<br ALIGN="LEFT"/>start()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.ccg.chart.CCGLeafEdge" [color="black", fontcolor="black", label=<{CCGLeafEdge|<br ALIGN="LEFT"/>|categ()<br ALIGN="LEFT"/>dot()<br ALIGN="LEFT"/>end()<br ALIGN="LEFT"/>is_complete()<br ALIGN="LEFT"/>is_incomplete()<br ALIGN="LEFT"/>leaf()<br ALIGN="LEFT"/>length()<br ALIGN="LEFT"/>lhs()<br ALIGN="LEFT"/>nextsym()<br ALIGN="LEFT"/>rhs()<br ALIGN="LEFT"/>span()<br ALIGN="LEFT"/>start()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.ccg.lexicon.CCGLexicon" [color="black", fontcolor="black", label=<{CCGLexicon|<br ALIGN="LEFT"/>|categories(word)<br ALIGN="LEFT"/>start()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.ccg.api.CCGVar" [color="black", fontcolor="black", label=<{CCGVar|<br ALIGN="LEFT"/>|can_unify(other)<br ALIGN="LEFT"/>id()<br ALIGN="LEFT"/>is_function()<br ALIGN="LEFT"/>is_primitive()<br ALIGN="LEFT"/>is_var()<br ALIGN="LEFT"/>new_id()<br ALIGN="LEFT"/>substitute(substitutions)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.grammar.CFG" [color="black", fontcolor="black", label=<{CFG|<br ALIGN="LEFT"/>|check_coverage(tokens)<br ALIGN="LEFT"/>fromstring(input, encoding)<br ALIGN="LEFT"/>is_binarised()<br ALIGN="LEFT"/>is_chomsky_normal_form()<br ALIGN="LEFT"/>is_flexible_chomsky_normal_form()<br ALIGN="LEFT"/>is_leftcorner(cat, left)<br ALIGN="LEFT"/>is_lexical()<br ALIGN="LEFT"/>is_nonempty()<br ALIGN="LEFT"/>is_nonlexical()<br ALIGN="LEFT"/>leftcorner_parents(cat)<br ALIGN="LEFT"/>leftcorners(cat)<br ALIGN="LEFT"/>max_len()<br ALIGN="LEFT"/>min_len()<br ALIGN="LEFT"/>productions(lhs, rhs, empty)<br ALIGN="LEFT"/>start()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.draw.cfg.CFGDemo" [color="black", fontcolor="black", label=<{CFGDemo|<br ALIGN="LEFT"/>|destroy()<br ALIGN="LEFT"/>mainloop()<br ALIGN="LEFT"/>reset_workspace()<br ALIGN="LEFT"/><I>workspace_markprod</I>(production)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.draw.cfg.CFGEditor" [color="black", fontcolor="black", label=<{CFGEditor|ARROW<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"nltk.corpus.reader.childes.CHILDESCorpusReader" [color="black", fontcolor="black", label=<{CHILDESCorpusReader|childes_url_base : str<br ALIGN="LEFT"/>|MLU(fileids, speaker)<br ALIGN="LEFT"/>age(fileids, speaker, month)<br ALIGN="LEFT"/>convert_age(age_year)<br ALIGN="LEFT"/>corpus(fileids)<br ALIGN="LEFT"/>participants(fileids)<br ALIGN="LEFT"/>sents(fileids, speaker, stem, relation, strip_space, replace)<br ALIGN="LEFT"/>tagged_sents(fileids, speaker, stem, relation, strip_space, replace)<br ALIGN="LEFT"/>tagged_words(fileids, speaker, stem, relation, strip_space, replace)<br ALIGN="LEFT"/>webview_file(fileid, urlbase)<br ALIGN="LEFT"/>words(fileids, speaker, stem, relation, strip_space, replace)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.corpus.reader.cmudict.CMUDictCorpusReader" [color="black", fontcolor="black", label=<{CMUDictCorpusReader|<br ALIGN="LEFT"/>|dict()<br ALIGN="LEFT"/>entries()<br ALIGN="LEFT"/>raw()<br ALIGN="LEFT"/>words()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.tag.crf.CRFTagger" [color="black", fontcolor="black", label=<{CRFTagger|<br ALIGN="LEFT"/>|set_model_file(model_file)<br ALIGN="LEFT"/>tag(tokens)<br ALIGN="LEFT"/>tag_sents(sents)<br ALIGN="LEFT"/>train(train_data, model_file)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.parse.chart.CachedTopDownPredictRule" [color="black", fontcolor="black", label=<{CachedTopDownPredictRule|<br ALIGN="LEFT"/>|apply(chart, grammar, edge)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.draw.util.CanvasFrame" [color="black", fontcolor="black", label=<{CanvasFrame|<br ALIGN="LEFT"/>|add_widget(canvaswidget, x, y)<br ALIGN="LEFT"/>canvas()<br ALIGN="LEFT"/>destroy()<br ALIGN="LEFT"/>destroy_widget(canvaswidget)<br ALIGN="LEFT"/>mainloop()<br ALIGN="LEFT"/>pack(cnf)<br ALIGN="LEFT"/>print_to_file(filename)<br ALIGN="LEFT"/>remove_widget(canvaswidget)<br ALIGN="LEFT"/>scrollregion()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.draw.util.CanvasWidget" [color="black", fontcolor="black", label=<{CanvasWidget|<br ALIGN="LEFT"/>|bbox()<br ALIGN="LEFT"/>bind_click(callback, button)<br ALIGN="LEFT"/>bind_drag(callback)<br ALIGN="LEFT"/>canvas()<br ALIGN="LEFT"/>child_widgets()<br ALIGN="LEFT"/>destroy()<br ALIGN="LEFT"/>height()<br ALIGN="LEFT"/>hidden()<br ALIGN="LEFT"/>hide()<br ALIGN="LEFT"/>manage()<br ALIGN="LEFT"/>move(dx, dy)<br ALIGN="LEFT"/>moveto(x, y, anchor)<br ALIGN="LEFT"/>parent()<br ALIGN="LEFT"/>show()<br ALIGN="LEFT"/>tags()<br ALIGN="LEFT"/>unbind_click(button)<br ALIGN="LEFT"/>unbind_drag()<br ALIGN="LEFT"/>update(child)<br ALIGN="LEFT"/>width()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.inference.tableau.Categories" [color="black", fontcolor="black", label=<{Categories|ALL : int<br ALIGN="LEFT"/>AND : int<br ALIGN="LEFT"/>APP : int<br ALIGN="LEFT"/>ATOM : int<br ALIGN="LEFT"/>D_NEG : int<br ALIGN="LEFT"/>EQ : int<br ALIGN="LEFT"/>EXISTS : int<br ALIGN="LEFT"/>IFF : int<br ALIGN="LEFT"/>IMP : int<br ALIGN="LEFT"/>N_ALL : int<br ALIGN="LEFT"/>N_AND : int<br ALIGN="LEFT"/>N_APP : int<br ALIGN="LEFT"/>N_ATOM : int<br ALIGN="LEFT"/>N_EQ : int<br ALIGN="LEFT"/>N_EXISTS : int<br ALIGN="LEFT"/>N_IFF : int<br ALIGN="LEFT"/>N_IMP : int<br ALIGN="LEFT"/>N_OR : int<br ALIGN="LEFT"/>N_PROP : int<br ALIGN="LEFT"/>OR : int<br ALIGN="LEFT"/>PROP : int<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"nltk.corpus.reader.bracket_parse.CategorizedBracketParseCorpusReader" [color="black", fontcolor="black", label=<{CategorizedBracketParseCorpusReader|<br ALIGN="LEFT"/>|paras(fileids, categories)<br ALIGN="LEFT"/>parsed_paras(fileids, categories)<br ALIGN="LEFT"/>parsed_sents(fileids, categories)<br ALIGN="LEFT"/>parsed_words(fileids, categories)<br ALIGN="LEFT"/>raw(fileids, categories)<br ALIGN="LEFT"/>sents(fileids, categories)<br ALIGN="LEFT"/>tagged_paras(fileids, categories, tagset)<br ALIGN="LEFT"/>tagged_sents(fileids, categories, tagset)<br ALIGN="LEFT"/>tagged_words(fileids, categories, tagset)<br ALIGN="LEFT"/>words(fileids, categories)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.corpus.reader.api.CategorizedCorpusReader" [color="black", fontcolor="black", label=<{CategorizedCorpusReader|<br ALIGN="LEFT"/>|categories(fileids)<br ALIGN="LEFT"/>fileids(categories)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.corpus.reader.plaintext.CategorizedPlaintextCorpusReader" [color="black", fontcolor="black", label=<{CategorizedPlaintextCorpusReader|<br ALIGN="LEFT"/>|paras(fileids, categories)<br ALIGN="LEFT"/>raw(fileids, categories)<br ALIGN="LEFT"/>sents(fileids, categories)<br ALIGN="LEFT"/>words(fileids, categories)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.corpus.reader.tagged.CategorizedTaggedCorpusReader" [color="black", fontcolor="black", label=<{CategorizedTaggedCorpusReader|<br ALIGN="LEFT"/>|paras(fileids, categories)<br ALIGN="LEFT"/>raw(fileids, categories)<br ALIGN="LEFT"/>sents(fileids, categories)<br ALIGN="LEFT"/>tagged_paras(fileids, categories, tagset)<br ALIGN="LEFT"/>tagged_sents(fileids, categories, tagset)<br ALIGN="LEFT"/>tagged_words(fileids, categories, tagset)<br ALIGN="LEFT"/>words(fileids, categories)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.inference.discourse.CfgReadingCommand" [color="black", fontcolor="black", label=<{CfgReadingCommand|<br ALIGN="LEFT"/>|combine_readings(readings)<br ALIGN="LEFT"/>parse_to_readings(sentence)<br ALIGN="LEFT"/>to_fol(expression)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.tokenize.simple.CharTokenizer" [color="black", fontcolor="black", label=<{CharTokenizer|<br ALIGN="LEFT"/>|span_tokenize(s)<br ALIGN="LEFT"/>tokenize(s)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.parse.chart.Chart" [color="black", fontcolor="black", label=<{Chart|<br ALIGN="LEFT"/>|child_pointer_lists(edge)<br ALIGN="LEFT"/>dot_digraph()<br ALIGN="LEFT"/>edges()<br ALIGN="LEFT"/>initialize()<br ALIGN="LEFT"/>insert(edge)<br ALIGN="LEFT"/>insert_with_backpointer(new_edge, previous_edge, child_edge)<br ALIGN="LEFT"/>iteredges()<br ALIGN="LEFT"/>leaf(index)<br ALIGN="LEFT"/>leaves()<br ALIGN="LEFT"/>num_edges()<br ALIGN="LEFT"/>num_leaves()<br ALIGN="LEFT"/>parses(root, tree_class)<br ALIGN="LEFT"/>pretty_format(width)<br ALIGN="LEFT"/>pretty_format_edge(edge, width)<br ALIGN="LEFT"/>pretty_format_leaves(width)<br ALIGN="LEFT"/>select()<br ALIGN="LEFT"/>trees(edge, tree_class, complete)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.parse.projectivedependencyparser.ChartCell" [color="black", fontcolor="black", label=<{ChartCell|<br ALIGN="LEFT"/>|add(span)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.app.chartparser_app.ChartComparer" [color="black", fontcolor="black", label=<{ChartComparer|CHART_FILE_TYPES : list<br ALIGN="LEFT"/>|destroy()<br ALIGN="LEFT"/>load_chart(filename)<br ALIGN="LEFT"/>load_chart_dialog()<br ALIGN="LEFT"/>mainloop()<br ALIGN="LEFT"/>save_chart_dialog()<br ALIGN="LEFT"/>select_cell(i, j)<br ALIGN="LEFT"/>select_edge(edge)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.app.chartparser_app.ChartMatrixView" [color="black", fontcolor="black", label=<{ChartMatrixView|<br ALIGN="LEFT"/>|activate()<br ALIGN="LEFT"/>add_callback(event, func)<br ALIGN="LEFT"/>deselect_cell()<br ALIGN="LEFT"/>destroy()<br ALIGN="LEFT"/>draw()<br ALIGN="LEFT"/>inactivate()<br ALIGN="LEFT"/>mark_edge(edge)<br ALIGN="LEFT"/>markonly_edge(edge)<br ALIGN="LEFT"/>pack()<br ALIGN="LEFT"/>remove_callback(event, func)<br ALIGN="LEFT"/>select_cell(i, j)<br ALIGN="LEFT"/>set_chart(chart)<br ALIGN="LEFT"/>unmark_edge(edge)<br ALIGN="LEFT"/>update()<br ALIGN="LEFT"/>view_edge(edge)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.parse.chart.ChartParser" [color="black", fontcolor="black", label=<{ChartParser|<br ALIGN="LEFT"/>|chart_parse(tokens, trace)<br ALIGN="LEFT"/>grammar()<br ALIGN="LEFT"/>parse(tokens, tree_class)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.app.chartparser_app.ChartParserApp" [color="black", fontcolor="black", label=<{ChartParserApp|CHART_FILE_TYPES : list<br ALIGN="LEFT"/>GRAMMAR_FILE_TYPES : list<br ALIGN="LEFT"/>|about()<br ALIGN="LEFT"/>apply_strategy(strategy, edge_strategy)<br ALIGN="LEFT"/>bottom_up()<br ALIGN="LEFT"/>bottom_up_leftcorner()<br ALIGN="LEFT"/>bottom_up_leftcorner_strategy()<br ALIGN="LEFT"/>bottom_up_strategy()<br ALIGN="LEFT"/>destroy()<br ALIGN="LEFT"/>edit_grammar()<br ALIGN="LEFT"/>edit_sentence()<br ALIGN="LEFT"/>fundamental()<br ALIGN="LEFT"/>get_font_size()<br ALIGN="LEFT"/>help()<br ALIGN="LEFT"/>load_chart()<br ALIGN="LEFT"/>load_grammar()<br ALIGN="LEFT"/>mainloop()<br ALIGN="LEFT"/>reset()<br ALIGN="LEFT"/>resize()<br ALIGN="LEFT"/>save_chart()<br ALIGN="LEFT"/>save_grammar()<br ALIGN="LEFT"/>set_font_size(size)<br ALIGN="LEFT"/>set_grammar(grammar)<br ALIGN="LEFT"/>set_sentence(sentence)<br ALIGN="LEFT"/>top_down_init()<br ALIGN="LEFT"/>top_down_predict()<br ALIGN="LEFT"/>top_down_strategy()<br ALIGN="LEFT"/>view_matrix()<br ALIGN="LEFT"/>view_results()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.app.chartparser_app.ChartResultsView" [color="black", fontcolor="black", label=<{ChartResultsView|<br ALIGN="LEFT"/>|clear()<br ALIGN="LEFT"/>destroy()<br ALIGN="LEFT"/>pack()<br ALIGN="LEFT"/>print_all()<br ALIGN="LEFT"/>print_selection()<br ALIGN="LEFT"/>set_chart(chart)<br ALIGN="LEFT"/>set_grammar(grammar)<br ALIGN="LEFT"/>update(edge)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.parse.chart.ChartRuleI" [color="black", fontcolor="black", label=<{ChartRuleI|<br ALIGN="LEFT"/>|<I>apply</I>(chart, grammar)<br ALIGN="LEFT"/><I>apply_everywhere</I>(chart, grammar)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.app.chartparser_app.ChartView" [color="black", fontcolor="black", label=<{ChartView|<br ALIGN="LEFT"/>|add_callback(event, func)<br ALIGN="LEFT"/>cycle_tree()<br ALIGN="LEFT"/>draw()<br ALIGN="LEFT"/>draw_tree(edge)<br ALIGN="LEFT"/>erase_tree()<br ALIGN="LEFT"/>get_font_size()<br ALIGN="LEFT"/>mark_edge(edge, mark)<br ALIGN="LEFT"/>markonly_edge(edge, mark)<br ALIGN="LEFT"/>page_down()<br ALIGN="LEFT"/>page_up()<br ALIGN="LEFT"/>remove_callback(event, func)<br ALIGN="LEFT"/>scroll_down()<br ALIGN="LEFT"/>scroll_up()<br ALIGN="LEFT"/>set_font_size(size)<br ALIGN="LEFT"/>unmark_edge(edge)<br ALIGN="LEFT"/>update(chart)<br ALIGN="LEFT"/>view_edge(edge)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.corpus.reader.chasen.ChasenCorpusReader" [color="black", fontcolor="black", label=<{ChasenCorpusReader|<br ALIGN="LEFT"/>|paras(fileids)<br ALIGN="LEFT"/>raw(fileids)<br ALIGN="LEFT"/>sents(fileids)<br ALIGN="LEFT"/>tagged_paras(fileids)<br ALIGN="LEFT"/>tagged_sents(fileids)<br ALIGN="LEFT"/>tagged_words(fileids)<br ALIGN="LEFT"/>words(fileids)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.corpus.reader.chasen.ChasenCorpusView" [color="black", fontcolor="black", label=<{ChasenCorpusView|<br ALIGN="LEFT"/>|read_block(stream)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.chat.util.Chat" [color="black", fontcolor="black", label=<{Chat|<br ALIGN="LEFT"/>|converse(quit)<br ALIGN="LEFT"/>respond(str)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.chunk.regexp.ChinkRule" [color="black", fontcolor="black", label=<{ChinkRule|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"nltk.chunk.api.ChunkParserI" [color="black", fontcolor="black", label=<{ChunkParserI|<br ALIGN="LEFT"/>|evaluate(gold)<br ALIGN="LEFT"/><I>parse</I>(tokens)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.chunk.regexp.ChunkRule" [color="black", fontcolor="black", label=<{ChunkRule|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"nltk.chunk.regexp.ChunkRuleWithContext" [color="black", fontcolor="black", label=<{ChunkRuleWithContext|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"nltk.chunk.util.ChunkScore" [color="black", fontcolor="black", label=<{ChunkScore|<br ALIGN="LEFT"/>|accuracy()<br ALIGN="LEFT"/>correct()<br ALIGN="LEFT"/>f_measure(alpha)<br ALIGN="LEFT"/>guessed()<br ALIGN="LEFT"/>incorrect()<br ALIGN="LEFT"/>missed()<br ALIGN="LEFT"/>precision()<br ALIGN="LEFT"/>recall()<br ALIGN="LEFT"/>score(correct, guessed)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.chunk.regexp.ChunkString" [color="black", fontcolor="black", label=<{ChunkString|CHUNK_TAG : str<br ALIGN="LEFT"/>CHUNK_TAG_CHAR : str<br ALIGN="LEFT"/>IN_CHINK_PATTERN : str<br ALIGN="LEFT"/>IN_CHUNK_PATTERN : str<br ALIGN="LEFT"/>|to_chunkstruct(chunk_label)<br ALIGN="LEFT"/>xform(regexp, repl)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.corpus.reader.chunked.ChunkedCorpusReader" [color="black", fontcolor="black", label=<{ChunkedCorpusReader|<br ALIGN="LEFT"/>|chunked_paras(fileids)<br ALIGN="LEFT"/>chunked_sents(fileids)<br ALIGN="LEFT"/>chunked_words(fileids)<br ALIGN="LEFT"/>paras(fileids)<br ALIGN="LEFT"/>raw(fileids)<br ALIGN="LEFT"/>sents(fileids)<br ALIGN="LEFT"/>tagged_paras(fileids)<br ALIGN="LEFT"/>tagged_sents(fileids)<br ALIGN="LEFT"/>tagged_words(fileids)<br ALIGN="LEFT"/>words(fileids)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.corpus.reader.chunked.ChunkedCorpusView" [color="black", fontcolor="black", label=<{ChunkedCorpusView|<br ALIGN="LEFT"/>|read_block(stream)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.tag.sequential.ClassifierBasedPOSTagger" [color="black", fontcolor="black", label=<{ClassifierBasedPOSTagger|<br ALIGN="LEFT"/>|feature_detector(tokens, index, history)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.tag.sequential.ClassifierBasedTagger" [color="black", fontcolor="black", label=<{ClassifierBasedTagger|<br ALIGN="LEFT"/>|choose_tag(tokens, index, history)<br ALIGN="LEFT"/>classifier()<br ALIGN="LEFT"/>feature_detector(tokens, index, history)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.classify.api.ClassifierI" [color="black", fontcolor="black", label=<{ClassifierI|<br ALIGN="LEFT"/>|classify(featureset)<br ALIGN="LEFT"/>classify_many(featuresets)<br ALIGN="LEFT"/><I>labels</I>()<br ALIGN="LEFT"/>prob_classify(featureset)<br ALIGN="LEFT"/>prob_classify_many(featuresets)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.inference.resolution.Clause" [color="black", fontcolor="black", label=<{Clause|<br ALIGN="LEFT"/>|free()<br ALIGN="LEFT"/>isSubsetOf(other)<br ALIGN="LEFT"/>is_tautology()<br ALIGN="LEFT"/>replace(variable, expression)<br ALIGN="LEFT"/>substitute_bindings(bindings)<br ALIGN="LEFT"/>subsumes(other)<br ALIGN="LEFT"/>unify(other, bindings, used, skipped, debug)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.inference.nonmonotonic.ClosedDomainProver" [color="black", fontcolor="black", label=<{ClosedDomainProver|<br ALIGN="LEFT"/>|assumptions()<br ALIGN="LEFT"/>goal()<br ALIGN="LEFT"/>replace_quants(ex, domain)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.inference.nonmonotonic.ClosedWorldProver" [color="black", fontcolor="black", label=<{ClosedWorldProver|<br ALIGN="LEFT"/>|assumptions()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.cluster.api.ClusterI" [color="black", fontcolor="black", label=<{ClusterI|<br ALIGN="LEFT"/>|classification_probdist(vector)<br ALIGN="LEFT"/><I>classify</I>(token)<br ALIGN="LEFT"/><I>cluster</I>(vectors, assign_clusters)<br ALIGN="LEFT"/>cluster_name(index)<br ALIGN="LEFT"/>cluster_names()<br ALIGN="LEFT"/>likelihood(vector, label)<br ALIGN="LEFT"/><I>num_clusters</I>()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.downloader.Collection" [color="black", fontcolor="black", label=<{Collection|children<br ALIGN="LEFT"/>id<br ALIGN="LEFT"/>name<br ALIGN="LEFT"/>packages : NoneType<br ALIGN="LEFT"/>|fromxml(xml)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.app.collocations_app.CollocationsModel" [color="black", fontcolor="black", label=<{CollocationsModel|CORPORA : dict<br ALIGN="LEFT"/>DEFAULT_CORPUS : str<br ALIGN="LEFT"/>collocations : NoneType<br ALIGN="LEFT"/>queue<br ALIGN="LEFT"/>result_count : NoneType, int<br ALIGN="LEFT"/>result_pages : list<br ALIGN="LEFT"/>results_returned : int<br ALIGN="LEFT"/>selected_corpus : NoneType<br ALIGN="LEFT"/>|is_last_page(number)<br ALIGN="LEFT"/>load_corpus(name)<br ALIGN="LEFT"/>next(page)<br ALIGN="LEFT"/>non_default_corpora()<br ALIGN="LEFT"/>prev(page)<br ALIGN="LEFT"/>reset_results()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.app.collocations_app.CollocationsView" [color="black", fontcolor="black", label=<{CollocationsView|after : NoneType<br ALIGN="LEFT"/>current_page : int<br ALIGN="LEFT"/>main_frame : Frame<br ALIGN="LEFT"/>model<br ALIGN="LEFT"/>next : Button<br ALIGN="LEFT"/>prev : Button<br ALIGN="LEFT"/>queue : Queue<br ALIGN="LEFT"/>results_box : Text<br ALIGN="LEFT"/>status : Label<br ALIGN="LEFT"/>top : NoneType, Tk<br ALIGN="LEFT"/>var : StringVar<br ALIGN="LEFT"/>|clear_results_box()<br ALIGN="LEFT"/>corpus_selected()<br ALIGN="LEFT"/>destroy()<br ALIGN="LEFT"/>fire_event(event)<br ALIGN="LEFT"/>freeze_editable()<br ALIGN="LEFT"/>handle_corpus_loaded(event)<br ALIGN="LEFT"/>handle_error_loading_corpus(event)<br ALIGN="LEFT"/>load_corpus(selection)<br ALIGN="LEFT"/>mainloop()<br ALIGN="LEFT"/>previous()<br ALIGN="LEFT"/>reset_current_page()<br ALIGN="LEFT"/>set_paging_button_states()<br ALIGN="LEFT"/>set_result_size()<br ALIGN="LEFT"/>unfreeze_editable()<br ALIGN="LEFT"/>write_results(results)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.draw.util.ColorizedList" [color="black", fontcolor="black", label=<{ColorizedList|<br ALIGN="LEFT"/>|add_callback(event, func)<br ALIGN="LEFT"/>focus()<br ALIGN="LEFT"/>get(index)<br ALIGN="LEFT"/>grid(cnf)<br ALIGN="LEFT"/>mark(item)<br ALIGN="LEFT"/>markonly(item)<br ALIGN="LEFT"/>pack(cnf)<br ALIGN="LEFT"/>remove_callback(event, func)<br ALIGN="LEFT"/>set(items)<br ALIGN="LEFT"/>unmark(item)<br ALIGN="LEFT"/>view(item)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.parse.earleychart.CompleteFundamentalRule" [color="black", fontcolor="black", label=<{CompleteFundamentalRule|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"nltk.parse.earleychart.CompleterRule" [color="black", fontcolor="black", label=<{CompleterRule|<br ALIGN="LEFT"/>|apply(chart, grammar, edge)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.sem.logic.ComplexType" [color="black", fontcolor="black", label=<{ComplexType|first<br ALIGN="LEFT"/>second<br ALIGN="LEFT"/>|matches(other)<br ALIGN="LEFT"/>resolve(other)<br ALIGN="LEFT"/>str()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.corpus.reader.util.ConcatenatedCorpusView" [color="black", fontcolor="black", label=<{ConcatenatedCorpusView|<br ALIGN="LEFT"/>|close()<br ALIGN="LEFT"/>iterate_from(start_tok)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.sem.chat80.Concept" [color="black", fontcolor="black", label=<{Concept|altLabels : list<br ALIGN="LEFT"/>arity<br ALIGN="LEFT"/>closures : list<br ALIGN="LEFT"/>extension<br ALIGN="LEFT"/>prefLabel<br ALIGN="LEFT"/>|augment(data)<br ALIGN="LEFT"/>close()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.text.ConcordanceIndex" [color="black", fontcolor="black", label=<{ConcordanceIndex|<br ALIGN="LEFT"/>|offsets(word)<br ALIGN="LEFT"/>print_concordance(word, width, lines)<br ALIGN="LEFT"/>tokens()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.app.concordance_app.ConcordanceSearchModel" [color="black", fontcolor="black", label=<{ConcordanceSearchModel|CORPORA : dict<br ALIGN="LEFT"/>DEFAULT_CORPUS : str<br ALIGN="LEFT"/>last_page : NoneType<br ALIGN="LEFT"/>last_requested_page<br ALIGN="LEFT"/>last_sent_searched : int<br ALIGN="LEFT"/>query : NoneType<br ALIGN="LEFT"/>queue<br ALIGN="LEFT"/>result_count : NoneType, int<br ALIGN="LEFT"/>results : list<br ALIGN="LEFT"/>selected_corpus : NoneType<br ALIGN="LEFT"/>tagged_sents : list<br ALIGN="LEFT"/>|get_results()<br ALIGN="LEFT"/>has_more_pages(page)<br ALIGN="LEFT"/>load_corpus(name)<br ALIGN="LEFT"/>next(page)<br ALIGN="LEFT"/>non_default_corpora()<br ALIGN="LEFT"/>prev(page)<br ALIGN="LEFT"/>reset_query()<br ALIGN="LEFT"/>reset_results()<br ALIGN="LEFT"/>search(query, page)<br ALIGN="LEFT"/>set_results(page, resultset)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.app.concordance_app.ConcordanceSearchView" [color="black", fontcolor="black", label=<{ConcordanceSearchView|after : NoneType<br ALIGN="LEFT"/>current_page : int<br ALIGN="LEFT"/>main_frame : Frame<br ALIGN="LEFT"/>model<br ALIGN="LEFT"/>next : Button<br ALIGN="LEFT"/>prev : Button<br ALIGN="LEFT"/>query_box : Entry<br ALIGN="LEFT"/>queue : Queue<br ALIGN="LEFT"/>results_box : Text<br ALIGN="LEFT"/>search_button : Button<br ALIGN="LEFT"/>status : Label<br ALIGN="LEFT"/>top : NoneType, Tk<br ALIGN="LEFT"/>var : StringVar<br ALIGN="LEFT"/>|about()<br ALIGN="LEFT"/>clear_all()<br ALIGN="LEFT"/>clear_results_box()<br ALIGN="LEFT"/>corpus_selected()<br ALIGN="LEFT"/>destroy()<br ALIGN="LEFT"/>fire_event(event)<br ALIGN="LEFT"/>freeze_editable()<br ALIGN="LEFT"/>handle_corpus_loaded(event)<br ALIGN="LEFT"/>handle_error_loading_corpus(event)<br ALIGN="LEFT"/>handle_search_error(event)<br ALIGN="LEFT"/>handle_search_terminated(event)<br ALIGN="LEFT"/>load_corpus(selection)<br ALIGN="LEFT"/>mainloop()<br ALIGN="LEFT"/>pad(sent, hstart, hend)<br ALIGN="LEFT"/>previous()<br ALIGN="LEFT"/>search()<br ALIGN="LEFT"/>search_enter_keypress_handler()<br ALIGN="LEFT"/>set_cntx_af_len()<br ALIGN="LEFT"/>set_cntx_bf_len()<br ALIGN="LEFT"/>set_paging_button_states()<br ALIGN="LEFT"/>set_result_size()<br ALIGN="LEFT"/>unfreeze_editable()<br ALIGN="LEFT"/>words_and_labels(sentence, pos1, pos2)<br ALIGN="LEFT"/>write_results(results)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.probability.ConditionalFreqDist" [color="black", fontcolor="black", label=<{ConditionalFreqDist|<br ALIGN="LEFT"/>|N()<br ALIGN="LEFT"/>conditions()<br ALIGN="LEFT"/>plot()<br ALIGN="LEFT"/>tabulate()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.probability.ConditionalProbDist" [color="black", fontcolor="black", label=<{ConditionalProbDist|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"nltk.probability.ConditionalProbDistI" [color="black", fontcolor="black", label=<{ConditionalProbDistI|<br ALIGN="LEFT"/>|conditions()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.parse.transitionparser.Configuration" [color="black", fontcolor="black", label=<{Configuration|arcs : list<br ALIGN="LEFT"/>buffer : list<br ALIGN="LEFT"/>stack : list<br ALIGN="LEFT"/>|extract_features()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.metrics.confusionmatrix.ConfusionMatrix" [color="black", fontcolor="black", label=<{ConfusionMatrix|<br ALIGN="LEFT"/>|key()<br ALIGN="LEFT"/>pretty_format(show_percents, values_in_chart, truncate, sort_by_count)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.corpus.reader.conll.ConllChunkCorpusReader" [color="black", fontcolor="black", label=<{ConllChunkCorpusReader|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"nltk.corpus.reader.conll.ConllCorpusReader" [color="black", fontcolor="black", label=<{ConllCorpusReader|CHUNK : str<br ALIGN="LEFT"/>COLUMN_TYPES : tuple<br ALIGN="LEFT"/>IGNORE : str<br ALIGN="LEFT"/>NE : str<br ALIGN="LEFT"/>POS : str<br ALIGN="LEFT"/>SRL : str<br ALIGN="LEFT"/>TREE : str<br ALIGN="LEFT"/>WORDS : str<br ALIGN="LEFT"/>|chunked_sents(fileids, chunk_types, tagset)<br ALIGN="LEFT"/>chunked_words(fileids, chunk_types, tagset)<br ALIGN="LEFT"/>iob_sents(fileids, tagset)<br ALIGN="LEFT"/>iob_words(fileids, tagset)<br ALIGN="LEFT"/>parsed_sents(fileids, pos_in_tree, tagset)<br ALIGN="LEFT"/>raw(fileids)<br ALIGN="LEFT"/>sents(fileids)<br ALIGN="LEFT"/>srl_instances(fileids, pos_in_tree, flatten)<br ALIGN="LEFT"/>srl_spans(fileids)<br ALIGN="LEFT"/>tagged_sents(fileids, tagset)<br ALIGN="LEFT"/>tagged_words(fileids, tagset)<br ALIGN="LEFT"/>words(fileids)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.corpus.reader.conll.ConllSRLInstance" [color="black", fontcolor="black", label=<{ConllSRLInstance|arguments : list<br ALIGN="LEFT"/>roleset<br ALIGN="LEFT"/>tagged_spans<br ALIGN="LEFT"/>tree<br ALIGN="LEFT"/>verb : list<br ALIGN="LEFT"/>verb_head<br ALIGN="LEFT"/>verb_stem<br ALIGN="LEFT"/>words<br ALIGN="LEFT"/>|pprint()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.corpus.reader.conll.ConllSRLInstanceList" [color="black", fontcolor="black", label=<{ConllSRLInstanceList|tree<br ALIGN="LEFT"/>|pprint(include_tree)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.sem.linearlogic.ConstantExpression" [color="black", fontcolor="black", label=<{ConstantExpression|<br ALIGN="LEFT"/>|unify(other, bindings)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.sem.logic.ConstantExpression" [color="black", fontcolor="black", label=<{ConstantExpression|type<br ALIGN="LEFT"/>|constants()<br ALIGN="LEFT"/>free()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.sem.hole.Constants" [color="black", fontcolor="black", label=<{Constants|ALL : str<br ALIGN="LEFT"/>AND : str<br ALIGN="LEFT"/>EXISTS : str<br ALIGN="LEFT"/>HOLE : str<br ALIGN="LEFT"/>IFF : str<br ALIGN="LEFT"/>IMP : str<br ALIGN="LEFT"/>LABEL : str<br ALIGN="LEFT"/>LEQ : str<br ALIGN="LEFT"/>MAP : dict<br ALIGN="LEFT"/>NOT : str<br ALIGN="LEFT"/>OR : str<br ALIGN="LEFT"/>PRED : str<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"nltk.sem.hole.Constraint" [color="black", fontcolor="black", label=<{Constraint|lhs<br ALIGN="LEFT"/>rhs<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"nltk.text.ContextIndex" [color="black", fontcolor="black", label=<{ContextIndex|<br ALIGN="LEFT"/>|common_contexts(words, fail_on_unknown)<br ALIGN="LEFT"/>similar_words(word, n)<br ALIGN="LEFT"/>tokens()<br ALIGN="LEFT"/>word_similarity_dict(word)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.tag.sequential.ContextTagger" [color="black", fontcolor="black", label=<{ContextTagger|<br ALIGN="LEFT"/>|choose_tag(tokens, index, history)<br ALIGN="LEFT"/><I>context</I>(tokens, index, history)<br ALIGN="LEFT"/>size()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.metrics.association.ContingencyMeasures" [color="black", fontcolor="black", label=<{ContingencyMeasures|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"nltk.sem.cooper_storage.CooperStore" [color="black", fontcolor="black", label=<{CooperStore|core<br ALIGN="LEFT"/>featstruct<br ALIGN="LEFT"/>readings : list<br ALIGN="LEFT"/>store<br ALIGN="LEFT"/>|s_retrieve(trace)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.corpus.reader.api.CorpusReader" [color="black", fontcolor="black", label=<{CorpusReader|root<br ALIGN="LEFT"/>|abspath(fileid)<br ALIGN="LEFT"/>abspaths(fileids, include_encoding, include_fileid)<br ALIGN="LEFT"/>encoding(file)<br ALIGN="LEFT"/><I>ensure_loaded</I>()<br ALIGN="LEFT"/>fileids()<br ALIGN="LEFT"/>open(file)<br ALIGN="LEFT"/>readme()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.internals.Counter" [color="black", fontcolor="black", label=<{Counter|<br ALIGN="LEFT"/>|get()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.probability.CrossValidationProbDist" [color="black", fontcolor="black", label=<{CrossValidationProbDist|SUM_TO_ONE : bool<br ALIGN="LEFT"/>|<I>discount</I>()<br ALIGN="LEFT"/>freqdists()<br ALIGN="LEFT"/>prob(sample)<br ALIGN="LEFT"/>samples()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.featstruct.CustomFeatureValue" [color="black", fontcolor="black", label=<{CustomFeatureValue|<br ALIGN="LEFT"/>|<I>unify</I>(other)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.classify.util.CutoffChecker" [color="black", fontcolor="black", label=<{CutoffChecker|acc : NoneType<br ALIGN="LEFT"/>cutoffs<br ALIGN="LEFT"/>iter : int<br ALIGN="LEFT"/>ll : NoneType<br ALIGN="LEFT"/>|check(classifier, train_toks)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.sem.drt.DRS" [color="black", fontcolor="black", label=<{DRS|conds<br ALIGN="LEFT"/>consequent : NoneType<br ALIGN="LEFT"/>label<br ALIGN="LEFT"/>refs<br ALIGN="LEFT"/>|eliminate_equality()<br ALIGN="LEFT"/>fol()<br ALIGN="LEFT"/>free()<br ALIGN="LEFT"/>get_refs(recursive)<br ALIGN="LEFT"/>replace(variable, expression, replace_bound, alpha_convert)<br ALIGN="LEFT"/>visit(function, combinator)<br ALIGN="LEFT"/>visit_structured(function, combinator)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.stem.snowball.DanishStemmer" [color="black", fontcolor="black", label=<{DanishStemmer|<br ALIGN="LEFT"/>|stem(word)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.inference.tableau.Debug" [color="black", fontcolor="black", label=<{Debug|indent : int<br ALIGN="LEFT"/>lines : NoneType, list<br ALIGN="LEFT"/>verbose<br ALIGN="LEFT"/>|line(data, indent)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.inference.resolution.DebugObject" [color="black", fontcolor="black", label=<{DebugObject|enabled : bool<br ALIGN="LEFT"/>indent : int<br ALIGN="LEFT"/>|line(line)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.classify.decisiontree.DecisionTreeClassifier" [color="black", fontcolor="black", label=<{DecisionTreeClassifier|<br ALIGN="LEFT"/>|best_binary_stump(feature_names, labeled_featuresets, feature_values, verbose)<br ALIGN="LEFT"/>best_stump(feature_names, labeled_featuresets, verbose)<br ALIGN="LEFT"/>binary_stump(feature_name, feature_value, labeled_featuresets)<br ALIGN="LEFT"/>classify(featureset)<br ALIGN="LEFT"/>error(labeled_featuresets)<br ALIGN="LEFT"/>labels()<br ALIGN="LEFT"/>leaf(labeled_featuresets)<br ALIGN="LEFT"/>pretty_format(width, prefix, depth)<br ALIGN="LEFT"/>pseudocode(prefix, depth)<br ALIGN="LEFT"/>refine(labeled_featuresets, entropy_cutoff, depth_cutoff, support_cutoff, binary, feature_values, verbose)<br ALIGN="LEFT"/>stump(feature_name, labeled_featuresets)<br ALIGN="LEFT"/>train(labeled_featuresets, entropy_cutoff, depth_cutoff, support_cutoff, binary, feature_values, verbose)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.tag.sequential.DefaultTagger" [color="black", fontcolor="black", label=<{DefaultTagger|json_tag : str<br ALIGN="LEFT"/>|choose_tag(tokens, index, history)<br ALIGN="LEFT"/>decode_json_obj(obj)<br ALIGN="LEFT"/>encode_json_obj()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.parse.nonprojectivedependencyparser.DemoScorer" [color="black", fontcolor="black", label=<{DemoScorer|<br ALIGN="LEFT"/>|score(graph)<br ALIGN="LEFT"/>train(graphs)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.cluster.util.Dendrogram" [color="black", fontcolor="black", label=<{Dendrogram|<br ALIGN="LEFT"/>|groups(n)<br ALIGN="LEFT"/>merge()<br ALIGN="LEFT"/>show(leaf_labels)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.corpus.reader.dependency.DependencyCorpusReader" [color="black", fontcolor="black", label=<{DependencyCorpusReader|<br ALIGN="LEFT"/>|parsed_sents(fileids)<br ALIGN="LEFT"/>raw(fileids)<br ALIGN="LEFT"/>sents(fileids)<br ALIGN="LEFT"/>tagged_sents(fileids)<br ALIGN="LEFT"/>tagged_words(fileids)<br ALIGN="LEFT"/>words(fileids)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.corpus.reader.dependency.DependencyCorpusView" [color="black", fontcolor="black", label=<{DependencyCorpusView|<br ALIGN="LEFT"/>|read_block(stream)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.parse.evaluate.DependencyEvaluator" [color="black", fontcolor="black", label=<{DependencyEvaluator|<br ALIGN="LEFT"/>|eval()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.grammar.DependencyGrammar" [color="black", fontcolor="black", label=<{DependencyGrammar|<br ALIGN="LEFT"/>|contains(head, mod)<br ALIGN="LEFT"/>fromstring(input)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.parse.dependencygraph.DependencyGraph" [color="black", fontcolor="black", label=<{DependencyGraph|nodelist : list<br ALIGN="LEFT"/>nodes : defaultdict<br ALIGN="LEFT"/>nx_labels : dict<br ALIGN="LEFT"/>root : NoneType, dict<br ALIGN="LEFT"/>|add_arc(head_address, mod_address)<br ALIGN="LEFT"/>add_node(node)<br ALIGN="LEFT"/>connect_graph()<br ALIGN="LEFT"/>contains_address(node_address)<br ALIGN="LEFT"/>contains_cycle()<br ALIGN="LEFT"/>get_by_address(node_address)<br ALIGN="LEFT"/>get_cycle_path(curr_node, goal_node_index)<br ALIGN="LEFT"/>left_children(node_index)<br ALIGN="LEFT"/>load(filename, zero_based, cell_separator)<br ALIGN="LEFT"/>nx_graph()<br ALIGN="LEFT"/>redirect_arcs(originals, redirect)<br ALIGN="LEFT"/>remove_by_address(address)<br ALIGN="LEFT"/>right_children(node_index)<br ALIGN="LEFT"/>to_conll(style)<br ALIGN="LEFT"/>to_dot()<br ALIGN="LEFT"/>tree()<br ALIGN="LEFT"/>triples(node)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.parse.dependencygraph.DependencyGraphError" [color="black", fontcolor="red", label=<{DependencyGraphError|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"nltk.grammar.DependencyProduction" [color="black", fontcolor="black", label=<{DependencyProduction|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"nltk.parse.nonprojectivedependencyparser.DependencyScorerI" [color="black", fontcolor="black", label=<{DependencyScorerI|<br ALIGN="LEFT"/>|<I>score</I>(graph)<br ALIGN="LEFT"/><I>train</I>(graphs)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.parse.projectivedependencyparser.DependencySpan" [color="black", fontcolor="black", label=<{DependencySpan|<br ALIGN="LEFT"/>|head_index()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.internals.Deprecated" [color="black", fontcolor="black", label=<{Deprecated|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"nltk.probability.DictionaryConditionalProbDist" [color="black", fontcolor="black", label=<{DictionaryConditionalProbDist|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"nltk.probability.DictionaryProbDist" [color="black", fontcolor="black", label=<{DictionaryProbDist|<br ALIGN="LEFT"/>|logprob(sample)<br ALIGN="LEFT"/>max()<br ALIGN="LEFT"/>prob(sample)<br ALIGN="LEFT"/>samples()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.ccg.combinator.DirectedBinaryCombinator" [color="black", fontcolor="black", label=<{DirectedBinaryCombinator|<br ALIGN="LEFT"/>|<I>can_combine</I>(left, right)<br ALIGN="LEFT"/><I>combine</I>(left, right)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.ccg.api.Direction" [color="black", fontcolor="black", label=<{Direction|<br ALIGN="LEFT"/>|can_compose()<br ALIGN="LEFT"/>can_cross()<br ALIGN="LEFT"/>can_unify(other)<br ALIGN="LEFT"/>dir()<br ALIGN="LEFT"/>is_backward()<br ALIGN="LEFT"/>is_forward()<br ALIGN="LEFT"/>is_variable()<br ALIGN="LEFT"/>restrs()<br ALIGN="LEFT"/>substitute(subs)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.inference.discourse.DiscourseTester" [color="black", fontcolor="black", label=<{DiscourseTester|<br ALIGN="LEFT"/>|add_background(background, verbose)<br ALIGN="LEFT"/>add_sentence(sentence, informchk, consistchk)<br ALIGN="LEFT"/>background()<br ALIGN="LEFT"/>expand_threads(thread_id, threads)<br ALIGN="LEFT"/>grammar()<br ALIGN="LEFT"/>models(thread_id, show, verbose)<br ALIGN="LEFT"/>multiply(discourse, readings)<br ALIGN="LEFT"/>readings(sentence, threaded, verbose, filter, show_thread_readings)<br ALIGN="LEFT"/>retract_sentence(sentence, verbose)<br ALIGN="LEFT"/>sentences()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.test.doctest_nose_plugin.DoctestFix" [color="black", fontcolor="black", label=<{DoctestFix|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"nltk.test.doctest_nose_plugin.DoctestPluginHelper" [color="black", fontcolor="black", label=<{DoctestPluginHelper|OPTION_BY_NAME : tuple<br ALIGN="LEFT"/>doctest_result_var<br ALIGN="LEFT"/>doctest_tests<br ALIGN="LEFT"/>extension<br ALIGN="LEFT"/>finder : DocTestFinder<br ALIGN="LEFT"/>fixtures<br ALIGN="LEFT"/>optionflags : int<br ALIGN="LEFT"/>options : dict<br ALIGN="LEFT"/>|configure(options, config)<br ALIGN="LEFT"/>loadTestsFromFile(filename)<br ALIGN="LEFT"/>loadTestsFromFileUnicode(filename)<br ALIGN="LEFT"/>loadTestsFromModule(module)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.downloader.Downloader" [color="black", fontcolor="black", label=<{Downloader|DEFAULT_URL : str<br ALIGN="LEFT"/>INDEX_TIMEOUT : int<br ALIGN="LEFT"/>INSTALLED : str<br ALIGN="LEFT"/>NOT_INSTALLED : str<br ALIGN="LEFT"/>PARTIAL : str<br ALIGN="LEFT"/>STALE : str<br ALIGN="LEFT"/>download_dir<br ALIGN="LEFT"/>url<br ALIGN="LEFT"/>|clear_status_cache(id)<br ALIGN="LEFT"/>collections()<br ALIGN="LEFT"/>corpora()<br ALIGN="LEFT"/>default_download_dir()<br ALIGN="LEFT"/>download(info_or_id, download_dir, quiet, force, prefix, halt_on_error, raise_on_error)<br ALIGN="LEFT"/>incr_download(info_or_id, download_dir, force)<br ALIGN="LEFT"/>index()<br ALIGN="LEFT"/>info(id)<br ALIGN="LEFT"/>is_installed(info_or_id, download_dir)<br ALIGN="LEFT"/>is_stale(info_or_id, download_dir)<br ALIGN="LEFT"/>list(download_dir, show_packages, show_collections, header, more_prompt, skip_installed)<br ALIGN="LEFT"/>models()<br ALIGN="LEFT"/>packages()<br ALIGN="LEFT"/>status(info_or_id, download_dir)<br ALIGN="LEFT"/>update(quiet, prefix)<br ALIGN="LEFT"/>xmlinfo(id)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.downloader.DownloaderGUI" [color="black", fontcolor="black", label=<{DownloaderGUI|COLUMNS : list<br ALIGN="LEFT"/>COLUMN_WEIGHTS : dict<br ALIGN="LEFT"/>COLUMN_WIDTHS : dict<br ALIGN="LEFT"/>DEFAULT_COLUMN_WIDTH : int<br ALIGN="LEFT"/>HELP<br ALIGN="LEFT"/>INITIAL_COLUMNS : list<br ALIGN="LEFT"/>c<br ALIGN="LEFT"/>top : Tk<br ALIGN="LEFT"/>|about()<br ALIGN="LEFT"/>destroy()<br ALIGN="LEFT"/>help()<br ALIGN="LEFT"/>mainloop()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.downloader.DownloaderMessage" [color="black", fontcolor="black", label=<{DownloaderMessage|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"nltk.downloader.DownloaderShell" [color="black", fontcolor="black", label=<{DownloaderShell|<br ALIGN="LEFT"/>|run()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.sem.drt.DrsDrawer" [color="black", fontcolor="black", label=<{DrsDrawer|BUFFER : int<br ALIGN="LEFT"/>OUTERSPACE : int<br ALIGN="LEFT"/>TOPSPACE : int<br ALIGN="LEFT"/>canvas : Canvas, NoneType<br ALIGN="LEFT"/>drs<br ALIGN="LEFT"/>master : NoneType, Tk<br ALIGN="LEFT"/>|draw(x, y)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.sem.drt_glue_demo.DrsWidget" [color="black", fontcolor="black", label=<{DrsWidget|bbox : tuple<br ALIGN="LEFT"/>|clear()<br ALIGN="LEFT"/>draw()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.sem.drt.DrtAbstractVariableExpression" [color="black", fontcolor="black", label=<{DrtAbstractVariableExpression|<br ALIGN="LEFT"/>|eliminate_equality()<br ALIGN="LEFT"/>fol()<br ALIGN="LEFT"/>get_refs(recursive)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.sem.drt.DrtApplicationExpression" [color="black", fontcolor="black", label=<{DrtApplicationExpression|<br ALIGN="LEFT"/>|fol()<br ALIGN="LEFT"/>get_refs(recursive)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.sem.drt.DrtBinaryExpression" [color="black", fontcolor="black", label=<{DrtBinaryExpression|<br ALIGN="LEFT"/>|get_refs(recursive)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.sem.drt.DrtBooleanExpression" [color="black", fontcolor="black", label=<{DrtBooleanExpression|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"nltk.sem.drt.DrtConcatenation" [color="black", fontcolor="black", label=<{DrtConcatenation|consequent : NoneType<br ALIGN="LEFT"/>|eliminate_equality()<br ALIGN="LEFT"/>fol()<br ALIGN="LEFT"/>getOp()<br ALIGN="LEFT"/>get_refs(recursive)<br ALIGN="LEFT"/>replace(variable, expression, replace_bound, alpha_convert)<br ALIGN="LEFT"/>simplify()<br ALIGN="LEFT"/>visit(function, combinator)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.sem.drt.DrtConstantExpression" [color="black", fontcolor="black", label=<{DrtConstantExpression|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"nltk.sem.drt.DrtEqualityExpression" [color="black", fontcolor="black", label=<{DrtEqualityExpression|<br ALIGN="LEFT"/>|fol()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.sem.drt.DrtEventVariableExpression" [color="black", fontcolor="black", label=<{DrtEventVariableExpression|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"nltk.sem.drt.DrtExpression" [color="black", fontcolor="black", label=<{DrtExpression|type<br ALIGN="LEFT"/>|applyto(other)<br ALIGN="LEFT"/>draw()<br ALIGN="LEFT"/>eliminate_equality()<br ALIGN="LEFT"/>equiv(other, prover)<br ALIGN="LEFT"/>fromstring(s)<br ALIGN="LEFT"/><I>get_refs</I>(recursive)<br ALIGN="LEFT"/>is_pronoun_function()<br ALIGN="LEFT"/>make_EqualityExpression(first, second)<br ALIGN="LEFT"/>make_VariableExpression(variable)<br ALIGN="LEFT"/>pretty_format()<br ALIGN="LEFT"/>pretty_print()<br ALIGN="LEFT"/>resolve_anaphora()<br ALIGN="LEFT"/><I>typecheck</I>(signature)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.sem.drt.DrtFunctionVariableExpression" [color="black", fontcolor="black", label=<{DrtFunctionVariableExpression|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"nltk.sem.glue.DrtGlue" [color="black", fontcolor="black", label=<{DrtGlue|remove_duplicates : bool<br ALIGN="LEFT"/>|get_glue_dict()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.sem.drt_glue_demo.DrtGlueDemo" [color="black", fontcolor="black", label=<{DrtGlueDemo|<br ALIGN="LEFT"/>|about()<br ALIGN="LEFT"/>destroy()<br ALIGN="LEFT"/>mainloop()<br ALIGN="LEFT"/>next()<br ALIGN="LEFT"/>postscript()<br ALIGN="LEFT"/>prev()<br ALIGN="LEFT"/>resize(size)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.sem.glue.DrtGlueDict" [color="black", fontcolor="black", label=<{DrtGlueDict|<br ALIGN="LEFT"/>|get_GlueFormula_factory()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.sem.glue.DrtGlueFormula" [color="black", fontcolor="black", label=<{DrtGlueFormula|glue<br ALIGN="LEFT"/>indices : NoneType, set<br ALIGN="LEFT"/>meaning<br ALIGN="LEFT"/>|make_LambdaExpression(variable, term)<br ALIGN="LEFT"/>make_VariableExpression(name)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.inference.discourse.DrtGlueReadingCommand" [color="black", fontcolor="black", label=<{DrtGlueReadingCommand|<br ALIGN="LEFT"/>|combine_readings(readings)<br ALIGN="LEFT"/>parse_to_readings(sentence)<br ALIGN="LEFT"/>process_thread(sentence_readings)<br ALIGN="LEFT"/>to_fol(expression)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.sem.drt.DrtIndividualVariableExpression" [color="black", fontcolor="black", label=<{DrtIndividualVariableExpression|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"nltk.sem.drt.DrtLambdaExpression" [color="black", fontcolor="black", label=<{DrtLambdaExpression|<br ALIGN="LEFT"/>|alpha_convert(newvar)<br ALIGN="LEFT"/>fol()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.sem.drt.DrtNegatedExpression" [color="black", fontcolor="black", label=<{DrtNegatedExpression|<br ALIGN="LEFT"/>|fol()<br ALIGN="LEFT"/>get_refs(recursive)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.sem.drt.DrtOrExpression" [color="black", fontcolor="black", label=<{DrtOrExpression|<br ALIGN="LEFT"/>|fol()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.sem.drt.DrtParser" [color="black", fontcolor="black", label=<{DrtParser|operator_precedence : dict<br ALIGN="LEFT"/>|get_BooleanExpression_factory(tok)<br ALIGN="LEFT"/>get_all_symbols()<br ALIGN="LEFT"/>handle(tok, context)<br ALIGN="LEFT"/>handle_DRS(tok, context)<br ALIGN="LEFT"/>handle_conds(context)<br ALIGN="LEFT"/>handle_prop(tok, context)<br ALIGN="LEFT"/>handle_refs()<br ALIGN="LEFT"/>isvariable(tok)<br ALIGN="LEFT"/>make_ApplicationExpression(function, argument)<br ALIGN="LEFT"/>make_BooleanExpression(factory, first, second)<br ALIGN="LEFT"/>make_EqualityExpression(first, second)<br ALIGN="LEFT"/>make_LambdaExpression(variables, term)<br ALIGN="LEFT"/>make_NegatedExpression(expression)<br ALIGN="LEFT"/>make_VariableExpression(name)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.sem.drt.DrtProposition" [color="black", fontcolor="black", label=<{DrtProposition|drs<br ALIGN="LEFT"/>variable<br ALIGN="LEFT"/>|eliminate_equality()<br ALIGN="LEFT"/>fol()<br ALIGN="LEFT"/>get_refs(recursive)<br ALIGN="LEFT"/>replace(variable, expression, replace_bound, alpha_convert)<br ALIGN="LEFT"/>visit(function, combinator)<br ALIGN="LEFT"/>visit_structured(function, combinator)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.sem.drt.DrtTokens" [color="black", fontcolor="black", label=<{DrtTokens|CLOSE_BRACKET : str<br ALIGN="LEFT"/>COLON : str<br ALIGN="LEFT"/>DRS : str<br ALIGN="LEFT"/>DRS_CONC : str<br ALIGN="LEFT"/>OPEN_BRACKET : str<br ALIGN="LEFT"/>PRONOUN : str<br ALIGN="LEFT"/>PUNCT : list<br ALIGN="LEFT"/>SYMBOLS<br ALIGN="LEFT"/>TOKENS<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"nltk.stem.snowball.DutchStemmer" [color="black", fontcolor="black", label=<{DutchStemmer|<br ALIGN="LEFT"/>|stem(word)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.probability.ELEProbDist" [color="black", fontcolor="black", label=<{ELEProbDist|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"nltk.cluster.em.EMClusterer" [color="black", fontcolor="black", label=<{EMClusterer|<br ALIGN="LEFT"/>|classify_vectorspace(vector)<br ALIGN="LEFT"/>cluster_vectorspace(vectors, trace)<br ALIGN="LEFT"/>likelihood_vectorspace(vector, cluster)<br ALIGN="LEFT"/>num_clusters()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.parse.earleychart.EarleyChartParser" [color="black", fontcolor="black", label=<{EarleyChartParser|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"nltk.parse.chart.EdgeI" [color="black", fontcolor="black", label=<{EdgeI|<br ALIGN="LEFT"/>|<I>dot</I>()<br ALIGN="LEFT"/><I>end</I>()<br ALIGN="LEFT"/><I>is_complete</I>()<br ALIGN="LEFT"/><I>is_incomplete</I>()<br ALIGN="LEFT"/><I>length</I>()<br ALIGN="LEFT"/><I>lhs</I>()<br ALIGN="LEFT"/><I>nextsym</I>()<br ALIGN="LEFT"/><I>rhs</I>()<br ALIGN="LEFT"/><I>span</I>()<br ALIGN="LEFT"/><I>start</I>()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.app.chartparser_app.EdgeList" [color="black", fontcolor="black", label=<{EdgeList|ARROW<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"nltk.app.chartparser_app.EdgeRule" [color="black", fontcolor="black", label=<{EdgeRule|NUM_EDGES<br ALIGN="LEFT"/>|apply(chart, grammar)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.internals.ElementWrapper" [color="black", fontcolor="black", label=<{ElementWrapper|<br ALIGN="LEFT"/>|find(path)<br ALIGN="LEFT"/>findall(path)<br ALIGN="LEFT"/>getchildren()<br ALIGN="LEFT"/>getiterator(tag)<br ALIGN="LEFT"/>makeelement(tag, attrib)<br ALIGN="LEFT"/>unwrap()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.parse.chart.EmptyPredictRule" [color="black", fontcolor="black", label=<{EmptyPredictRule|NUM_EDGES : int<br ALIGN="LEFT"/>|apply(chart, grammar)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.stem.snowball.EnglishStemmer" [color="black", fontcolor="black", label=<{EnglishStemmer|<br ALIGN="LEFT"/>|stem(word)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.sem.logic.EntityType" [color="black", fontcolor="black", label=<{EntityType|<br ALIGN="LEFT"/>|str()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.draw.util.EntryDialog" [color="black", fontcolor="black", label=<{EntryDialog|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"nltk.sem.logic.EqualityExpression" [color="black", fontcolor="black", label=<{EqualityExpression|<br ALIGN="LEFT"/>|getOp()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.sem.evaluate.Error" [color="black", fontcolor="red", label=<{Error|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"nltk.downloader.ErrorMessage" [color="black", fontcolor="black", label=<{ErrorMessage|message : str<br ALIGN="LEFT"/>package<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"nltk.corpus.reader.plaintext.EuroparlCorpusReader" [color="black", fontcolor="black", label=<{EuroparlCorpusReader|<br ALIGN="LEFT"/>|chapters(fileids)<br ALIGN="LEFT"/><I>paras</I>(fileids)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.sem.logic.EventType" [color="black", fontcolor="black", label=<{EventType|<br ALIGN="LEFT"/>|str()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.sem.logic.EventVariableExpression" [color="black", fontcolor="black", label=<{EventVariableExpression|type<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"nltk.sem.logic.ExistsExpression" [color="black", fontcolor="black", label=<{ExistsExpression|<br ALIGN="LEFT"/>|getQuantifier()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.chunk.regexp.ExpandLeftRule" [color="black", fontcolor="black", label=<{ExpandLeftRule|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"nltk.chunk.regexp.ExpandRightRule" [color="black", fontcolor="black", label=<{ExpandRightRule|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"nltk.sem.logic.ExpectedMoreTokensException" [color="black", fontcolor="red", label=<{ExpectedMoreTokensException|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"nltk.sem.linearlogic.Expression" [color="black", fontcolor="black", label=<{Expression|<br ALIGN="LEFT"/>|applyto(other, other_indices)<br ALIGN="LEFT"/>fromstring(s)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.sem.logic.Expression" [color="black", fontcolor="black", label=<{Expression|<br ALIGN="LEFT"/>|applyto(other)<br ALIGN="LEFT"/>constants()<br ALIGN="LEFT"/>equiv(other, prover)<br ALIGN="LEFT"/><I>findtype</I>(variable)<br ALIGN="LEFT"/>free()<br ALIGN="LEFT"/>fromstring(s, type_check, signature)<br ALIGN="LEFT"/>make_VariableExpression(variable)<br ALIGN="LEFT"/>negate()<br ALIGN="LEFT"/>normalize(newvars)<br ALIGN="LEFT"/>predicates()<br ALIGN="LEFT"/>replace(variable, expression, replace_bound, alpha_convert)<br ALIGN="LEFT"/>simplify()<br ALIGN="LEFT"/>substitute_bindings(bindings)<br ALIGN="LEFT"/>typecheck(signature)<br ALIGN="LEFT"/>variables()<br ALIGN="LEFT"/><I>visit</I>(function, combinator)<br ALIGN="LEFT"/>visit_structured(function, combinator)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.sem.lfg.FStructure" [color="black", fontcolor="black", label=<{FStructure|label<br ALIGN="LEFT"/>parent : NoneType<br ALIGN="LEFT"/>pred : NoneType, tuple<br ALIGN="LEFT"/>|pretty_format(indent)<br ALIGN="LEFT"/>read_depgraph(depgraph)<br ALIGN="LEFT"/>safeappend(key, item)<br ALIGN="LEFT"/>to_depgraph(rel)<br ALIGN="LEFT"/>to_glueformula_list(glue_dict)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.featstruct.FeatDict" [color="black", fontcolor="black", label=<{FeatDict|clear<br ALIGN="LEFT"/>pop<br ALIGN="LEFT"/>popitem<br ALIGN="LEFT"/>setdefault<br ALIGN="LEFT"/>|get(name_or_path, default)<br ALIGN="LEFT"/>has_key(name_or_path)<br ALIGN="LEFT"/>update(features)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.featstruct.FeatList" [color="black", fontcolor="black", label=<{FeatList|append<br ALIGN="LEFT"/>extend<br ALIGN="LEFT"/>insert<br ALIGN="LEFT"/>pop<br ALIGN="LEFT"/>remove<br ALIGN="LEFT"/>reverse<br ALIGN="LEFT"/>sort<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"nltk.featstruct.FeatStruct" [color="black", fontcolor="black", label=<{FeatStruct|<br ALIGN="LEFT"/>|copy(deep)<br ALIGN="LEFT"/>cyclic()<br ALIGN="LEFT"/>equal_values(other, check_reentrance)<br ALIGN="LEFT"/>freeze()<br ALIGN="LEFT"/>frozen()<br ALIGN="LEFT"/>remove_variables()<br ALIGN="LEFT"/>rename_variables(vars, used_vars, new_vars)<br ALIGN="LEFT"/>retract_bindings(bindings)<br ALIGN="LEFT"/>substitute_bindings(bindings)<br ALIGN="LEFT"/>subsumes(other)<br ALIGN="LEFT"/>unify(other, bindings, trace, fail, rename_vars)<br ALIGN="LEFT"/>variables()<br ALIGN="LEFT"/>walk()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.grammar.FeatStructNonterminal" [color="black", fontcolor="black", label=<{FeatStructNonterminal|<br ALIGN="LEFT"/>|symbol()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.featstruct.FeatStructReader" [color="black", fontcolor="black", label=<{FeatStructReader|VALUE_HANDLERS : list<br ALIGN="LEFT"/>|fromstring(s, fstruct)<br ALIGN="LEFT"/>read_app_value(s, position, reentrances, match)<br ALIGN="LEFT"/>read_fstruct_value(s, position, reentrances, match)<br ALIGN="LEFT"/>read_int_value(s, position, reentrances, match)<br ALIGN="LEFT"/>read_logic_value(s, position, reentrances, match)<br ALIGN="LEFT"/>read_partial(s, position, reentrances, fstruct)<br ALIGN="LEFT"/>read_set_value(s, position, reentrances, match)<br ALIGN="LEFT"/>read_str_value(s, position, reentrances, match)<br ALIGN="LEFT"/>read_sym_value(s, position, reentrances, match)<br ALIGN="LEFT"/>read_tuple_value(s, position, reentrances, match)<br ALIGN="LEFT"/>read_value(s, position, reentrances)<br ALIGN="LEFT"/>read_var_value(s, position, reentrances, match)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.featstruct.Feature" [color="black", fontcolor="black", label=<{Feature|default<br ALIGN="LEFT"/>display<br ALIGN="LEFT"/>name<br ALIGN="LEFT"/>|read_value(s, position, reentrances, parser)<br ALIGN="LEFT"/>unify_base_values(fval1, fval2, bindings)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.tbl.feature.Feature" [color="black", fontcolor="black", label=<{Feature|PROPERTY_NAME : NoneType<br ALIGN="LEFT"/>json_tag : str<br ALIGN="LEFT"/>positions : NoneType, tuple<br ALIGN="LEFT"/>|decode_json_obj(obj)<br ALIGN="LEFT"/>encode_json_obj()<br ALIGN="LEFT"/>expand(starts, winlens, excludezero)<br ALIGN="LEFT"/><I>extract_property</I>(tokens, index)<br ALIGN="LEFT"/>intersects(other)<br ALIGN="LEFT"/>issuperset(other)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.parse.featurechart.FeatureBottomUpChartParser" [color="black", fontcolor="black", label=<{FeatureBottomUpChartParser|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"nltk.parse.featurechart.FeatureBottomUpLeftCornerChartParser" [color="black", fontcolor="black", label=<{FeatureBottomUpLeftCornerChartParser|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"nltk.parse.featurechart.FeatureBottomUpPredictCombineRule" [color="black", fontcolor="black", label=<{FeatureBottomUpPredictCombineRule|<br ALIGN="LEFT"/>|apply(chart, grammar, edge)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.parse.featurechart.FeatureBottomUpPredictRule" [color="black", fontcolor="black", label=<{FeatureBottomUpPredictRule|<br ALIGN="LEFT"/>|apply(chart, grammar, edge)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.parse.featurechart.FeatureChart" [color="black", fontcolor="black", label=<{FeatureChart|<br ALIGN="LEFT"/>|parses(start, tree_class)<br ALIGN="LEFT"/>select()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.parse.featurechart.FeatureChartParser" [color="black", fontcolor="black", label=<{FeatureChartParser|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"nltk.parse.earleychart.FeatureCompleteFundamentalRule" [color="black", fontcolor="black", label=<{FeatureCompleteFundamentalRule|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"nltk.parse.earleychart.FeatureCompleterRule" [color="black", fontcolor="black", label=<{FeatureCompleterRule|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"nltk.parse.earleychart.FeatureEarleyChartParser" [color="black", fontcolor="black", label=<{FeatureEarleyChartParser|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"nltk.parse.featurechart.FeatureEmptyPredictRule" [color="black", fontcolor="black", label=<{FeatureEmptyPredictRule|<br ALIGN="LEFT"/>|apply(chart, grammar)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.parse.featurechart.FeatureFundamentalRule" [color="black", fontcolor="black", label=<{FeatureFundamentalRule|<br ALIGN="LEFT"/>|apply(chart, grammar, left_edge, right_edge)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.grammar.FeatureGrammar" [color="black", fontcolor="black", label=<{FeatureGrammar|<br ALIGN="LEFT"/>|fromstring(input, features, logic_parser, fstruct_reader, encoding)<br ALIGN="LEFT"/><I>leftcorner_parents</I>(cat)<br ALIGN="LEFT"/><I>leftcorners</I>(cat)<br ALIGN="LEFT"/>productions(lhs, rhs, empty)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.parse.earleychart.FeatureIncrementalBottomUpChartParser" [color="black", fontcolor="black", label=<{FeatureIncrementalBottomUpChartParser|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"nltk.parse.earleychart.FeatureIncrementalBottomUpLeftCornerChartParser" [color="black", fontcolor="black", label=<{FeatureIncrementalBottomUpLeftCornerChartParser|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"nltk.parse.earleychart.FeatureIncrementalChart" [color="black", fontcolor="black", label=<{FeatureIncrementalChart|<br ALIGN="LEFT"/>|select(end)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.parse.earleychart.FeatureIncrementalChartParser" [color="black", fontcolor="black", label=<{FeatureIncrementalChartParser|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"nltk.parse.earleychart.FeatureIncrementalTopDownChartParser" [color="black", fontcolor="black", label=<{FeatureIncrementalTopDownChartParser|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"nltk.parse.earleychart.FeaturePredictorRule" [color="black", fontcolor="black", label=<{FeaturePredictorRule|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"nltk.parse.earleychart.FeatureScannerRule" [color="black", fontcolor="black", label=<{FeatureScannerRule|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"nltk.parse.featurechart.FeatureSingleEdgeFundamentalRule" [color="black", fontcolor="black", label=<{FeatureSingleEdgeFundamentalRule|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"nltk.parse.featurechart.FeatureTopDownChartParser" [color="black", fontcolor="black", label=<{FeatureTopDownChartParser|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"nltk.parse.featurechart.FeatureTopDownInitRule" [color="black", fontcolor="black", label=<{FeatureTopDownInitRule|<br ALIGN="LEFT"/>|apply(chart, grammar)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.parse.featurechart.FeatureTopDownPredictRule" [color="black", fontcolor="black", label=<{FeatureTopDownPredictRule|<br ALIGN="LEFT"/>|apply(chart, grammar, edge)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.parse.featurechart.FeatureTreeEdge" [color="black", fontcolor="black", label=<{FeatureTreeEdge|<br ALIGN="LEFT"/>|bindings()<br ALIGN="LEFT"/>from_production(production, index)<br ALIGN="LEFT"/>move_dot_forward(new_end, bindings)<br ALIGN="LEFT"/>next_with_bindings()<br ALIGN="LEFT"/>variables()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.featstruct.FeatureValueConcat" [color="black", fontcolor="black", label=<{FeatureValueConcat|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"nltk.featstruct.FeatureValueSet" [color="black", fontcolor="black", label=<{FeatureValueSet|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"nltk.featstruct.FeatureValueTuple" [color="black", fontcolor="black", label=<{FeatureValueTuple|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"nltk.grammar.FeatureValueType" [color="black", fontcolor="black", label=<{FeatureValueType|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"nltk.featstruct.FeatureValueUnion" [color="black", fontcolor="black", label=<{FeatureValueUnion|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"nltk.tag.api.FeaturesetTaggerI" [color="black", fontcolor="black", label=<{FeaturesetTaggerI|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"nltk.data.FileSystemPathPointer" [color="black", fontcolor="black", label=<{FileSystemPathPointer|path<br ALIGN="LEFT"/>|file_size()<br ALIGN="LEFT"/>join(fileid)<br ALIGN="LEFT"/>open(encoding)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.parse.chart.FilteredBottomUpPredictCombineRule" [color="black", fontcolor="black", label=<{FilteredBottomUpPredictCombineRule|<br ALIGN="LEFT"/>|apply(chart, grammar, edge)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.parse.earleychart.FilteredCompleteFundamentalRule" [color="black", fontcolor="black", label=<{FilteredCompleteFundamentalRule|<br ALIGN="LEFT"/>|apply(chart, grammar, edge)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.parse.chart.FilteredSingleEdgeFundamentalRule" [color="black", fontcolor="black", label=<{FilteredSingleEdgeFundamentalRule|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"nltk.app.nemo_app.FindZone" [color="black", fontcolor="black", label=<{FindZone|rex<br ALIGN="LEFT"/>rexSel<br ALIGN="LEFT"/>|addTags(m)<br ALIGN="LEFT"/>substitute()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.downloader.FinishCollectionMessage" [color="black", fontcolor="black", label=<{FinishCollectionMessage|collection<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"nltk.downloader.FinishDownloadMessage" [color="black", fontcolor="black", label=<{FinishDownloadMessage|package<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"nltk.downloader.FinishPackageMessage" [color="black", fontcolor="black", label=<{FinishPackageMessage|package<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"nltk.downloader.FinishUnzipMessage" [color="black", fontcolor="black", label=<{FinishUnzipMessage|package<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"nltk.stem.snowball.FinnishStemmer" [color="black", fontcolor="black", label=<{FinnishStemmer|<br ALIGN="LEFT"/>|stem(word)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.corpus.util._make_bound_method.Foo" [color="black", fontcolor="black", label=<{Foo|<br ALIGN="LEFT"/>|<I>meth</I>()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.ccg.combinator.ForwardCombinator" [color="black", fontcolor="black", label=<{ForwardCombinator|<br ALIGN="LEFT"/>|can_combine(left, right)<br ALIGN="LEFT"/>combine(left, right)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.ccg.chart.ForwardTypeRaiseRule" [color="black", fontcolor="black", label=<{ForwardTypeRaiseRule|NUMEDGES : int<br ALIGN="LEFT"/>|apply(chart, grammar, left_edge, right_edge)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.corpus.reader.framenet.FramenetCorpusReader" [color="black", fontcolor="black", label=<{FramenetCorpusReader|<br ALIGN="LEFT"/>|annotated_document(fn_docid)<br ALIGN="LEFT"/>buildindexes()<br ALIGN="LEFT"/>documents(name)<br ALIGN="LEFT"/>fe_relations()<br ALIGN="LEFT"/>fes(name)<br ALIGN="LEFT"/>frame(fn_fid_or_fname, ignorekeys)<br ALIGN="LEFT"/>frame_by_id(fn_fid, ignorekeys)<br ALIGN="LEFT"/>frame_by_name(fn_fname, ignorekeys, check_cache)<br ALIGN="LEFT"/>frame_ids_and_names(name)<br ALIGN="LEFT"/>frame_relation_types()<br ALIGN="LEFT"/>frame_relations(frame, frame2, type)<br ALIGN="LEFT"/>frames(name)<br ALIGN="LEFT"/>frames_by_lemma(pat)<br ALIGN="LEFT"/>lu(fn_luid, ignorekeys)<br ALIGN="LEFT"/>lu_basic(fn_luid)<br ALIGN="LEFT"/>lu_ids_and_names(name)<br ALIGN="LEFT"/>lus(name)<br ALIGN="LEFT"/>propagate_semtypes()<br ALIGN="LEFT"/>readme()<br ALIGN="LEFT"/>semtype(key)<br ALIGN="LEFT"/>semtype_inherits(st, superST)<br ALIGN="LEFT"/>semtypes()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.corpus.reader.framenet.FramenetError" [color="black", fontcolor="red", label=<{FramenetError|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"nltk.stem.snowball.FrenchStemmer" [color="black", fontcolor="black", label=<{FrenchStemmer|<br ALIGN="LEFT"/>|stem(word)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.probability.FreqDist" [color="black", fontcolor="black", label=<{FreqDist|<br ALIGN="LEFT"/>|B()<br ALIGN="LEFT"/>N()<br ALIGN="LEFT"/>Nr(r, bins)<br ALIGN="LEFT"/>copy()<br ALIGN="LEFT"/>freq(sample)<br ALIGN="LEFT"/>hapaxes()<br ALIGN="LEFT"/>max()<br ALIGN="LEFT"/>pformat(maxlen)<br ALIGN="LEFT"/>plot()<br ALIGN="LEFT"/>pprint(maxlen, stream)<br ALIGN="LEFT"/>r_Nr(bins)<br ALIGN="LEFT"/>tabulate()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.classify.maxent.FunctionBackedMaxentFeatureEncoding" [color="black", fontcolor="black", label=<{FunctionBackedMaxentFeatureEncoding|<br ALIGN="LEFT"/>|describe(fid)<br ALIGN="LEFT"/>encode(featureset, label)<br ALIGN="LEFT"/>labels()<br ALIGN="LEFT"/>length()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.sem.logic.FunctionVariableExpression" [color="black", fontcolor="black", label=<{FunctionVariableExpression|type<br ALIGN="LEFT"/>|constants()<br ALIGN="LEFT"/>free()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.ccg.api.FunctionalCategory" [color="black", fontcolor="black", label=<{FunctionalCategory|<br ALIGN="LEFT"/>|arg()<br ALIGN="LEFT"/>can_unify(other)<br ALIGN="LEFT"/>dir()<br ALIGN="LEFT"/>is_function()<br ALIGN="LEFT"/>is_primitive()<br ALIGN="LEFT"/>is_var()<br ALIGN="LEFT"/>res()<br ALIGN="LEFT"/>substitute(subs)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.app.chartparser_app.FundamentalEdgeRule" [color="black", fontcolor="black", label=<{FundamentalEdgeRule|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"nltk.parse.chart.FundamentalRule" [color="black", fontcolor="black", label=<{FundamentalRule|NUM_EDGES : int<br ALIGN="LEFT"/>|apply(chart, grammar, left_edge, right_edge)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.corpus.reader.framenet.Future" [color="black", fontcolor="black", label=<{Future|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"nltk.cluster.gaac.GAAClusterer" [color="black", fontcolor="black", label=<{GAAClusterer|<br ALIGN="LEFT"/>|classify_vectorspace(vector)<br ALIGN="LEFT"/>cluster(vectors, assign_clusters, trace)<br ALIGN="LEFT"/>cluster_vectorspace(vectors, trace)<br ALIGN="LEFT"/>dendrogram()<br ALIGN="LEFT"/>num_clusters()<br ALIGN="LEFT"/>update_clusters(num_clusters)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.classify.maxent.GISEncoding" [color="black", fontcolor="black", label=<{GISEncoding|C<br ALIGN="LEFT"/>|describe(f_id)<br ALIGN="LEFT"/>encode(featureset, label)<br ALIGN="LEFT"/>length()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.stem.snowball.GermanStemmer" [color="black", fontcolor="black", label=<{GermanStemmer|<br ALIGN="LEFT"/>|stem(word)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.sem.glue.Glue" [color="black", fontcolor="black", label=<{Glue|depparser : NoneType<br ALIGN="LEFT"/>prover<br ALIGN="LEFT"/>remove_duplicates : bool<br ALIGN="LEFT"/>semtype_file : NoneType<br ALIGN="LEFT"/>verbose : bool<br ALIGN="LEFT"/>|dep_parse(sentence)<br ALIGN="LEFT"/>depgraph_to_glue(depgraph)<br ALIGN="LEFT"/>get_glue_dict()<br ALIGN="LEFT"/>get_pos_tagger()<br ALIGN="LEFT"/>get_readings(agenda)<br ALIGN="LEFT"/>gfl_to_compiled(gfl)<br ALIGN="LEFT"/>parse_to_compiled(sentence)<br ALIGN="LEFT"/>parse_to_meaning(sentence)<br ALIGN="LEFT"/>train_depparser(depgraphs)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.sem.glue.GlueDict" [color="black", fontcolor="black", label=<{GlueDict|file_encoding : NoneType<br ALIGN="LEFT"/>filename<br ALIGN="LEFT"/>|add_missing_dependencies(node, depgraph)<br ALIGN="LEFT"/>find_label_name(name, node, depgraph, unique_index)<br ALIGN="LEFT"/>get_GlueFormula_factory()<br ALIGN="LEFT"/>get_glueformulas_from_semtype_entry(lookup, word, node, depgraph, counter)<br ALIGN="LEFT"/>get_label(node)<br ALIGN="LEFT"/>get_meaning_formula(generic, word)<br ALIGN="LEFT"/>get_semtypes(node)<br ALIGN="LEFT"/>initialize_labels(expr, node, depgraph, unique_index)<br ALIGN="LEFT"/>lookup(node, depgraph, counter)<br ALIGN="LEFT"/>lookup_unique(rel, node, depgraph)<br ALIGN="LEFT"/>read_file(empty_first)<br ALIGN="LEFT"/>to_glueformula_list(depgraph, node, counter, verbose)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.sem.glue.GlueFormula" [color="black", fontcolor="black", label=<{GlueFormula|glue<br ALIGN="LEFT"/>indices : NoneType, set<br ALIGN="LEFT"/>meaning<br ALIGN="LEFT"/>word<br ALIGN="LEFT"/>|applyto(arg)<br ALIGN="LEFT"/>compile(counter)<br ALIGN="LEFT"/>lambda_abstract(other)<br ALIGN="LEFT"/>make_LambdaExpression(variable, term)<br ALIGN="LEFT"/>make_VariableExpression(name)<br ALIGN="LEFT"/>simplify()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.data.GzipFileSystemPathPointer" [color="black", fontcolor="black", label=<{GzipFileSystemPathPointer|<br ALIGN="LEFT"/>|open(encoding)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.align.ibm3.HashableDict" [color="black", fontcolor="black", label=<{HashableDict|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"nltk.probability.HeldoutProbDist" [color="black", fontcolor="black", label=<{HeldoutProbDist|SUM_TO_ONE : bool<br ALIGN="LEFT"/>|base_fdist()<br ALIGN="LEFT"/><I>discount</I>()<br ALIGN="LEFT"/>heldout_fdist()<br ALIGN="LEFT"/>max()<br ALIGN="LEFT"/>prob(sample)<br ALIGN="LEFT"/>samples()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.tag.hmm.HiddenMarkovModelTagger" [color="black", fontcolor="black", label=<{HiddenMarkovModelTagger|<br ALIGN="LEFT"/>|best_path(unlabeled_sequence)<br ALIGN="LEFT"/>best_path_simple(unlabeled_sequence)<br ALIGN="LEFT"/>entropy(unlabeled_sequence)<br ALIGN="LEFT"/>log_probability(sequence)<br ALIGN="LEFT"/>point_entropy(unlabeled_sequence)<br ALIGN="LEFT"/>probability(sequence)<br ALIGN="LEFT"/>random_sample(rng, length)<br ALIGN="LEFT"/>reset_cache()<br ALIGN="LEFT"/>tag(unlabeled_sequence)<br ALIGN="LEFT"/>test(test_sequence, verbose)<br ALIGN="LEFT"/>train(labeled_sequence, test_sequence, unlabeled_sequence)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.tag.hmm.HiddenMarkovModelTrainer" [color="black", fontcolor="black", label=<{HiddenMarkovModelTrainer|<br ALIGN="LEFT"/>|train(labeled_sequences, unlabeled_sequences)<br ALIGN="LEFT"/>train_supervised(labelled_sequences, estimator)<br ALIGN="LEFT"/>train_unsupervised(unlabeled_sequences, update_outputs)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.sem.hole.HoleSemantics" [color="black", fontcolor="black", label=<{HoleSemantics|constraints : set<br ALIGN="LEFT"/>fragments : dict<br ALIGN="LEFT"/>holes : set<br ALIGN="LEFT"/>labels : set<br ALIGN="LEFT"/>top_hole<br ALIGN="LEFT"/>top_most_labels : set<br ALIGN="LEFT"/>|formula_tree(plugging)<br ALIGN="LEFT"/>is_node(x)<br ALIGN="LEFT"/>pluggings()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.stem.snowball.HungarianStemmer" [color="black", fontcolor="black", label=<{HungarianStemmer|<br ALIGN="LEFT"/>|stem(word)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.tag.hunpos.HunposTagger" [color="black", fontcolor="black", label=<{HunposTagger|<br ALIGN="LEFT"/>|close()<br ALIGN="LEFT"/>tag(tokens)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.align.ibm1.IBMModel1" [color="black", fontcolor="black", label=<{IBMModel1|probabilities : defaultdict<br ALIGN="LEFT"/>|align(align_sent)<br ALIGN="LEFT"/>train(align_sents, num_iter)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.align.ibm2.IBMModel2" [color="black", fontcolor="black", label=<{IBMModel2|alignments : defaultdict<br ALIGN="LEFT"/>probabilities : defaultdict<br ALIGN="LEFT"/>|align(align_sent)<br ALIGN="LEFT"/>train(align_sents, num_iter)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.align.ibm3.IBMModel3" [color="black", fontcolor="black", label=<{IBMModel3|PROB_SMOOTH : float<br ALIGN="LEFT"/>align_table : defaultdict<br ALIGN="LEFT"/>distortion : defaultdict<br ALIGN="LEFT"/>fertility : defaultdict<br ALIGN="LEFT"/>null_insertion : float<br ALIGN="LEFT"/>probabilities : defaultdict<br ALIGN="LEFT"/>|align(align_sent)<br ALIGN="LEFT"/>hillclimb(a, j_pegged, es, fs, fert)<br ALIGN="LEFT"/>neighboring(a, j_pegged, es, fs, fert)<br ALIGN="LEFT"/>probability(a, es, fs, Fert)<br ALIGN="LEFT"/>sample(e, f)<br ALIGN="LEFT"/>train(align_sents, num_iter)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.corpus.reader.ieer.IEERCorpusReader" [color="black", fontcolor="black", label=<{IEERCorpusReader|<br ALIGN="LEFT"/>|docs(fileids)<br ALIGN="LEFT"/>parsed_docs(fileids)<br ALIGN="LEFT"/>raw(fileids)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.corpus.reader.ieer.IEERDocument" [color="black", fontcolor="black", label=<{IEERDocument|date_time : NoneType<br ALIGN="LEFT"/>docno : NoneType<br ALIGN="LEFT"/>doctype : NoneType<br ALIGN="LEFT"/>headline : str<br ALIGN="LEFT"/>text<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"nltk.corpus.reader.ipipan.IPIPANCorpusReader" [color="black", fontcolor="black", label=<{IPIPANCorpusReader|<br ALIGN="LEFT"/>|categories(fileids)<br ALIGN="LEFT"/>channels(fileids)<br ALIGN="LEFT"/>domains(fileids)<br ALIGN="LEFT"/>fileids(channels, domains, categories)<br ALIGN="LEFT"/>paras(fileids)<br ALIGN="LEFT"/>raw(fileids)<br ALIGN="LEFT"/>sents(fileids)<br ALIGN="LEFT"/>tagged_paras(fileids)<br ALIGN="LEFT"/>tagged_sents(fileids)<br ALIGN="LEFT"/>tagged_words(fileids)<br ALIGN="LEFT"/>words(fileids)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.corpus.reader.ipipan.IPIPANCorpusView" [color="black", fontcolor="black", label=<{IPIPANCorpusView|PARAS_MODE : int<br ALIGN="LEFT"/>SENTS_MODE : int<br ALIGN="LEFT"/>WORDS_MODE : int<br ALIGN="LEFT"/>append_no_space<br ALIGN="LEFT"/>append_space<br ALIGN="LEFT"/>disamb_only<br ALIGN="LEFT"/>in_sentence : bool<br ALIGN="LEFT"/>mode<br ALIGN="LEFT"/>one_tag<br ALIGN="LEFT"/>position : int<br ALIGN="LEFT"/>replace_xmlentities<br ALIGN="LEFT"/>show_tags<br ALIGN="LEFT"/>simplify_tags<br ALIGN="LEFT"/>|read_block(stream)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.stem.isri.ISRIStemmer" [color="black", fontcolor="black", label=<{ISRIStemmer|p1 : list<br ALIGN="LEFT"/>p2 : list<br ALIGN="LEFT"/>p3 : list<br ALIGN="LEFT"/>pr4 : dict<br ALIGN="LEFT"/>pr53 : dict<br ALIGN="LEFT"/>re_hamza<br ALIGN="LEFT"/>re_initial_hamza<br ALIGN="LEFT"/>re_short_vowels<br ALIGN="LEFT"/>s1 : list<br ALIGN="LEFT"/>s2 : list<br ALIGN="LEFT"/>s3 : list<br ALIGN="LEFT"/>stop_words : list<br ALIGN="LEFT"/>|end_w5(word)<br ALIGN="LEFT"/>end_w6(word)<br ALIGN="LEFT"/>norm(word, num)<br ALIGN="LEFT"/>pre1(word)<br ALIGN="LEFT"/>pre32(word)<br ALIGN="LEFT"/>pro_w4(word)<br ALIGN="LEFT"/>pro_w53(word)<br ALIGN="LEFT"/>pro_w54(word)<br ALIGN="LEFT"/>pro_w6(word)<br ALIGN="LEFT"/>pro_w64(word)<br ALIGN="LEFT"/>stem(token)<br ALIGN="LEFT"/>suf1(word)<br ALIGN="LEFT"/>suf32(word)<br ALIGN="LEFT"/>waw(word)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.sem.logic.IffExpression" [color="black", fontcolor="black", label=<{IffExpression|<br ALIGN="LEFT"/>|getOp()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.sem.logic.IllegalTypeException" [color="black", fontcolor="red", label=<{IllegalTypeException|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"nltk.tree.ImmutableMultiParentedTree" [color="black", fontcolor="black", label=<{ImmutableMultiParentedTree|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"nltk.tree.ImmutableParentedTree" [color="black", fontcolor="black", label=<{ImmutableParentedTree|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"nltk.probability.ImmutableProbabilisticMixIn" [color="black", fontcolor="black", label=<{ImmutableProbabilisticMixIn|<br ALIGN="LEFT"/>|set_logprob(prob)<br ALIGN="LEFT"/>set_prob(prob)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.tree.ImmutableProbabilisticTree" [color="black", fontcolor="black", label=<{ImmutableProbabilisticTree|<br ALIGN="LEFT"/>|convert(val)<br ALIGN="LEFT"/>copy(deep)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.tree.ImmutableTree" [color="black", fontcolor="black", label=<{ImmutableTree|<br ALIGN="LEFT"/>|append(v)<br ALIGN="LEFT"/>extend(v)<br ALIGN="LEFT"/>pop(v)<br ALIGN="LEFT"/>remove(v)<br ALIGN="LEFT"/>reverse()<br ALIGN="LEFT"/>set_label(value)<br ALIGN="LEFT"/>sort()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.sem.linearlogic.ImpExpression" [color="black", fontcolor="black", label=<{ImpExpression|antecedent<br ALIGN="LEFT"/>consequent<br ALIGN="LEFT"/>|compile_neg(index_counter, glueFormulaFactory)<br ALIGN="LEFT"/>compile_pos(index_counter, glueFormulaFactory)<br ALIGN="LEFT"/>initialize_labels(fstruct)<br ALIGN="LEFT"/>simplify(bindings)<br ALIGN="LEFT"/>unify(other, bindings)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.sem.logic.ImpExpression" [color="black", fontcolor="black", label=<{ImpExpression|<br ALIGN="LEFT"/>|getOp()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.sem.logic.InconsistentTypeHierarchyException" [color="black", fontcolor="red", label=<{InconsistentTypeHierarchyException|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"nltk.parse.earleychart.IncrementalBottomUpChartParser" [color="black", fontcolor="black", label=<{IncrementalBottomUpChartParser|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"nltk.parse.earleychart.IncrementalBottomUpLeftCornerChartParser" [color="black", fontcolor="black", label=<{IncrementalBottomUpLeftCornerChartParser|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"nltk.parse.earleychart.IncrementalChart" [color="black", fontcolor="black", label=<{IncrementalChart|<br ALIGN="LEFT"/>|edges()<br ALIGN="LEFT"/>initialize()<br ALIGN="LEFT"/>iteredges()<br ALIGN="LEFT"/>select(end)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.parse.earleychart.IncrementalChartParser" [color="black", fontcolor="black", label=<{IncrementalChartParser|<br ALIGN="LEFT"/>|chart_parse(tokens, trace)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.parse.earleychart.IncrementalLeftCornerChartParser" [color="black", fontcolor="black", label=<{IncrementalLeftCornerChartParser|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"nltk.parse.earleychart.IncrementalTopDownChartParser" [color="black", fontcolor="black", label=<{IncrementalTopDownChartParser|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"nltk.util.Index" [color="black", fontcolor="black", label=<{Index|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"nltk.corpus.reader.indian.IndianCorpusReader" [color="black", fontcolor="black", label=<{IndianCorpusReader|<br ALIGN="LEFT"/>|raw(fileids)<br ALIGN="LEFT"/>sents(fileids)<br ALIGN="LEFT"/>tagged_sents(fileids, tagset)<br ALIGN="LEFT"/>tagged_words(fileids, tagset)<br ALIGN="LEFT"/>words(fileids)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.corpus.reader.indian.IndianCorpusView" [color="black", fontcolor="black", label=<{IndianCorpusView|<br ALIGN="LEFT"/>|read_block(stream)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.sem.logic.IndividualVariableExpression" [color="black", fontcolor="black", label=<{IndividualVariableExpression|type<br ALIGN="LEFT"/>|constants()<br ALIGN="LEFT"/>free()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.parse.pchart.InsideChartParser" [color="black", fontcolor="black", label=<{InsideChartParser|<br ALIGN="LEFT"/>|sort_queue(queue, chart)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.parse.featurechart.InstantiateVarsChart" [color="black", fontcolor="black", label=<{InstantiateVarsChart|<br ALIGN="LEFT"/>|initialize()<br ALIGN="LEFT"/>insert(edge, child_pointer_list)<br ALIGN="LEFT"/>inst_vars(edge)<br ALIGN="LEFT"/>instantiate_edge(edge)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.stem.snowball.ItalianStemmer" [color="black", fontcolor="black", label=<{ItalianStemmer|<br ALIGN="LEFT"/>|stem(word)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.jsontags.JSONTaggedDecoder" [color="black", fontcolor="black", label=<{JSONTaggedDecoder|<br ALIGN="LEFT"/>|decode(s)<br ALIGN="LEFT"/>decode_obj(obj)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.jsontags.JSONTaggedEncoder" [color="black", fontcolor="black", label=<{JSONTaggedEncoder|<br ALIGN="LEFT"/>|default(obj)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.cluster.kmeans.KMeansClusterer" [color="black", fontcolor="black", label=<{KMeansClusterer|<br ALIGN="LEFT"/>|classify_vectorspace(vector)<br ALIGN="LEFT"/>cluster_vectorspace(vectors, trace)<br ALIGN="LEFT"/>means()<br ALIGN="LEFT"/>num_clusters()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.corpus.reader.knbc.KNBCorpusReader" [color="black", fontcolor="black", label=<{KNBCorpusReader|morphs2str<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"nltk.probability.KneserNeyProbDist" [color="black", fontcolor="black", label=<{KneserNeyProbDist|<br ALIGN="LEFT"/>|discount()<br ALIGN="LEFT"/>max()<br ALIGN="LEFT"/>prob(trigram)<br ALIGN="LEFT"/>samples()<br ALIGN="LEFT"/>set_discount(discount)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.sem.logic.LambdaExpression" [color="black", fontcolor="black", label=<{LambdaExpression|type<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"nltk.stem.lancaster.LancasterStemmer" [color="black", fontcolor="black", label=<{LancasterStemmer|rule_dictionary : dict<br ALIGN="LEFT"/>rule_tuple : tuple<br ALIGN="LEFT"/>|parseRules(rule_tuple)<br ALIGN="LEFT"/>stem(word)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.align.gale_church.LanguageIndependent" [color="black", fontcolor="black", label=<{LanguageIndependent|AVERAGE_CHARACTERS : int<br ALIGN="LEFT"/>PRIORS : dict<br ALIGN="LEFT"/>VARIANCE_CHARACTERS : float<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"nltk.probability.LaplaceProbDist" [color="black", fontcolor="black", label=<{LaplaceProbDist|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"nltk.util.LazyConcatenation" [color="black", fontcolor="black", label=<{LazyConcatenation|<br ALIGN="LEFT"/>|iterate_from(start_index)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.corpus.util.LazyCorpusLoader" [color="black", fontcolor="black", label=<{LazyCorpusLoader|morphs2str<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"nltk.util.LazyEnumerate" [color="black", fontcolor="black", label=<{LazyEnumerate|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"nltk.data.LazyLoader" [color="black", fontcolor="black", label=<{LazyLoader|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"nltk.util.LazyMap" [color="black", fontcolor="black", label=<{LazyMap|<br ALIGN="LEFT"/>|iterate_from(index)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.lazyimport.LazyModule" [color="black", fontcolor="black", label=<{LazyModule|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"nltk.util.LazySubsequence" [color="black", fontcolor="black", label=<{LazySubsequence|MIN_SIZE : int<br ALIGN="LEFT"/>|iterate_from(start)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.util.LazyZip" [color="black", fontcolor="black", label=<{LazyZip|<br ALIGN="LEFT"/>|iterate_from(index)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.parse.chart.LeafEdge" [color="black", fontcolor="black", label=<{LeafEdge|<br ALIGN="LEFT"/>|dot()<br ALIGN="LEFT"/>end()<br ALIGN="LEFT"/>is_complete()<br ALIGN="LEFT"/>is_incomplete()<br ALIGN="LEFT"/>length()<br ALIGN="LEFT"/>lhs()<br ALIGN="LEFT"/>nextsym()<br ALIGN="LEFT"/>rhs()<br ALIGN="LEFT"/>span()<br ALIGN="LEFT"/>start()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.parse.chart.LeafInitRule" [color="black", fontcolor="black", label=<{LeafInitRule|NUM_EDGES : int<br ALIGN="LEFT"/>|apply(chart, grammar)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.parse.chart.LeftCornerChartParser" [color="black", fontcolor="black", label=<{LeftCornerChartParser|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"nltk.corpus.reader.wordnet.Lemma" [color="black", fontcolor="black", label=<{Lemma|<br ALIGN="LEFT"/>|antonyms()<br ALIGN="LEFT"/>count()<br ALIGN="LEFT"/>derivationally_related_forms()<br ALIGN="LEFT"/>frame_ids()<br ALIGN="LEFT"/>frame_strings()<br ALIGN="LEFT"/>key()<br ALIGN="LEFT"/>lang()<br ALIGN="LEFT"/>name()<br ALIGN="LEFT"/>pertainyms()<br ALIGN="LEFT"/>synset()<br ALIGN="LEFT"/>syntactic_marker()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.probability.LidstoneProbDist" [color="black", fontcolor="black", label=<{LidstoneProbDist|SUM_TO_ONE : bool<br ALIGN="LEFT"/>|discount()<br ALIGN="LEFT"/>freqdist()<br ALIGN="LEFT"/>max()<br ALIGN="LEFT"/>prob(sample)<br ALIGN="LEFT"/>samples()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.corpus.reader.lin.LinThesaurusCorpusReader" [color="black", fontcolor="black", label=<{LinThesaurusCorpusReader|<br ALIGN="LEFT"/>|scored_synonyms(ngram, fileid)<br ALIGN="LEFT"/>similarity(ngram1, ngram2, fileid)<br ALIGN="LEFT"/>synonyms(ngram, fileid)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.tokenize.simple.LineTokenizer" [color="black", fontcolor="black", label=<{LineTokenizer|<br ALIGN="LEFT"/>|span_tokenize(s)<br ALIGN="LEFT"/>tokenize(s)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.sem.linearlogic.LinearLogicApplicationException" [color="black", fontcolor="red", label=<{LinearLogicApplicationException|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"nltk.sem.linearlogic.LinearLogicParser" [color="black", fontcolor="black", label=<{LinearLogicParser|operator_precedence : dict<br ALIGN="LEFT"/>right_associated_operations<br ALIGN="LEFT"/>|attempt_ApplicationExpression(expression, context)<br ALIGN="LEFT"/>get_BooleanExpression_factory(tok)<br ALIGN="LEFT"/>get_all_symbols()<br ALIGN="LEFT"/>handle(tok, context)<br ALIGN="LEFT"/>make_BooleanExpression(factory, first, second)<br ALIGN="LEFT"/>make_VariableExpression(name)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.app.collocations_app.CollocationsModel.LoadCorpus" [color="black", fontcolor="black", label=<{LoadCorpus|model<br ALIGN="LEFT"/>name<br ALIGN="LEFT"/>|run()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.app.concordance_app.ConcordanceSearchModel.LoadCorpus" [color="black", fontcolor="black", label=<{LoadCorpus|model<br ALIGN="LEFT"/>name<br ALIGN="LEFT"/>|run()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.sem.logic.LogicParser" [color="black", fontcolor="black", label=<{LogicParser|operator_precedence : dict<br ALIGN="LEFT"/>quote_chars : list<br ALIGN="LEFT"/>right_associated_operations : list<br ALIGN="LEFT"/>type_check : bool<br ALIGN="LEFT"/>|assertNextToken(expected)<br ALIGN="LEFT"/>assertToken(tok, expected)<br ALIGN="LEFT"/>attempt_ApplicationExpression(expression, context)<br ALIGN="LEFT"/>attempt_BooleanExpression(expression, context)<br ALIGN="LEFT"/>attempt_EqualityExpression(expression, context)<br ALIGN="LEFT"/>attempt_adjuncts(expression, context)<br ALIGN="LEFT"/>get_BooleanExpression_factory(tok)<br ALIGN="LEFT"/>get_QuantifiedExpression_factory(tok)<br ALIGN="LEFT"/>get_all_symbols()<br ALIGN="LEFT"/>get_next_token_variable(description)<br ALIGN="LEFT"/>handle(tok, context)<br ALIGN="LEFT"/>handle_lambda(tok, context)<br ALIGN="LEFT"/>handle_negation(tok, context)<br ALIGN="LEFT"/>handle_open(tok, context)<br ALIGN="LEFT"/>handle_quant(tok, context)<br ALIGN="LEFT"/>handle_variable(tok, context)<br ALIGN="LEFT"/>has_priority(operation, context)<br ALIGN="LEFT"/>inRange(location)<br ALIGN="LEFT"/>isvariable(tok)<br ALIGN="LEFT"/>make_ApplicationExpression(function, argument)<br ALIGN="LEFT"/>make_BooleanExpression(factory, first, second)<br ALIGN="LEFT"/>make_EqualityExpression(first, second)<br ALIGN="LEFT"/>make_LambdaExpression(variable, term)<br ALIGN="LEFT"/>make_NegatedExpression(expression)<br ALIGN="LEFT"/>make_QuanifiedExpression(factory, variable, term)<br ALIGN="LEFT"/>make_VariableExpression(name)<br ALIGN="LEFT"/>parse(data, signature)<br ALIGN="LEFT"/>process(data)<br ALIGN="LEFT"/>process_next_expression(context)<br ALIGN="LEFT"/>process_quoted_token(data_idx, data)<br ALIGN="LEFT"/>token(location)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.sem.logic.LogicalExpressionException" [color="black", fontcolor="red", label=<{LogicalExpressionException|index<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"nltk.parse.pchart.LongestChartParser" [color="black", fontcolor="black", label=<{LongestChartParser|<br ALIGN="LEFT"/>|sort_queue(queue, chart)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.probability.MLEProbDist" [color="black", fontcolor="black", label=<{MLEProbDist|<br ALIGN="LEFT"/>|freqdist()<br ALIGN="LEFT"/>max()<br ALIGN="LEFT"/>prob(sample)<br ALIGN="LEFT"/>samples()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.corpus.reader.tagged.MacMorphoCorpusReader" [color="black", fontcolor="black", label=<{MacMorphoCorpusReader|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"nltk.inference.mace.Mace" [color="black", fontcolor="black", label=<{Mace|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"nltk.inference.mace.MaceCommand" [color="black", fontcolor="black", label=<{MaceCommand|valuation<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"nltk.parse.malt.MaltParser" [color="black", fontcolor="black", label=<{MaltParser|additional_java_args : NoneType, list<br ALIGN="LEFT"/>mco : NoneType, str<br ALIGN="LEFT"/>tagger<br ALIGN="LEFT"/>working_dir : NoneType<br ALIGN="LEFT"/>|config_malt(bin, verbose)<br ALIGN="LEFT"/>parse_sents(sentences, verbose)<br ALIGN="LEFT"/>tagged_parse(sentence, verbose)<br ALIGN="LEFT"/>tagged_parse_sents(sentences, verbose)<br ALIGN="LEFT"/>train(depgraphs, verbose)<br ALIGN="LEFT"/>train_from_file(conll_file, verbose)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.classify.maxent.MaxentClassifier" [color="black", fontcolor="black", label=<{MaxentClassifier|ALGORITHMS : list<br ALIGN="LEFT"/>|classify(featureset)<br ALIGN="LEFT"/>explain(featureset, columns)<br ALIGN="LEFT"/>labels()<br ALIGN="LEFT"/>prob_classify(featureset)<br ALIGN="LEFT"/>set_weights(new_weights)<br ALIGN="LEFT"/>show_most_informative_features(n, show)<br ALIGN="LEFT"/>train(train_toks, algorithm, trace, encoding, labels, gaussian_prior_sigma)<br ALIGN="LEFT"/>weights()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.classify.maxent.MaxentFeatureEncodingI" [color="black", fontcolor="black", label=<{MaxentFeatureEncodingI|<br ALIGN="LEFT"/>|<I>describe</I>(fid)<br ALIGN="LEFT"/><I>encode</I>(featureset, label)<br ALIGN="LEFT"/><I>labels</I>()<br ALIGN="LEFT"/><I>length</I>()<br ALIGN="LEFT"/><I>train</I>(train_toks)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.chunk.regexp.MergeRule" [color="black", fontcolor="black", label=<{MergeRule|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"nltk.misc.minimalset.MinimalSet" [color="black", fontcolor="black", label=<{MinimalSet|<br ALIGN="LEFT"/>|add(context, target, display)<br ALIGN="LEFT"/>contexts(minimum)<br ALIGN="LEFT"/>display(context, target, default)<br ALIGN="LEFT"/>display_all(context)<br ALIGN="LEFT"/>targets()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.sem.evaluate.Model" [color="black", fontcolor="black", label=<{Model|domain<br ALIGN="LEFT"/>valuation<br ALIGN="LEFT"/>|evaluate(expr, g, trace)<br ALIGN="LEFT"/>i(parsed, g, trace)<br ALIGN="LEFT"/>satisfiers(parsed, varex, g, trace, nesting)<br ALIGN="LEFT"/>satisfy(parsed, g, trace)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.inference.api.ModelBuilder" [color="black", fontcolor="black", label=<{ModelBuilder|<br ALIGN="LEFT"/>|build_model(goal, assumptions, verbose)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.inference.api.ModelBuilderCommand" [color="black", fontcolor="black", label=<{ModelBuilderCommand|<br ALIGN="LEFT"/>|<I>build_model</I>(verbose)<br ALIGN="LEFT"/><I>get_model_builder</I>()<br ALIGN="LEFT"/><I>model</I>(format)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.inference.api.ModelBuilderCommandDecorator" [color="black", fontcolor="black", label=<{ModelBuilderCommandDecorator|<br ALIGN="LEFT"/>|build_model(verbose)<br ALIGN="LEFT"/>get_model_builder()<br ALIGN="LEFT"/>model(format)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.classify.api.MultiClassifierI" [color="black", fontcolor="black", label=<{MultiClassifierI|<br ALIGN="LEFT"/>|classify(featureset)<br ALIGN="LEFT"/>classify_many(featuresets)<br ALIGN="LEFT"/><I>labels</I>()<br ALIGN="LEFT"/>prob_classify(featureset)<br ALIGN="LEFT"/>prob_classify_many(featuresets)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.draw.table.MultiListbox" [color="black", fontcolor="black", label=<{MultiListbox|FRAME_CONFIG : dict<br ALIGN="LEFT"/>LABEL_CONFIG : dict<br ALIGN="LEFT"/>LISTBOX_CONFIG : dict<br ALIGN="LEFT"/>column_labels<br ALIGN="LEFT"/>column_names<br ALIGN="LEFT"/>columnconfig<br ALIGN="LEFT"/>itemconfig<br ALIGN="LEFT"/>listboxes<br ALIGN="LEFT"/>rowconfig<br ALIGN="LEFT"/>select_anchor<br ALIGN="LEFT"/>select_clear<br ALIGN="LEFT"/>select_includes<br ALIGN="LEFT"/>select_set<br ALIGN="LEFT"/>|activate()<br ALIGN="LEFT"/>bbox(row, col)<br ALIGN="LEFT"/>bind_to_columns(sequence, func, add)<br ALIGN="LEFT"/>bind_to_labels(sequence, func, add)<br ALIGN="LEFT"/>bind_to_listboxes(sequence, func, add)<br ALIGN="LEFT"/>columnconfigure(col_index, cnf)<br ALIGN="LEFT"/>configure(cnf)<br ALIGN="LEFT"/>curselection()<br ALIGN="LEFT"/>delete()<br ALIGN="LEFT"/>get(first, last)<br ALIGN="LEFT"/>hide_column(col_index)<br ALIGN="LEFT"/>index()<br ALIGN="LEFT"/>insert(index)<br ALIGN="LEFT"/>itemcget()<br ALIGN="LEFT"/>itemconfigure(row_index, col_index, cnf)<br ALIGN="LEFT"/>nearest()<br ALIGN="LEFT"/>rowconfigure(row_index, cnf)<br ALIGN="LEFT"/>scan_dragto()<br ALIGN="LEFT"/>scan_mark()<br ALIGN="LEFT"/>see()<br ALIGN="LEFT"/>select(index, delta, see)<br ALIGN="LEFT"/>selection_anchor()<br ALIGN="LEFT"/>selection_clear()<br ALIGN="LEFT"/>selection_includes()<br ALIGN="LEFT"/>selection_set()<br ALIGN="LEFT"/>show_column(col_index)<br ALIGN="LEFT"/>size()<br ALIGN="LEFT"/>yview()<br ALIGN="LEFT"/>yview_moveto()<br ALIGN="LEFT"/>yview_scroll()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.tree.MultiParentedTree" [color="black", fontcolor="black", label=<{MultiParentedTree|<br ALIGN="LEFT"/>|left_siblings()<br ALIGN="LEFT"/>parent_indices(parent)<br ALIGN="LEFT"/>parents()<br ALIGN="LEFT"/>right_siblings()<br ALIGN="LEFT"/>roots()<br ALIGN="LEFT"/>treepositions(root)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.draw.util.MutableOptionMenu" [color="black", fontcolor="black", label=<{MutableOptionMenu|menuname<br ALIGN="LEFT"/>widgetName : str<br ALIGN="LEFT"/>|add(value)<br ALIGN="LEFT"/>destroy()<br ALIGN="LEFT"/>remove(value)<br ALIGN="LEFT"/>set(value)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.probability.MutableProbDist" [color="black", fontcolor="black", label=<{MutableProbDist|<br ALIGN="LEFT"/>|logprob(sample)<br ALIGN="LEFT"/>prob(sample)<br ALIGN="LEFT"/>samples()<br ALIGN="LEFT"/>update(sample, prob, log)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.app.wordnet_app.MyServerHandler" [color="black", fontcolor="black", label=<{MyServerHandler|<br ALIGN="LEFT"/>|do_GET()<br ALIGN="LEFT"/>do_HEAD()<br ALIGN="LEFT"/>log_message(format)<br ALIGN="LEFT"/>send_head(type)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.chunk.named_entity.NEChunkParser" [color="black", fontcolor="black", label=<{NEChunkParser|<br ALIGN="LEFT"/>|parse(tokens)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.chunk.named_entity.NEChunkParserTagger" [color="black", fontcolor="black", label=<{NEChunkParserTagger|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"nltk.tag.stanford.NERTagger" [color="black", fontcolor="black", label=<{NERTagger|<br ALIGN="LEFT"/>|parse_output(text)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.corpus.reader.nkjp.NKJPCorpusReader" [color="black", fontcolor="black", label=<{NKJPCorpusReader|HEADER_MODE : int<br ALIGN="LEFT"/>RAW_MODE : int<br ALIGN="LEFT"/>SENTS_MODE : int<br ALIGN="LEFT"/>WORDS_MODE : int<br ALIGN="LEFT"/>|add_root(fileid)<br ALIGN="LEFT"/>fileids()<br ALIGN="LEFT"/>get_paths()<br ALIGN="LEFT"/>header(fileids)<br ALIGN="LEFT"/>raw(fileids)<br ALIGN="LEFT"/>sents(fileids)<br ALIGN="LEFT"/>tagged_words(fileids)<br ALIGN="LEFT"/>words(fileids)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.corpus.reader.nkjp.NKJPCorpus_Header_View" [color="black", fontcolor="black", label=<{NKJPCorpus_Header_View|tagspec : str<br ALIGN="LEFT"/>|handle_elt(elt, context)<br ALIGN="LEFT"/>handle_query()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.corpus.reader.nkjp.NKJPCorpus_Morph_View" [color="black", fontcolor="black", label=<{NKJPCorpus_Morph_View|tags<br ALIGN="LEFT"/>tagspec : str<br ALIGN="LEFT"/>xml_tool<br ALIGN="LEFT"/>|handle_elt(elt, context)<br ALIGN="LEFT"/>handle_query()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.corpus.reader.nkjp.NKJPCorpus_Segmentation_View" [color="black", fontcolor="black", label=<{NKJPCorpus_Segmentation_View|tagspec : str<br ALIGN="LEFT"/>text_view<br ALIGN="LEFT"/>xml_tool<br ALIGN="LEFT"/>|get_segm_id(example_word)<br ALIGN="LEFT"/>get_sent_beg(beg_word)<br ALIGN="LEFT"/>get_sent_end(end_word)<br ALIGN="LEFT"/>get_sentences(sent_segm)<br ALIGN="LEFT"/>handle_elt(elt, context)<br ALIGN="LEFT"/>handle_query()<br ALIGN="LEFT"/>remove_choice(segm)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.corpus.reader.nkjp.NKJPCorpus_Text_View" [color="black", fontcolor="black", label=<{NKJPCorpus_Text_View|RAW_MODE : int<br ALIGN="LEFT"/>SENTS_MODE : int<br ALIGN="LEFT"/>mode<br ALIGN="LEFT"/>segm_dict : dict<br ALIGN="LEFT"/>tagspec : str<br ALIGN="LEFT"/>xml_tool<br ALIGN="LEFT"/>|get_segm_id(elt)<br ALIGN="LEFT"/>handle_elt(elt, context)<br ALIGN="LEFT"/>handle_query()<br ALIGN="LEFT"/>read_block(stream, tagspec, elt_handler)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.corpus.reader.nps_chat.NPSChatCorpusReader" [color="black", fontcolor="black", label=<{NPSChatCorpusReader|<br ALIGN="LEFT"/>|posts(fileids)<br ALIGN="LEFT"/>tagged_posts(fileids, tagset)<br ALIGN="LEFT"/>tagged_words(fileids, tagset)<br ALIGN="LEFT"/>words(fileids)<br ALIGN="LEFT"/>xml_posts(fileids)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.classify.naivebayes.NaiveBayesClassifier" [color="black", fontcolor="black", label=<{NaiveBayesClassifier|<br ALIGN="LEFT"/>|classify(featureset)<br ALIGN="LEFT"/>labels()<br ALIGN="LEFT"/>most_informative_features(n)<br ALIGN="LEFT"/>prob_classify(featureset)<br ALIGN="LEFT"/>show_most_informative_features(n)<br ALIGN="LEFT"/>train(labeled_featuresets, estimator)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.test.unit.test_naivebayes.NaiveBayesClassifierTest" [color="black", fontcolor="black", label=<{NaiveBayesClassifierTest|<br ALIGN="LEFT"/>|test_simple()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.parse.nonprojectivedependencyparser.NaiveBayesDependencyScorer" [color="black", fontcolor="black", label=<{NaiveBayesDependencyScorer|classifier<br ALIGN="LEFT"/>|score(graph)<br ALIGN="LEFT"/>train(graphs)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.sem.logic.NegatedExpression" [color="black", fontcolor="black", label=<{NegatedExpression|term<br ALIGN="LEFT"/>type<br ALIGN="LEFT"/>|findtype(variable)<br ALIGN="LEFT"/>negate()<br ALIGN="LEFT"/>visit(function, combinator)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.metrics.association.NgramAssocMeasures" [color="black", fontcolor="black", label=<{NgramAssocMeasures|<br ALIGN="LEFT"/>|chi_sq()<br ALIGN="LEFT"/>jaccard()<br ALIGN="LEFT"/>likelihood_ratio()<br ALIGN="LEFT"/>mi_like()<br ALIGN="LEFT"/>pmi()<br ALIGN="LEFT"/>poisson_stirling()<br ALIGN="LEFT"/>raw_freq()<br ALIGN="LEFT"/>student_t()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.tag.sequential.NgramTagger" [color="black", fontcolor="black", label=<{NgramTagger|json_tag : str<br ALIGN="LEFT"/>|context(tokens, index, history)<br ALIGN="LEFT"/>decode_json_obj(obj)<br ALIGN="LEFT"/>encode_json_obj()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.sem.boxer.NltkDrtBoxerDrsInterpreter" [color="black", fontcolor="black", label=<{NltkDrtBoxerDrsInterpreter|<br ALIGN="LEFT"/>|interpret(ex)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.test.runtests.NltkPluginManager" [color="black", fontcolor="black", label=<{NltkPluginManager|<br ALIGN="LEFT"/>|loadPlugins()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.corpus.reader.nombank.NombankChainTreePointer" [color="black", fontcolor="black", label=<{NombankChainTreePointer|pieces<br ALIGN="LEFT"/>|select(tree)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.corpus.reader.nombank.NombankCorpusReader" [color="black", fontcolor="black", label=<{NombankCorpusReader|<br ALIGN="LEFT"/>|instances(baseform)<br ALIGN="LEFT"/>lines()<br ALIGN="LEFT"/>nouns()<br ALIGN="LEFT"/>raw(fileids)<br ALIGN="LEFT"/>roleset(roleset_id)<br ALIGN="LEFT"/>rolesets(baseform)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.corpus.reader.nombank.NombankInstance" [color="black", fontcolor="black", label=<{NombankInstance|arguments : tuple<br ALIGN="LEFT"/>baseform<br ALIGN="LEFT"/>fileid<br ALIGN="LEFT"/>parse_corpus : NoneType<br ALIGN="LEFT"/>predicate<br ALIGN="LEFT"/>predid<br ALIGN="LEFT"/>roleset<br ALIGN="LEFT"/>sensenumber<br ALIGN="LEFT"/>sentnum<br ALIGN="LEFT"/>tree<br ALIGN="LEFT"/>wordnum<br ALIGN="LEFT"/>|parse(s, parse_fileid_xform, parse_corpus)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.corpus.reader.nombank.NombankPointer" [color="black", fontcolor="black", label=<{NombankPointer|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"nltk.corpus.reader.nombank.NombankSplitTreePointer" [color="black", fontcolor="black", label=<{NombankSplitTreePointer|pieces<br ALIGN="LEFT"/>|select(tree)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.corpus.reader.nombank.NombankTreePointer" [color="black", fontcolor="black", label=<{NombankTreePointer|height<br ALIGN="LEFT"/>wordnum<br ALIGN="LEFT"/>|parse(s)<br ALIGN="LEFT"/>select(tree)<br ALIGN="LEFT"/>treepos(tree)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.parse.nonprojectivedependencyparser.NonprojectiveDependencyParser" [color="black", fontcolor="black", label=<{NonprojectiveDependencyParser|<br ALIGN="LEFT"/>|parse(tokens)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.grammar.Nonterminal" [color="black", fontcolor="black", label=<{Nonterminal|<br ALIGN="LEFT"/>|symbol()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.stem.snowball.NorwegianStemmer" [color="black", fontcolor="black", label=<{NorwegianStemmer|<br ALIGN="LEFT"/>|stem(word)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.data.OpenOnDemandZipFile" [color="black", fontcolor="black", label=<{OpenOnDemandZipFile|fp<br ALIGN="LEFT"/>|read(name)<br ALIGN="LEFT"/><I>write</I>()<br ALIGN="LEFT"/><I>writestr</I>()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.sem.logic.OrExpression" [color="black", fontcolor="black", label=<{OrExpression|<br ALIGN="LEFT"/>|getOp()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.util.OrderedDict" [color="black", fontcolor="black", label=<{OrderedDict|<br ALIGN="LEFT"/>|clear()<br ALIGN="LEFT"/>copy()<br ALIGN="LEFT"/>items()<br ALIGN="LEFT"/>keys(data, keys)<br ALIGN="LEFT"/>popitem()<br ALIGN="LEFT"/>setdefault(key, failobj)<br ALIGN="LEFT"/>update(data)<br ALIGN="LEFT"/>values()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.draw.util.OvalWidget" [color="black", fontcolor="black", label=<{OvalWidget|RATIO : float<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"nltk.grammar.PCFG" [color="black", fontcolor="black", label=<{PCFG|EPSILON : float<br ALIGN="LEFT"/>|fromstring(input, encoding)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.tag.stanford.POSTagger" [color="black", fontcolor="black", label=<{POSTagger|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"nltk.corpus.reader.ppattach.PPAttachment" [color="black", fontcolor="black", label=<{PPAttachment|attachment<br ALIGN="LEFT"/>noun1<br ALIGN="LEFT"/>noun2<br ALIGN="LEFT"/>prep<br ALIGN="LEFT"/>sent<br ALIGN="LEFT"/>verb<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"nltk.corpus.reader.ppattach.PPAttachmentCorpusReader" [color="black", fontcolor="black", label=<{PPAttachmentCorpusReader|<br ALIGN="LEFT"/>|attachments(fileids)<br ALIGN="LEFT"/>raw(fileids)<br ALIGN="LEFT"/>tuples(fileids)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.downloader.Package" [color="black", fontcolor="black", label=<{Package|author : str<br ALIGN="LEFT"/>checksum : NoneType<br ALIGN="LEFT"/>contact : str<br ALIGN="LEFT"/>copyright : str<br ALIGN="LEFT"/>filename<br ALIGN="LEFT"/>id<br ALIGN="LEFT"/>license : str<br ALIGN="LEFT"/>name<br ALIGN="LEFT"/>size : int<br ALIGN="LEFT"/>subdir : str<br ALIGN="LEFT"/>svn_revision : NoneType<br ALIGN="LEFT"/>unzip : bool<br ALIGN="LEFT"/>unzipped_size : int<br ALIGN="LEFT"/>url<br ALIGN="LEFT"/>|fromxml(xml)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.metrics.paice.Paice" [color="black", fontcolor="black", label=<{Paice|coords : list<br ALIGN="LEFT"/>errt : NoneType, float<br ALIGN="LEFT"/>gdmt : NoneType, float<br ALIGN="LEFT"/>gdnt : NoneType, float<br ALIGN="LEFT"/>gumt : NoneType, float<br ALIGN="LEFT"/>gwmt : NoneType, float<br ALIGN="LEFT"/>lemmas<br ALIGN="LEFT"/>oi : NoneType, float<br ALIGN="LEFT"/>stems : dict<br ALIGN="LEFT"/>sw : NoneType, float<br ALIGN="LEFT"/>ui : NoneType, float<br ALIGN="LEFT"/>|update()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.inference.api.ParallelProverBuilder" [color="black", fontcolor="black", label=<{ParallelProverBuilder|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"nltk.inference.api.ParallelProverBuilderCommand" [color="black", fontcolor="black", label=<{ParallelProverBuilderCommand|<br ALIGN="LEFT"/>|build_model(verbose)<br ALIGN="LEFT"/>prove(verbose)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.draw.util.ParenWidget" [color="black", fontcolor="black", label=<{ParenWidget|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"nltk.tree.ParentedTree" [color="black", fontcolor="black", label=<{ParentedTree|<br ALIGN="LEFT"/>|left_sibling()<br ALIGN="LEFT"/>parent()<br ALIGN="LEFT"/>parent_index()<br ALIGN="LEFT"/>right_sibling()<br ALIGN="LEFT"/>root()<br ALIGN="LEFT"/>treeposition()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.parse.api.ParserI" [color="black", fontcolor="black", label=<{ParserI|<br ALIGN="LEFT"/>|<I>grammar</I>()<br ALIGN="LEFT"/>parse(sent)<br ALIGN="LEFT"/>parse_all(sent)<br ALIGN="LEFT"/>parse_one(sent)<br ALIGN="LEFT"/>parse_sents(sents)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.sem.boxer.PassthroughBoxerDrsInterpreter" [color="black", fontcolor="black", label=<{PassthroughBoxerDrsInterpreter|<br ALIGN="LEFT"/>|interpret(ex)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.data.PathPointer" [color="black", fontcolor="black", label=<{PathPointer|<br ALIGN="LEFT"/>|<I>file_size</I>()<br ALIGN="LEFT"/><I>join</I>(fileid)<br ALIGN="LEFT"/><I>open</I>(encoding)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.corpus.reader.util.PickleCorpusView" [color="black", fontcolor="black", label=<{PickleCorpusView|BLOCK_SIZE : int<br ALIGN="LEFT"/>PROTOCOL : int<br ALIGN="LEFT"/>|cache_to_tempfile(sequence, delete_on_gc)<br ALIGN="LEFT"/>read_block(stream)<br ALIGN="LEFT"/>write(sequence, output_file)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.corpus.reader.pl196x.Pl196xCorpusReader" [color="black", fontcolor="black", label=<{Pl196xCorpusReader|headLen : int<br ALIGN="LEFT"/>|decode_tag(tag)<br ALIGN="LEFT"/>paras(fileids, categories, textids)<br ALIGN="LEFT"/>raw(fileids, categories)<br ALIGN="LEFT"/>sents(fileids, categories, textids)<br ALIGN="LEFT"/>tagged_paras(fileids, categories, textids)<br ALIGN="LEFT"/>tagged_sents(fileids, categories, textids)<br ALIGN="LEFT"/>tagged_words(fileids, categories, textids)<br ALIGN="LEFT"/>textids(fileids, categories)<br ALIGN="LEFT"/>words(fileids, categories, textids)<br ALIGN="LEFT"/>xml(fileids, categories)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.corpus.reader.plaintext.PlaintextCorpusReader" [color="black", fontcolor="black", label=<{PlaintextCorpusReader|CorpusView<br ALIGN="LEFT"/>|paras(fileids)<br ALIGN="LEFT"/>raw(fileids)<br ALIGN="LEFT"/>sents(fileids)<br ALIGN="LEFT"/>words(fileids)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.stem.porter.PorterStemmer" [color="black", fontcolor="black", label=<{PorterStemmer|pool : dict<br ALIGN="LEFT"/>vowels : frozenset<br ALIGN="LEFT"/>|stem(word)<br ALIGN="LEFT"/>stem_word(p, i, j)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.stem.snowball.PorterStemmer" [color="black", fontcolor="black", label=<{PorterStemmer|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"nltk.corpus.reader.plaintext.PortugueseCategorizedPlaintextCorpusReader" [color="black", fontcolor="black", label=<{PortugueseCategorizedPlaintextCorpusReader|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"nltk.stem.snowball.PortugueseStemmer" [color="black", fontcolor="black", label=<{PortugueseStemmer|<br ALIGN="LEFT"/>|stem(word)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.tag.brill.Pos" [color="black", fontcolor="black", label=<{Pos|json_tag : str<br ALIGN="LEFT"/>|extract_property(tokens, index)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.classify.positivenaivebayes.PositiveNaiveBayesClassifier" [color="black", fontcolor="black", label=<{PositiveNaiveBayesClassifier|<br ALIGN="LEFT"/>|train(positive_featuresets, unlabeled_featuresets, positive_prob_prior, estimator)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.sem.drt.PossibleAntecedents" [color="black", fontcolor="black", label=<{PossibleAntecedents|<br ALIGN="LEFT"/>|free()<br ALIGN="LEFT"/>replace(variable, expression, replace_bound, alpha_convert)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.inference.nonmonotonic.PredHolder" [color="black", fontcolor="black", label=<{PredHolder|properties : list<br ALIGN="LEFT"/>signature_len : NoneType<br ALIGN="LEFT"/>signatures : list<br ALIGN="LEFT"/>|append_prop(new_prop)<br ALIGN="LEFT"/>append_sig(new_sig)<br ALIGN="LEFT"/>validate_sig_len(new_sig)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.parse.earleychart.PredictorRule" [color="black", fontcolor="black", label=<{PredictorRule|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"nltk.corpus.reader.framenet.PrettyDict" [color="black", fontcolor="black", label=<{PrettyDict|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"nltk.corpus.reader.framenet.PrettyLazyMap" [color="black", fontcolor="black", label=<{PrettyLazyMap|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"nltk.corpus.reader.framenet.PrettyList" [color="black", fontcolor="black", label=<{PrettyList|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"nltk.ccg.api.PrimitiveCategory" [color="black", fontcolor="black", label=<{PrimitiveCategory|<br ALIGN="LEFT"/>|can_unify(other)<br ALIGN="LEFT"/>categ()<br ALIGN="LEFT"/>is_function()<br ALIGN="LEFT"/>is_primitive()<br ALIGN="LEFT"/>is_var()<br ALIGN="LEFT"/>restrs()<br ALIGN="LEFT"/>substitute(subs)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.probability.ProbDistI" [color="black", fontcolor="black", label=<{ProbDistI|SUM_TO_ONE : bool<br ALIGN="LEFT"/>|discount()<br ALIGN="LEFT"/>generate()<br ALIGN="LEFT"/>logprob(sample)<br ALIGN="LEFT"/><I>max</I>()<br ALIGN="LEFT"/><I>prob</I>(sample)<br ALIGN="LEFT"/><I>samples</I>()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.parse.pchart.ProbabilisticBottomUpInitRule" [color="black", fontcolor="black", label=<{ProbabilisticBottomUpInitRule|NUM_EDGES : int<br ALIGN="LEFT"/>|apply(chart, grammar)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.parse.pchart.ProbabilisticBottomUpPredictRule" [color="black", fontcolor="black", label=<{ProbabilisticBottomUpPredictRule|NUM_EDGES : int<br ALIGN="LEFT"/>|apply(chart, grammar, edge)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.grammar.ProbabilisticDependencyGrammar" [color="black", fontcolor="black", label=<{ProbabilisticDependencyGrammar|<br ALIGN="LEFT"/>|contains(head, mod)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.parse.pchart.ProbabilisticFundamentalRule" [color="black", fontcolor="black", label=<{ProbabilisticFundamentalRule|NUM_EDGES : int<br ALIGN="LEFT"/>|apply(chart, grammar, left_edge, right_edge)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.parse.pchart.ProbabilisticLeafEdge" [color="black", fontcolor="black", label=<{ProbabilisticLeafEdge|<br ALIGN="LEFT"/>|prob()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.probability.ProbabilisticMixIn" [color="black", fontcolor="black", label=<{ProbabilisticMixIn|<br ALIGN="LEFT"/>|logprob()<br ALIGN="LEFT"/>prob()<br ALIGN="LEFT"/>set_logprob(logprob)<br ALIGN="LEFT"/>set_prob(prob)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.parse.nonprojectivedependencyparser.ProbabilisticNonprojectiveParser" [color="black", fontcolor="black", label=<{ProbabilisticNonprojectiveParser|inner_nodes : dict<br ALIGN="LEFT"/>scores<br ALIGN="LEFT"/>|best_incoming_arc(node_index)<br ALIGN="LEFT"/>collapse_nodes(new_node, cycle_path, g_graph, b_graph, c_graph)<br ALIGN="LEFT"/>compute_max_subtract_score(column_index, cycle_indexes)<br ALIGN="LEFT"/>compute_original_indexes(new_indexes)<br ALIGN="LEFT"/>initialize_edge_scores(graph)<br ALIGN="LEFT"/>original_best_arc(node_index)<br ALIGN="LEFT"/>parse(tokens, tags)<br ALIGN="LEFT"/>train(graphs, dependency_scorer)<br ALIGN="LEFT"/>update_edge_scores(new_node, cycle_path)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.grammar.ProbabilisticProduction" [color="black", fontcolor="black", label=<{ProbabilisticProduction|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"nltk.parse.projectivedependencyparser.ProbabilisticProjectiveDependencyParser" [color="black", fontcolor="black", label=<{ProbabilisticProjectiveDependencyParser|<br ALIGN="LEFT"/>|compute_prob(dg)<br ALIGN="LEFT"/>concatenate(span1, span2)<br ALIGN="LEFT"/>parse(tokens)<br ALIGN="LEFT"/>train(graphs)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.tree.ProbabilisticTree" [color="black", fontcolor="black", label=<{ProbabilisticTree|<br ALIGN="LEFT"/>|convert(val)<br ALIGN="LEFT"/>copy(deep)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.parse.pchart.ProbabilisticTreeEdge" [color="black", fontcolor="black", label=<{ProbabilisticTreeEdge|<br ALIGN="LEFT"/>|from_production(production, index, p)<br ALIGN="LEFT"/>prob()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.grammar.Production" [color="black", fontcolor="black", label=<{Production|<br ALIGN="LEFT"/>|is_lexical()<br ALIGN="LEFT"/>is_nonlexical()<br ALIGN="LEFT"/>lhs()<br ALIGN="LEFT"/>rhs()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.draw.cfg.ProductionList" [color="black", fontcolor="black", label=<{ProductionList|ARROW<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"nltk.downloader.ProgressMessage" [color="black", fontcolor="black", label=<{ProgressMessage|progress<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"nltk.parse.projectivedependencyparser.ProjectiveDependencyParser" [color="black", fontcolor="black", label=<{ProjectiveDependencyParser|<br ALIGN="LEFT"/>|concatenate(span1, span2)<br ALIGN="LEFT"/>parse(tokens)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.corpus.reader.propbank.PropbankChainTreePointer" [color="black", fontcolor="black", label=<{PropbankChainTreePointer|pieces<br ALIGN="LEFT"/>|select(tree)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.corpus.reader.propbank.PropbankCorpusReader" [color="black", fontcolor="black", label=<{PropbankCorpusReader|<br ALIGN="LEFT"/>|instances(baseform)<br ALIGN="LEFT"/>lines()<br ALIGN="LEFT"/>raw(fileids)<br ALIGN="LEFT"/>roleset(roleset_id)<br ALIGN="LEFT"/>rolesets(baseform)<br ALIGN="LEFT"/>verbs()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.corpus.reader.propbank.PropbankInflection" [color="black", fontcolor="black", label=<{PropbankInflection|ACTIVE : str<br ALIGN="LEFT"/>FINITE : str<br ALIGN="LEFT"/>FUTURE : str<br ALIGN="LEFT"/>GERUND : str<br ALIGN="LEFT"/>INFINITIVE : str<br ALIGN="LEFT"/>NONE : str<br ALIGN="LEFT"/>PARTICIPLE : str<br ALIGN="LEFT"/>PASSIVE : str<br ALIGN="LEFT"/>PAST : str<br ALIGN="LEFT"/>PERFECT : str<br ALIGN="LEFT"/>PERFECT_AND_PROGRESSIVE : str<br ALIGN="LEFT"/>PRESENT : str<br ALIGN="LEFT"/>PROGRESSIVE : str<br ALIGN="LEFT"/>THIRD_PERSON : str<br ALIGN="LEFT"/>aspect : str<br ALIGN="LEFT"/>form : str<br ALIGN="LEFT"/>person : str<br ALIGN="LEFT"/>tense : str<br ALIGN="LEFT"/>voice : str<br ALIGN="LEFT"/>|parse(s)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.corpus.reader.propbank.PropbankInstance" [color="black", fontcolor="black", label=<{PropbankInstance|arguments : tuple<br ALIGN="LEFT"/>baseform<br ALIGN="LEFT"/>fileid<br ALIGN="LEFT"/>inflection<br ALIGN="LEFT"/>parse_corpus : NoneType<br ALIGN="LEFT"/>predicate<br ALIGN="LEFT"/>predid<br ALIGN="LEFT"/>roleset<br ALIGN="LEFT"/>sensenumber<br ALIGN="LEFT"/>sentnum<br ALIGN="LEFT"/>tagger<br ALIGN="LEFT"/>tree<br ALIGN="LEFT"/>wordnum<br ALIGN="LEFT"/>|parse(s, parse_fileid_xform, parse_corpus)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.corpus.reader.propbank.PropbankPointer" [color="black", fontcolor="black", label=<{PropbankPointer|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"nltk.corpus.reader.propbank.PropbankSplitTreePointer" [color="black", fontcolor="black", label=<{PropbankSplitTreePointer|pieces<br ALIGN="LEFT"/>|select(tree)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.corpus.reader.propbank.PropbankTreePointer" [color="black", fontcolor="black", label=<{PropbankTreePointer|height<br ALIGN="LEFT"/>wordnum<br ALIGN="LEFT"/>|parse(s)<br ALIGN="LEFT"/>select(tree)<br ALIGN="LEFT"/>treepos(tree)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.inference.api.Prover" [color="black", fontcolor="black", label=<{Prover|<br ALIGN="LEFT"/>|prove(goal, assumptions, verbose)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.inference.prover9.Prover9" [color="black", fontcolor="black", label=<{Prover9|<br ALIGN="LEFT"/>|prover9_input(goal, assumptions)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.inference.prover9.Prover9Command" [color="black", fontcolor="black", label=<{Prover9Command|prover9_search : list<br ALIGN="LEFT"/>|decorate_proof(proof_string, simplify)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.inference.prover9.Prover9CommandParent" [color="black", fontcolor="black", label=<{Prover9CommandParent|<br ALIGN="LEFT"/>|print_assumptions(output_format)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.inference.prover9.Prover9Exception" [color="black", fontcolor="red", label=<{Prover9Exception|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"nltk.inference.prover9.Prover9FatalException" [color="black", fontcolor="red", label=<{Prover9FatalException|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"nltk.inference.prover9.Prover9LimitExceededException" [color="black", fontcolor="red", label=<{Prover9LimitExceededException|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"nltk.inference.prover9.Prover9Parent" [color="black", fontcolor="black", label=<{Prover9Parent|<br ALIGN="LEFT"/>|binary_locations()<br ALIGN="LEFT"/>config_prover9(binary_location, verbose)<br ALIGN="LEFT"/>prover9_input(goal, assumptions)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.inference.api.ProverCommand" [color="black", fontcolor="black", label=<{ProverCommand|<br ALIGN="LEFT"/>|<I>get_prover</I>()<br ALIGN="LEFT"/><I>proof</I>(simplify)<br ALIGN="LEFT"/><I>prove</I>(verbose)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.inference.api.ProverCommandDecorator" [color="black", fontcolor="black", label=<{ProverCommandDecorator|<br ALIGN="LEFT"/>|decorate_proof(proof_string, simplify)<br ALIGN="LEFT"/>get_prover()<br ALIGN="LEFT"/>proof(simplify)<br ALIGN="LEFT"/>prove(verbose)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.inference.nonmonotonic.ProverParseError" [color="black", fontcolor="red", label=<{ProverParseError|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"nltk.inference.resolution.ProverParseError" [color="black", fontcolor="red", label=<{ProverParseError|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"nltk.inference.tableau.ProverParseError" [color="black", fontcolor="red", label=<{ProverParseError|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"nltk.tokenize.punkt.PunktBaseClass" [color="black", fontcolor="black", label=<{PunktBaseClass|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"nltk.tokenize.punkt.PunktLanguageVars" [color="black", fontcolor="black", label=<{PunktLanguageVars|internal_punctuation : str<br ALIGN="LEFT"/>re_boundary_realignment<br ALIGN="LEFT"/>sent_end_chars : tuple<br ALIGN="LEFT"/>|period_context_re()<br ALIGN="LEFT"/>word_tokenize(s)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.tokenize.punkt.PunktParameters" [color="black", fontcolor="black", label=<{PunktParameters|abbrev_types : set<br ALIGN="LEFT"/>collocations : set<br ALIGN="LEFT"/>ortho_context : defaultdict<br ALIGN="LEFT"/>sent_starters : set<br ALIGN="LEFT"/>|add_ortho_context(typ, flag)<br ALIGN="LEFT"/>clear_abbrevs()<br ALIGN="LEFT"/>clear_collocations()<br ALIGN="LEFT"/>clear_ortho_context()<br ALIGN="LEFT"/>clear_sent_starters()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.tokenize.punkt.PunktSentenceTokenizer" [color="black", fontcolor="black", label=<{PunktSentenceTokenizer|PUNCTUATION : tuple<br ALIGN="LEFT"/>|debug_decisions(text)<br ALIGN="LEFT"/>dump(tokens)<br ALIGN="LEFT"/>sentences_from_text(text, realign_boundaries)<br ALIGN="LEFT"/>sentences_from_text_legacy(text)<br ALIGN="LEFT"/>sentences_from_tokens(tokens)<br ALIGN="LEFT"/>span_tokenize(text, realign_boundaries)<br ALIGN="LEFT"/>text_contains_sentbreak(text)<br ALIGN="LEFT"/>tokenize(text, realign_boundaries)<br ALIGN="LEFT"/>train(train_text, verbose)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.tokenize.punkt.PunktToken" [color="black", fontcolor="black", label=<{PunktToken|first_case<br ALIGN="LEFT"/>first_lower<br ALIGN="LEFT"/>first_upper<br ALIGN="LEFT"/>is_alpha<br ALIGN="LEFT"/>is_ellipsis<br ALIGN="LEFT"/>is_initial<br ALIGN="LEFT"/>is_non_punct<br ALIGN="LEFT"/>is_number<br ALIGN="LEFT"/>period_final<br ALIGN="LEFT"/>tok<br ALIGN="LEFT"/>type<br ALIGN="LEFT"/>type_no_period<br ALIGN="LEFT"/>type_no_sentperiod<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"nltk.tokenize.punkt.PunktTrainer" [color="black", fontcolor="black", label=<{PunktTrainer|ABBREV : float<br ALIGN="LEFT"/>ABBREV_BACKOFF : int<br ALIGN="LEFT"/>COLLOCATION : float<br ALIGN="LEFT"/>IGNORE_ABBREV_PENALTY : bool<br ALIGN="LEFT"/>INCLUDE_ABBREV_COLLOCS : bool<br ALIGN="LEFT"/>INCLUDE_ALL_COLLOCS : bool<br ALIGN="LEFT"/>MIN_COLLOC_FREQ : int<br ALIGN="LEFT"/>SENT_STARTER : int<br ALIGN="LEFT"/>|finalize_training(verbose)<br ALIGN="LEFT"/>find_abbrev_types()<br ALIGN="LEFT"/>freq_threshold(ortho_thresh, type_thresh, colloc_thres, sentstart_thresh)<br ALIGN="LEFT"/>get_params()<br ALIGN="LEFT"/>train(text, verbose, finalize)<br ALIGN="LEFT"/>train_tokens(tokens, verbose, finalize)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.metrics.association.QuadgramAssocMeasures" [color="black", fontcolor="black", label=<{QuadgramAssocMeasures|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"nltk.collocations.QuadgramCollocationFinder" [color="black", fontcolor="black", label=<{QuadgramCollocationFinder|ii<br ALIGN="LEFT"/>iii<br ALIGN="LEFT"/>iixi<br ALIGN="LEFT"/>ixi<br ALIGN="LEFT"/>ixii<br ALIGN="LEFT"/>ixxi<br ALIGN="LEFT"/>|from_words(words, window_size)<br ALIGN="LEFT"/>score_ngram(score_fn, w1, w2, w3, w4)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.sem.logic.QuantifiedExpression" [color="black", fontcolor="black", label=<{QuantifiedExpression|type<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"nltk.stem.rslp.RSLPStemmer" [color="black", fontcolor="black", label=<{RSLPStemmer|<br ALIGN="LEFT"/>|apply_rule(word, rule_index)<br ALIGN="LEFT"/>read_rule(filename)<br ALIGN="LEFT"/>stem(word)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.corpus.reader.rte.RTECorpusReader" [color="black", fontcolor="black", label=<{RTECorpusReader|<br ALIGN="LEFT"/>|pairs(fileids)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.classify.rte_classify.RTEFeatureExtractor" [color="black", fontcolor="black", label=<{RTEFeatureExtractor|hyp_tokens<br ALIGN="LEFT"/>hyp_words : set<br ALIGN="LEFT"/>negwords : set<br ALIGN="LEFT"/>stop : bool<br ALIGN="LEFT"/>stopwords : set<br ALIGN="LEFT"/>text_tokens<br ALIGN="LEFT"/>text_words : set<br ALIGN="LEFT"/>|hyp_extra(toktype, debug)<br ALIGN="LEFT"/>overlap(toktype, debug)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.corpus.reader.rte.RTEPair" [color="black", fontcolor="black", label=<{RTEPair|challenge : NoneType<br ALIGN="LEFT"/>gid<br ALIGN="LEFT"/>hyp<br ALIGN="LEFT"/>id<br ALIGN="LEFT"/>length : NoneType<br ALIGN="LEFT"/>task : NoneType<br ALIGN="LEFT"/>text<br ALIGN="LEFT"/>value : NoneType<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"nltk.parse.pchart.RandomChartParser" [color="black", fontcolor="black", label=<{RandomChartParser|<br ALIGN="LEFT"/>|sort_queue(queue, chart)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.probability.RandomProbDist" [color="black", fontcolor="black", label=<{RandomProbDist|<br ALIGN="LEFT"/>|prob(sample)<br ALIGN="LEFT"/>samples()<br ALIGN="LEFT"/>unirand(samples)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.featstruct.RangeFeature" [color="black", fontcolor="black", label=<{RangeFeature|RANGE_RE<br ALIGN="LEFT"/>|read_value(s, position, reentrances, parser)<br ALIGN="LEFT"/>unify_base_values(fval1, fval2, bindings)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.internals.ReadError" [color="black", fontcolor="red", label=<{ReadError|expected<br ALIGN="LEFT"/>position<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"nltk.inference.discourse.ReadingCommand" [color="black", fontcolor="black", label=<{ReadingCommand|<br ALIGN="LEFT"/>|<I>combine_readings</I>(readings)<br ALIGN="LEFT"/><I>parse_to_readings</I>(sentence)<br ALIGN="LEFT"/>process_thread(sentence_readings)<br ALIGN="LEFT"/><I>to_fol</I>(expression)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.app.rdparser_app.RecursiveDescentApp" [color="black", fontcolor="black", label=<{RecursiveDescentApp|<br ALIGN="LEFT"/>|about()<br ALIGN="LEFT"/>autostep()<br ALIGN="LEFT"/>backtrack()<br ALIGN="LEFT"/>cancel_autostep()<br ALIGN="LEFT"/>destroy()<br ALIGN="LEFT"/>edit_grammar()<br ALIGN="LEFT"/>edit_sentence()<br ALIGN="LEFT"/>expand()<br ALIGN="LEFT"/>help()<br ALIGN="LEFT"/>mainloop()<br ALIGN="LEFT"/>match()<br ALIGN="LEFT"/>postscript()<br ALIGN="LEFT"/>reset()<br ALIGN="LEFT"/>resize(size)<br ALIGN="LEFT"/>set_grammar(grammar)<br ALIGN="LEFT"/>set_sentence(sentence)<br ALIGN="LEFT"/>step()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.parse.recursivedescent.RecursiveDescentParser" [color="black", fontcolor="black", label=<{RecursiveDescentParser|<br ALIGN="LEFT"/>|grammar()<br ALIGN="LEFT"/>parse(tokens)<br ALIGN="LEFT"/>trace(trace)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.app.wordnet_app.Reference" [color="black", fontcolor="black", label=<{Reference|synset_relations : dict<br ALIGN="LEFT"/>word<br ALIGN="LEFT"/>|decode(string)<br ALIGN="LEFT"/>encode()<br ALIGN="LEFT"/>toggle_synset(synset)<br ALIGN="LEFT"/>toggle_synset_relation(synset, relation)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.app.chunkparser_app.RegexpChunkApp" [color="black", fontcolor="black", label=<{RegexpChunkApp|HELP : list<br ALIGN="LEFT"/>HELP_AUTOTAG : list<br ALIGN="LEFT"/>SAVE_GRAMMAR_TEMPLATE : str<br ALIGN="LEFT"/>TAGSET : dict<br ALIGN="LEFT"/>charnum : dict<br ALIGN="LEFT"/>chunker : NoneType<br ALIGN="LEFT"/>devset : NoneType<br ALIGN="LEFT"/>devset_button : Button<br ALIGN="LEFT"/>devset_index : int<br ALIGN="LEFT"/>devset_name : str<br ALIGN="LEFT"/>devset_scroll : Scrollbar<br ALIGN="LEFT"/>devset_xscroll : Scrollbar<br ALIGN="LEFT"/>devsetbox : Text<br ALIGN="LEFT"/>devsetlabel : Label<br ALIGN="LEFT"/>evalbox : Canvas<br ALIGN="LEFT"/>grammar : NoneType, str<br ALIGN="LEFT"/>grammar_changed : int<br ALIGN="LEFT"/>grammarbox : Text<br ALIGN="LEFT"/>grammarlabel : Label<br ALIGN="LEFT"/>helpbox : Text<br ALIGN="LEFT"/>helptabs : dict<br ALIGN="LEFT"/>linenum : dict<br ALIGN="LEFT"/>normalized_grammar : NoneType<br ALIGN="LEFT"/>status : Label<br ALIGN="LEFT"/>tagset : NoneType, dict<br ALIGN="LEFT"/>top : NoneType, Tk<br ALIGN="LEFT"/>trace_button : Button<br ALIGN="LEFT"/>|about()<br ALIGN="LEFT"/>destroy()<br ALIGN="LEFT"/>load_grammar(filename)<br ALIGN="LEFT"/>mainloop()<br ALIGN="LEFT"/>normalize_grammar(grammar)<br ALIGN="LEFT"/>reset()<br ALIGN="LEFT"/>resize(size)<br ALIGN="LEFT"/>save_grammar(filename)<br ALIGN="LEFT"/>save_history(filename)<br ALIGN="LEFT"/>set_devset_size(size)<br ALIGN="LEFT"/>show_devset(index)<br ALIGN="LEFT"/>show_help(tab)<br ALIGN="LEFT"/>show_trace()<br ALIGN="LEFT"/>toggle_show_trace()<br ALIGN="LEFT"/>update()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.chunk.regexp.RegexpChunkParser" [color="black", fontcolor="black", label=<{RegexpChunkParser|<br ALIGN="LEFT"/>|parse(chunk_struct, trace)<br ALIGN="LEFT"/>rules()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.chunk.regexp.RegexpChunkRule" [color="black", fontcolor="black", label=<{RegexpChunkRule|<br ALIGN="LEFT"/>|apply(chunkstr)<br ALIGN="LEFT"/>descr()<br ALIGN="LEFT"/>fromstring(s)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.chunk.regexp.RegexpParser" [color="black", fontcolor="black", label=<{RegexpParser|<br ALIGN="LEFT"/>|parse(chunk_struct, trace)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.stem.regexp.RegexpStemmer" [color="black", fontcolor="black", label=<{RegexpStemmer|<br ALIGN="LEFT"/>|stem(word)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.tag.sequential.RegexpTagger" [color="black", fontcolor="black", label=<{RegexpTagger|json_tag : str<br ALIGN="LEFT"/>|choose_tag(tokens, index, history)<br ALIGN="LEFT"/>decode_json_obj(obj)<br ALIGN="LEFT"/>encode_json_obj()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.tokenize.regexp.RegexpTokenizer" [color="black", fontcolor="black", label=<{RegexpTokenizer|<br ALIGN="LEFT"/>|span_tokenize(text)<br ALIGN="LEFT"/>tokenize(text)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.app.nemo_app.ReplaceZone" [color="black", fontcolor="black", label=<{ReplaceZone|diff : int<br ALIGN="LEFT"/>repl<br ALIGN="LEFT"/>|addTags(m)<br ALIGN="LEFT"/>substitute()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.inference.resolution.ResolutionProver" [color="black", fontcolor="black", label=<{ResolutionProver|ANSWER_KEY : str<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"nltk.inference.resolution.ResolutionProverCommand" [color="black", fontcolor="black", label=<{ResolutionProverCommand|<br ALIGN="LEFT"/>|find_answers(verbose)<br ALIGN="LEFT"/>prove(verbose)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.stem.snowball.RomanianStemmer" [color="black", fontcolor="black", label=<{RomanianStemmer|<br ALIGN="LEFT"/>|stem(word)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.tbl.rule.Rule" [color="black", fontcolor="black", label=<{Rule|json_tag : str<br ALIGN="LEFT"/>templateid<br ALIGN="LEFT"/>|applies(tokens, index)<br ALIGN="LEFT"/>decode_json_obj(obj)<br ALIGN="LEFT"/>encode_json_obj()<br ALIGN="LEFT"/>format(fmt)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.stem.snowball.RussianStemmer" [color="black", fontcolor="black", label=<{RussianStemmer|<br ALIGN="LEFT"/>|stem(word)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.tokenize.sexpr.SExprTokenizer" [color="black", fontcolor="black", label=<{SExprTokenizer|<br ALIGN="LEFT"/>|tokenize(text)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.parse.earleychart.ScannerRule" [color="black", fontcolor="black", label=<{ScannerRule|<br ALIGN="LEFT"/>|apply(chart, grammar, edge)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.draw.util.ScrollWatcherWidget" [color="black", fontcolor="black", label=<{ScrollWatcherWidget|<br ALIGN="LEFT"/>|add_child(canvaswidget)<br ALIGN="LEFT"/>remove_child(canvaswidget)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.app.concordance_app.ConcordanceSearchModel.SearchCorpus" [color="black", fontcolor="black", label=<{SearchCorpus|count<br ALIGN="LEFT"/>model<br ALIGN="LEFT"/>page<br ALIGN="LEFT"/>|processed_query()<br ALIGN="LEFT"/>run()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.data.SeekableUnicodeStreamReader" [color="black", fontcolor="black", label=<{SeekableUnicodeStreamReader|DEBUG : bool<br ALIGN="LEFT"/>bytebuffer : bytes<br ALIGN="LEFT"/>closed<br ALIGN="LEFT"/>decode<br ALIGN="LEFT"/>encoding<br ALIGN="LEFT"/>errors : str<br ALIGN="LEFT"/>linebuffer : NoneType<br ALIGN="LEFT"/>mode<br ALIGN="LEFT"/>name<br ALIGN="LEFT"/>stream<br ALIGN="LEFT"/>|char_seek_forward(offset)<br ALIGN="LEFT"/>close()<br ALIGN="LEFT"/>next()<br ALIGN="LEFT"/>read(size)<br ALIGN="LEFT"/>readline(size)<br ALIGN="LEFT"/>readlines(sizehint, keepends)<br ALIGN="LEFT"/>seek(offset, whence)<br ALIGN="LEFT"/>tell()<br ALIGN="LEFT"/>xreadlines()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.downloader.SelectDownloadDirMessage" [color="black", fontcolor="black", label=<{SelectDownloadDirMessage|download_dir<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"nltk.corpus.reader.semcor.SemcorCorpusReader" [color="black", fontcolor="black", label=<{SemcorCorpusReader|<br ALIGN="LEFT"/>|chunk_sents(fileids)<br ALIGN="LEFT"/>chunks(fileids)<br ALIGN="LEFT"/>sents(fileids)<br ALIGN="LEFT"/>tagged_chunks(fileids, tag)<br ALIGN="LEFT"/>tagged_sents(fileids, tag)<br ALIGN="LEFT"/>words(fileids)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.corpus.reader.semcor.SemcorSentence" [color="black", fontcolor="black", label=<{SemcorSentence|num<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"nltk.corpus.reader.semcor.SemcorWordView" [color="black", fontcolor="black", label=<{SemcorWordView|<br ALIGN="LEFT"/>|handle_elt(elt, context)<br ALIGN="LEFT"/>handle_sent(elt)<br ALIGN="LEFT"/>handle_word(elt)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.classify.senna.Senna" [color="black", fontcolor="black", label=<{Senna|SUPPORTED_OPERATIONS : list<br ALIGN="LEFT"/>operations<br ALIGN="LEFT"/>|executable(base_path)<br ALIGN="LEFT"/>tag(tokens)<br ALIGN="LEFT"/>tag_sents(sentences)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.tag.senna.SennaChunkTagger" [color="black", fontcolor="black", label=<{SennaChunkTagger|<br ALIGN="LEFT"/>|tag_sents(sentences)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.tag.senna.SennaNERTagger" [color="black", fontcolor="black", label=<{SennaNERTagger|<br ALIGN="LEFT"/>|tag_sents(sentences)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.tag.senna.SennaTagger" [color="black", fontcolor="black", label=<{SennaTagger|<br ALIGN="LEFT"/>|tag_sents(sentences)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.corpus.reader.senseval.SensevalCorpusReader" [color="black", fontcolor="black", label=<{SensevalCorpusReader|<br ALIGN="LEFT"/>|instances(fileids)<br ALIGN="LEFT"/>raw(fileids)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.corpus.reader.senseval.SensevalCorpusView" [color="black", fontcolor="black", label=<{SensevalCorpusView|<br ALIGN="LEFT"/>|read_block(stream)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.corpus.reader.senseval.SensevalInstance" [color="black", fontcolor="black", label=<{SensevalInstance|context<br ALIGN="LEFT"/>position<br ALIGN="LEFT"/>senses : tuple<br ALIGN="LEFT"/>word<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"nltk.corpus.reader.sentiwordnet.SentiSynset" [color="black", fontcolor="black", label=<{SentiSynset|synset<br ALIGN="LEFT"/>|neg_score()<br ALIGN="LEFT"/>obj_score()<br ALIGN="LEFT"/>pos_score()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.corpus.reader.sentiwordnet.SentiWordNetCorpusReader" [color="black", fontcolor="black", label=<{SentiWordNetCorpusReader|<br ALIGN="LEFT"/>|all_senti_synsets()<br ALIGN="LEFT"/>senti_synset()<br ALIGN="LEFT"/>senti_synsets(string, pos)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.draw.util.SequenceWidget" [color="black", fontcolor="black", label=<{SequenceWidget|children<br ALIGN="LEFT"/>|insert_child(index, child)<br ALIGN="LEFT"/>remove_child(child)<br ALIGN="LEFT"/>replace_child(oldchild, newchild)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.tag.sequential.SequentialBackoffTagger" [color="black", fontcolor="black", label=<{SequentialBackoffTagger|backoff<br ALIGN="LEFT"/>|<I>choose_tag</I>(tokens, index, history)<br ALIGN="LEFT"/>tag(tokens)<br ALIGN="LEFT"/>tag_one(tokens, index, history)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.inference.nonmonotonic.SetHolder" [color="black", fontcolor="black", label=<{SetHolder|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"nltk.app.srparser_app.ShiftReduceApp" [color="black", fontcolor="black", label=<{ShiftReduceApp|<br ALIGN="LEFT"/>|about()<br ALIGN="LEFT"/>destroy()<br ALIGN="LEFT"/>edit_grammar()<br ALIGN="LEFT"/>edit_sentence()<br ALIGN="LEFT"/>help()<br ALIGN="LEFT"/>mainloop()<br ALIGN="LEFT"/>postscript()<br ALIGN="LEFT"/>reduce()<br ALIGN="LEFT"/>reset()<br ALIGN="LEFT"/>resize(size)<br ALIGN="LEFT"/>set_grammar(grammar)<br ALIGN="LEFT"/>set_sentence(sent)<br ALIGN="LEFT"/>shift()<br ALIGN="LEFT"/>step()<br ALIGN="LEFT"/>undo()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.parse.shiftreduce.ShiftReduceParser" [color="black", fontcolor="black", label=<{ShiftReduceParser|<br ALIGN="LEFT"/>|grammar()<br ALIGN="LEFT"/>parse(tokens)<br ALIGN="LEFT"/>trace(trace)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.draw.util.ShowText" [color="black", fontcolor="black", label=<{ShowText|<br ALIGN="LEFT"/>|destroy()<br ALIGN="LEFT"/>find_dimentions(text, width, height)<br ALIGN="LEFT"/>mainloop()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.probability.SimpleGoodTuringProbDist" [color="black", fontcolor="black", label=<{SimpleGoodTuringProbDist|SUM_TO_ONE : bool<br ALIGN="LEFT"/>|check()<br ALIGN="LEFT"/>discount()<br ALIGN="LEFT"/>find_best_fit(r, nr)<br ALIGN="LEFT"/>freqdist()<br ALIGN="LEFT"/>max()<br ALIGN="LEFT"/>prob(sample)<br ALIGN="LEFT"/>samples()<br ALIGN="LEFT"/>smoothedNr(r)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.parse.chart.SingleEdgeFundamentalRule" [color="black", fontcolor="black", label=<{SingleEdgeFundamentalRule|NUM_EDGES : int<br ALIGN="LEFT"/>|apply(chart, grammar, edge)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.parse.pchart.SingleEdgeProbabilisticFundamentalRule" [color="black", fontcolor="black", label=<{SingleEdgeProbabilisticFundamentalRule|NUM_EDGES : int<br ALIGN="LEFT"/>|apply(chart, grammar, edge1)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.corpus.reader.sinica_treebank.SinicaTreebankCorpusReader" [color="black", fontcolor="black", label=<{SinicaTreebankCorpusReader|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"nltk.classify.scikitlearn.SklearnClassifier" [color="black", fontcolor="black", label=<{SklearnClassifier|<br ALIGN="LEFT"/>|classify_many(featuresets)<br ALIGN="LEFT"/>labels()<br ALIGN="LEFT"/>prob_classify_many(featuresets)<br ALIGN="LEFT"/>train(labeled_featuresets)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.featstruct.SlashFeature" [color="black", fontcolor="black", label=<{SlashFeature|<br ALIGN="LEFT"/>|read_value(s, position, reentrances, parser)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.stem.snowball.SnowballStemmer" [color="black", fontcolor="black", label=<{SnowballStemmer|languages : tuple<br ALIGN="LEFT"/>stem<br ALIGN="LEFT"/>stemmer<br ALIGN="LEFT"/>stopwords<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"nltk.test.unit.test_stem.SnowballTest" [color="black", fontcolor="black", label=<{SnowballTest|<br ALIGN="LEFT"/>|test_german()<br ALIGN="LEFT"/>test_russian()<br ALIGN="LEFT"/>test_short_strings_bug()<br ALIGN="LEFT"/>test_spanish()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.tokenize.simple.SpaceTokenizer" [color="black", fontcolor="black", label=<{SpaceTokenizer|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"nltk.draw.util.SpaceWidget" [color="black", fontcolor="black", label=<{SpaceWidget|<br ALIGN="LEFT"/>|set_height(height)<br ALIGN="LEFT"/>set_width(width)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.stem.snowball.SpanishStemmer" [color="black", fontcolor="black", label=<{SpanishStemmer|<br ALIGN="LEFT"/>|stem(word)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.corpus.reader.timit.SpeakerInfo" [color="black", fontcolor="black", label=<{SpeakerInfo|birthdate<br ALIGN="LEFT"/>comments : NoneType<br ALIGN="LEFT"/>dr<br ALIGN="LEFT"/>edu<br ALIGN="LEFT"/>ht<br ALIGN="LEFT"/>id<br ALIGN="LEFT"/>race<br ALIGN="LEFT"/>recdate<br ALIGN="LEFT"/>sex<br ALIGN="LEFT"/>use<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"nltk.chunk.regexp.SplitRule" [color="black", fontcolor="black", label=<{SplitRule|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"nltk.draw.util.StackWidget" [color="black", fontcolor="black", label=<{StackWidget|children<br ALIGN="LEFT"/>|insert_child(index, child)<br ALIGN="LEFT"/>remove_child(child)<br ALIGN="LEFT"/>replace_child(oldchild, newchild)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.downloader.StaleMessage" [color="black", fontcolor="black", label=<{StaleMessage|package<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"nltk.toolbox.StandardFormat" [color="black", fontcolor="black", label=<{StandardFormat|line_num : int<br ALIGN="LEFT"/>|close()<br ALIGN="LEFT"/>fields(strip, unwrap, encoding, errors, unicode_fields)<br ALIGN="LEFT"/>open(sfm_file)<br ALIGN="LEFT"/>open_string(s)<br ALIGN="LEFT"/>raw_fields()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.parse.stanford.StanfordParser" [color="black", fontcolor="black", label=<{StanfordParser|java_options : str<br ALIGN="LEFT"/>model_path : str<br ALIGN="LEFT"/>|parse_sents(sentences, verbose)<br ALIGN="LEFT"/>raw_parse(sentence, verbose)<br ALIGN="LEFT"/>raw_parse_sents(sentences, verbose)<br ALIGN="LEFT"/>tagged_parse(sentence, verbose)<br ALIGN="LEFT"/>tagged_parse_sents(sentences, verbose)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.tag.stanford.StanfordTagger" [color="black", fontcolor="black", label=<{StanfordTagger|java_options : str<br ALIGN="LEFT"/>|parse_output(text)<br ALIGN="LEFT"/>tag(tokens)<br ALIGN="LEFT"/>tag_sents(sentences)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.tokenize.stanford.StanfordTokenizer" [color="black", fontcolor="black", label=<{StanfordTokenizer|java_options : str<br ALIGN="LEFT"/>|tokenize(s)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.downloader.StartCollectionMessage" [color="black", fontcolor="black", label=<{StartCollectionMessage|collection<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"nltk.downloader.StartDownloadMessage" [color="black", fontcolor="black", label=<{StartDownloadMessage|package<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"nltk.downloader.StartPackageMessage" [color="black", fontcolor="black", label=<{StartPackageMessage|package<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"nltk.downloader.StartUnzipMessage" [color="black", fontcolor="black", label=<{StartUnzipMessage|package<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"nltk.stem.api.StemmerI" [color="black", fontcolor="black", label=<{StemmerI|<br ALIGN="LEFT"/>|<I>stem</I>(token)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.parse.chart.SteppingChartParser" [color="black", fontcolor="black", label=<{SteppingChartParser|<br ALIGN="LEFT"/>|chart()<br ALIGN="LEFT"/>current_chartrule()<br ALIGN="LEFT"/>grammar()<br ALIGN="LEFT"/>initialize(tokens)<br ALIGN="LEFT"/>parse(tokens, tree_class)<br ALIGN="LEFT"/>parses(tree_class)<br ALIGN="LEFT"/>set_chart(chart)<br ALIGN="LEFT"/>set_grammar(grammar)<br ALIGN="LEFT"/>set_strategy(strategy)<br ALIGN="LEFT"/>step()<br ALIGN="LEFT"/>strategy()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.parse.recursivedescent.SteppingRecursiveDescentParser" [color="black", fontcolor="black", label=<{SteppingRecursiveDescentParser|<br ALIGN="LEFT"/>|backtrack()<br ALIGN="LEFT"/>currently_complete()<br ALIGN="LEFT"/>expand(production)<br ALIGN="LEFT"/>expandable_productions()<br ALIGN="LEFT"/>frontier()<br ALIGN="LEFT"/>initialize(tokens)<br ALIGN="LEFT"/>match()<br ALIGN="LEFT"/>parse(tokens)<br ALIGN="LEFT"/>parses()<br ALIGN="LEFT"/>remaining_text()<br ALIGN="LEFT"/>set_grammar(grammar)<br ALIGN="LEFT"/>step()<br ALIGN="LEFT"/>tree()<br ALIGN="LEFT"/>untried_expandable_productions()<br ALIGN="LEFT"/>untried_match()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.parse.shiftreduce.SteppingShiftReduceParser" [color="black", fontcolor="black", label=<{SteppingShiftReduceParser|<br ALIGN="LEFT"/>|initialize(tokens)<br ALIGN="LEFT"/>parse(tokens)<br ALIGN="LEFT"/>parses()<br ALIGN="LEFT"/>reduce(production)<br ALIGN="LEFT"/>reducible_productions()<br ALIGN="LEFT"/>remaining_text()<br ALIGN="LEFT"/>set_grammar(grammar)<br ALIGN="LEFT"/>shift()<br ALIGN="LEFT"/>stack()<br ALIGN="LEFT"/>step()<br ALIGN="LEFT"/>undo()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.corpus.reader.util.StreamBackedCorpusView" [color="black", fontcolor="black", label=<{StreamBackedCorpusView|fileid<br ALIGN="LEFT"/>read_block : NoneType<br ALIGN="LEFT"/>|close()<br ALIGN="LEFT"/>iterate_from(start_tok)<br ALIGN="LEFT"/><I>read_block</I>(stream)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.corpus.reader.string_category.StringCategoryCorpusReader" [color="black", fontcolor="black", label=<{StringCategoryCorpusReader|<br ALIGN="LEFT"/>|raw(fileids)<br ALIGN="LEFT"/>tuples(fileids)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.tokenize.api.StringTokenizer" [color="black", fontcolor="black", label=<{StringTokenizer|<br ALIGN="LEFT"/>|span_tokenize(s)<br ALIGN="LEFT"/>tokenize(s)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.sem.logic.StringTrie" [color="black", fontcolor="black", label=<{StringTrie|LEAF : str<br ALIGN="LEFT"/>|insert(string)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.sem.logic.SubstituteBindingsI" [color="black", fontcolor="black", label=<{SubstituteBindingsI|<br ALIGN="LEFT"/>|<I>substitute_bindings</I>(bindings)<br ALIGN="LEFT"/><I>variables</I>()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.featstruct.SubstituteBindingsSequence" [color="black", fontcolor="black", label=<{SubstituteBindingsSequence|<br ALIGN="LEFT"/>|subst(v, bindings)<br ALIGN="LEFT"/>substitute_bindings(bindings)<br ALIGN="LEFT"/>variables()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.classify.svm.SvmClassifier" [color="black", fontcolor="black", label=<{SvmClassifier|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"nltk.corpus.reader.wordlist.SwadeshCorpusReader" [color="black", fontcolor="black", label=<{SwadeshCorpusReader|<br ALIGN="LEFT"/>|entries(fileids)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.stem.snowball.SwedishStemmer" [color="black", fontcolor="black", label=<{SwedishStemmer|<br ALIGN="LEFT"/>|stem(word)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.corpus.reader.switchboard.SwitchboardCorpusReader" [color="black", fontcolor="black", label=<{SwitchboardCorpusReader|<br ALIGN="LEFT"/>|discourses()<br ALIGN="LEFT"/>tagged_discourses(tagset)<br ALIGN="LEFT"/>tagged_turns(tagset)<br ALIGN="LEFT"/>tagged_words(tagset)<br ALIGN="LEFT"/>turns()<br ALIGN="LEFT"/>words()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.corpus.reader.switchboard.SwitchboardTurn" [color="black", fontcolor="black", label=<{SwitchboardTurn|id : int<br ALIGN="LEFT"/>speaker<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"nltk.draw.util.SymbolWidget" [color="black", fontcolor="black", label=<{SymbolWidget|SYMBOLS : dict<br ALIGN="LEFT"/>|set_symbol(symbol)<br ALIGN="LEFT"/>symbol()<br ALIGN="LEFT"/>symbolsheet(size)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.corpus.reader.wordnet.Synset" [color="black", fontcolor="black", label=<{Synset|hypernyms<br ALIGN="LEFT"/>instance_hypernyms<br ALIGN="LEFT"/>|closure(rel, depth)<br ALIGN="LEFT"/>common_hypernyms(other)<br ALIGN="LEFT"/>definition()<br ALIGN="LEFT"/>examples()<br ALIGN="LEFT"/>frame_ids()<br ALIGN="LEFT"/>hypernym_distances(distance, simulate_root)<br ALIGN="LEFT"/>hypernym_paths()<br ALIGN="LEFT"/>jcn_similarity(other, ic, verbose)<br ALIGN="LEFT"/>lch_similarity(other, verbose, simulate_root)<br ALIGN="LEFT"/>lemma_names(lang)<br ALIGN="LEFT"/>lemmas(lang)<br ALIGN="LEFT"/>lexname()<br ALIGN="LEFT"/>lin_similarity(other, ic, verbose)<br ALIGN="LEFT"/>lowest_common_hypernyms(other, simulate_root, use_min_depth)<br ALIGN="LEFT"/>max_depth()<br ALIGN="LEFT"/>min_depth()<br ALIGN="LEFT"/>name()<br ALIGN="LEFT"/>offset()<br ALIGN="LEFT"/>path_similarity(other, verbose, simulate_root)<br ALIGN="LEFT"/>pos()<br ALIGN="LEFT"/>res_similarity(other, ic, verbose)<br ALIGN="LEFT"/>root_hypernyms()<br ALIGN="LEFT"/>shortest_path_distance(other, simulate_root)<br ALIGN="LEFT"/>tree(rel, depth, cut_mark)<br ALIGN="LEFT"/>wup_similarity(other, verbose, simulate_root)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.corpus.reader.api.SyntaxCorpusReader" [color="black", fontcolor="black", label=<{SyntaxCorpusReader|<br ALIGN="LEFT"/>|parsed_sents(fileids)<br ALIGN="LEFT"/>raw(fileids)<br ALIGN="LEFT"/>sents(fileids)<br ALIGN="LEFT"/>tagged_sents(fileids, tagset)<br ALIGN="LEFT"/>tagged_words(fileids, tagset)<br ALIGN="LEFT"/>words(fileids)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.corpus.reader.pl196x.TEICorpusView" [color="black", fontcolor="black", label=<{TEICorpusView|<br ALIGN="LEFT"/>|read_block(stream)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.tokenize.simple.TabTokenizer" [color="black", fontcolor="black", label=<{TabTokenizer|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"nltk.draw.table.Table" [color="black", fontcolor="black", label=<{Table|column_names<br ALIGN="LEFT"/>columnconfig<br ALIGN="LEFT"/>itemconfig<br ALIGN="LEFT"/>rowconfig<br ALIGN="LEFT"/>|append(rowvalue)<br ALIGN="LEFT"/>bind(sequence, func, add)<br ALIGN="LEFT"/>bind_to_columns(sequence, func, add)<br ALIGN="LEFT"/>bind_to_labels(sequence, func, add)<br ALIGN="LEFT"/>bind_to_listboxes(sequence, func, add)<br ALIGN="LEFT"/>clear()<br ALIGN="LEFT"/>column_index(i)<br ALIGN="LEFT"/>columnconfigure(col_index, cnf)<br ALIGN="LEFT"/>extend(rowvalues)<br ALIGN="LEFT"/>focus()<br ALIGN="LEFT"/>grid()<br ALIGN="LEFT"/>hide_column(column_index)<br ALIGN="LEFT"/>insert(row_index, rowvalue)<br ALIGN="LEFT"/>itemconfigure(row_index, col_index, cnf)<br ALIGN="LEFT"/>pack()<br ALIGN="LEFT"/>rowconfigure(row_index, cnf)<br ALIGN="LEFT"/>select(index, delta, see)<br ALIGN="LEFT"/>selected_row()<br ALIGN="LEFT"/>show_column(column_index)<br ALIGN="LEFT"/>sort_by(column_index, order)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.inference.tableau.TableauProver" [color="black", fontcolor="black", label=<{TableauProver|<br ALIGN="LEFT"/>|is_atom(e)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.inference.tableau.TableauProverCommand" [color="black", fontcolor="black", label=<{TableauProverCommand|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"nltk.classify.maxent.TadmEventMaxentFeatureEncoding" [color="black", fontcolor="black", label=<{TadmEventMaxentFeatureEncoding|<br ALIGN="LEFT"/>|describe(fid)<br ALIGN="LEFT"/>encode(featureset, label)<br ALIGN="LEFT"/>labels()<br ALIGN="LEFT"/>length()<br ALIGN="LEFT"/>train(train_toks, count_cutoff, labels)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.classify.maxent.TadmMaxentClassifier" [color="black", fontcolor="black", label=<{TadmMaxentClassifier|<br ALIGN="LEFT"/>|train(train_toks)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.tbl.rule.TagRule" [color="black", fontcolor="black", label=<{TagRule|original_tag<br ALIGN="LEFT"/>replacement_tag<br ALIGN="LEFT"/>|<I>applies</I>(tokens, index)<br ALIGN="LEFT"/>apply(tokens, positions)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.corpus.reader.tagged.TaggedCorpusReader" [color="black", fontcolor="black", label=<{TaggedCorpusReader|<br ALIGN="LEFT"/>|paras(fileids)<br ALIGN="LEFT"/>raw(fileids)<br ALIGN="LEFT"/>sents(fileids)<br ALIGN="LEFT"/>tagged_paras(fileids, tagset)<br ALIGN="LEFT"/>tagged_sents(fileids, tagset)<br ALIGN="LEFT"/>tagged_words(fileids, tagset)<br ALIGN="LEFT"/>words(fileids)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.corpus.reader.tagged.TaggedCorpusView" [color="black", fontcolor="black", label=<{TaggedCorpusView|<br ALIGN="LEFT"/>|read_block(stream)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.tag.api.TaggerI" [color="black", fontcolor="black", label=<{TaggerI|<br ALIGN="LEFT"/>|evaluate(gold)<br ALIGN="LEFT"/>tag(tokens)<br ALIGN="LEFT"/>tag_sents(sentences)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.tbl.template.Template" [color="black", fontcolor="black", label=<{Template|ALLTEMPLATES : list<br ALIGN="LEFT"/>id : str<br ALIGN="LEFT"/>|applicable_rules(tokens, index, correct_tag)<br ALIGN="LEFT"/>expand(featurelists, combinations, skipintersecting)<br ALIGN="LEFT"/>get_neighborhood(tokens, index)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.test.unit.test_collocations.TestBigram" [color="black", fontcolor="black", label=<{TestBigram|<br ALIGN="LEFT"/>|test_bigram2()<br ALIGN="LEFT"/>test_bigram3()<br ALIGN="LEFT"/>test_bigram5()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.test.unit.test_corpora.TestCess" [color="black", fontcolor="black", label=<{TestCess|<br ALIGN="LEFT"/>|test_catalan()<br ALIGN="LEFT"/>test_esp()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.test.unit.test_corpora.TestCoNLL2007" [color="black", fontcolor="black", label=<{TestCoNLL2007|<br ALIGN="LEFT"/>|test_parsed_sents()<br ALIGN="LEFT"/>test_sents()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.test.unit.test_corpus_views.TestCorpusViews" [color="black", fontcolor="black", label=<{TestCorpusViews|linetok<br ALIGN="LEFT"/>names : list<br ALIGN="LEFT"/>|data()<br ALIGN="LEFT"/>test_correct_length()<br ALIGN="LEFT"/>test_correct_values()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.test.unit.test_corpora.TestFloresta" [color="black", fontcolor="black", label=<{TestFloresta|<br ALIGN="LEFT"/>|test_words()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.parse.util.TestGrammar" [color="black", fontcolor="black", label=<{TestGrammar|cp<br ALIGN="LEFT"/>suite<br ALIGN="LEFT"/>test_grammar<br ALIGN="LEFT"/>|run(show_trees)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.test.unit.test_corpora.TestIndian" [color="black", fontcolor="black", label=<{TestIndian|<br ALIGN="LEFT"/>|test_tagged_words()<br ALIGN="LEFT"/>test_words()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.test.unit.test_corpora.TestPTB" [color="black", fontcolor="black", label=<{TestPTB|<br ALIGN="LEFT"/>|test_categories()<br ALIGN="LEFT"/>test_category_words()<br ALIGN="LEFT"/>test_fileids()<br ALIGN="LEFT"/>test_news_fileids()<br ALIGN="LEFT"/>test_tagged_words()<br ALIGN="LEFT"/>test_words()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.test.unit.test_corpora.TestSinicaTreebank" [color="black", fontcolor="black", label=<{TestSinicaTreebank|<br ALIGN="LEFT"/>|test_parsed_sents()<br ALIGN="LEFT"/>test_sents()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.test.unit.test_2x_compat.TestTextTransliteration" [color="black", fontcolor="black", label=<{TestTextTransliteration|txt<br ALIGN="LEFT"/>|test_repr()<br ALIGN="LEFT"/>test_str()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.test.unit.test_corpora.TestUdhr" [color="black", fontcolor="black", label=<{TestUdhr|<br ALIGN="LEFT"/>|test_raw_unicode()<br ALIGN="LEFT"/>test_words()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.text.Text" [color="black", fontcolor="black", label=<{Text|name : NoneType, str<br ALIGN="LEFT"/>tokens : list<br ALIGN="LEFT"/>|collocations(num, window_size)<br ALIGN="LEFT"/>common_contexts(words, num)<br ALIGN="LEFT"/>concordance(word, width, lines)<br ALIGN="LEFT"/>count(word)<br ALIGN="LEFT"/>dispersion_plot(words)<br ALIGN="LEFT"/>findall(regexp)<br ALIGN="LEFT"/>index(word)<br ALIGN="LEFT"/>plot()<br ALIGN="LEFT"/><I>readability</I>(method)<br ALIGN="LEFT"/>similar(word, num)<br ALIGN="LEFT"/>vocab()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.text.TextCollection" [color="black", fontcolor="black", label=<{TextCollection|<br ALIGN="LEFT"/>|idf(term, method)<br ALIGN="LEFT"/>tf(term, text, method)<br ALIGN="LEFT"/>tf_idf(term, text)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.tokenize.texttiling.TextTilingTokenizer" [color="black", fontcolor="black", label=<{TextTilingTokenizer|<br ALIGN="LEFT"/>|tokenize(text)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.draw.util.TextWidget" [color="black", fontcolor="black", label=<{TextWidget|<br ALIGN="LEFT"/>|set_text(text)<br ALIGN="LEFT"/>text()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.inference.api.TheoremToolCommand" [color="black", fontcolor="black", label=<{TheoremToolCommand|<br ALIGN="LEFT"/>|<I>add_assumptions</I>(new_assumptions)<br ALIGN="LEFT"/><I>assumptions</I>()<br ALIGN="LEFT"/><I>goal</I>()<br ALIGN="LEFT"/><I>print_assumptions</I>()<br ALIGN="LEFT"/><I>retract_assumptions</I>(retracted, debug)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.inference.api.TheoremToolCommandDecorator" [color="black", fontcolor="black", label=<{TheoremToolCommandDecorator|<br ALIGN="LEFT"/>|add_assumptions(new_assumptions)<br ALIGN="LEFT"/>assumptions()<br ALIGN="LEFT"/>goal()<br ALIGN="LEFT"/>print_assumptions()<br ALIGN="LEFT"/>retract_assumptions(retracted, debug)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.inference.api.TheoremToolThread" [color="black", fontcolor="black", label=<{TheoremToolThread|result<br ALIGN="LEFT"/>|run()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.corpus.reader.timit.TimitCorpusReader" [color="black", fontcolor="black", label=<{TimitCorpusReader|speakers<br ALIGN="LEFT"/>|audiodata(utterance, start, end)<br ALIGN="LEFT"/>fileids(filetype)<br ALIGN="LEFT"/>phone_times(utterances)<br ALIGN="LEFT"/>phone_trees(utterances)<br ALIGN="LEFT"/>phones(utterances)<br ALIGN="LEFT"/>play(utterance, start, end)<br ALIGN="LEFT"/>sent_times(utterances)<br ALIGN="LEFT"/>sentid(utterance)<br ALIGN="LEFT"/>sents(utterances)<br ALIGN="LEFT"/>spkrid(utterance)<br ALIGN="LEFT"/>spkrinfo(speaker)<br ALIGN="LEFT"/>spkrutteranceids(speaker)<br ALIGN="LEFT"/>transcription_dict()<br ALIGN="LEFT"/>utterance(spkrid, sentid)<br ALIGN="LEFT"/>utteranceids(dialect, sex, spkrid, sent_type, sentid)<br ALIGN="LEFT"/>wav(utterance, start, end)<br ALIGN="LEFT"/>word_times(utterances)<br ALIGN="LEFT"/>words(utterances)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.corpus.reader.tagged.TimitTaggedCorpusReader" [color="black", fontcolor="black", label=<{TimitTaggedCorpusReader|<br ALIGN="LEFT"/>|<I>paras</I>()<br ALIGN="LEFT"/><I>tagged_paras</I>()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.compat.TkinterLoader" [color="black", fontcolor="black", label=<{TkinterLoader|module_map : dict<br ALIGN="LEFT"/>|find_module(name, path)<br ALIGN="LEFT"/>load_module(name)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.compat.TkinterPackage" [color="black", fontcolor="black", label=<{TkinterPackage|mod<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"nltk.tag.tnt.TnT" [color="black", fontcolor="black", label=<{TnT|known : int<br ALIGN="LEFT"/>unknown : int<br ALIGN="LEFT"/>|tag(data)<br ALIGN="LEFT"/>tagdata(data)<br ALIGN="LEFT"/>train(data)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.text.TokenSearcher" [color="black", fontcolor="black", label=<{TokenSearcher|<br ALIGN="LEFT"/>|findall(regexp)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.tokenize.texttiling.TokenSequence" [color="black", fontcolor="black", label=<{TokenSequence|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"nltk.tokenize.texttiling.TokenTableField" [color="black", fontcolor="black", label=<{TokenTableField|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"nltk.tokenize.api.TokenizerI" [color="black", fontcolor="black", label=<{TokenizerI|<br ALIGN="LEFT"/>|<I>span_tokenize</I>(s)<br ALIGN="LEFT"/>span_tokenize_sents(strings)<br ALIGN="LEFT"/>tokenize(s)<br ALIGN="LEFT"/>tokenize_sents(strings)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.sem.linearlogic.Tokens" [color="black", fontcolor="black", label=<{Tokens|CLOSE : str<br ALIGN="LEFT"/>IMP : str<br ALIGN="LEFT"/>OPEN : str<br ALIGN="LEFT"/>PUNCT : list<br ALIGN="LEFT"/>TOKENS : list<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"nltk.sem.logic.Tokens" [color="black", fontcolor="black", label=<{Tokens|ALL : str<br ALIGN="LEFT"/>ALL_LIST : list<br ALIGN="LEFT"/>AND : str<br ALIGN="LEFT"/>AND_LIST : list<br ALIGN="LEFT"/>BINOPS : list<br ALIGN="LEFT"/>CLOSE : str<br ALIGN="LEFT"/>COMMA : str<br ALIGN="LEFT"/>DOT : str<br ALIGN="LEFT"/>EQ : str<br ALIGN="LEFT"/>EQ_LIST : list<br ALIGN="LEFT"/>EXISTS : str<br ALIGN="LEFT"/>EXISTS_LIST : list<br ALIGN="LEFT"/>IFF : str<br ALIGN="LEFT"/>IFF_LIST : list<br ALIGN="LEFT"/>IMP : str<br ALIGN="LEFT"/>IMP_LIST : list<br ALIGN="LEFT"/>LAMBDA : str<br ALIGN="LEFT"/>LAMBDA_LIST : list<br ALIGN="LEFT"/>NEQ : str<br ALIGN="LEFT"/>NEQ_LIST : list<br ALIGN="LEFT"/>NOT : str<br ALIGN="LEFT"/>NOT_LIST : list<br ALIGN="LEFT"/>OPEN : str<br ALIGN="LEFT"/>OR : str<br ALIGN="LEFT"/>OR_LIST : list<br ALIGN="LEFT"/>PUNCT : list<br ALIGN="LEFT"/>QUANTS : list<br ALIGN="LEFT"/>SYMBOLS<br ALIGN="LEFT"/>TOKENS<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"nltk.corpus.reader.toolbox.ToolboxCorpusReader" [color="black", fontcolor="black", label=<{ToolboxCorpusReader|<br ALIGN="LEFT"/>|entries(fileids)<br ALIGN="LEFT"/>fields(fileids, strip, unwrap, encoding, errors, unicode_fields)<br ALIGN="LEFT"/>raw(fileids)<br ALIGN="LEFT"/>words(fileids, key)<br ALIGN="LEFT"/>xml(fileids, key)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.toolbox.ToolboxData" [color="black", fontcolor="black", label=<{ToolboxData|<br ALIGN="LEFT"/>|parse(grammar)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.toolbox.ToolboxSettings" [color="black", fontcolor="black", label=<{ToolboxSettings|<br ALIGN="LEFT"/>|parse(encoding, errors)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.parse.chart.TopDownChartParser" [color="black", fontcolor="black", label=<{TopDownChartParser|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"nltk.parse.chart.TopDownInitRule" [color="black", fontcolor="black", label=<{TopDownInitRule|NUM_EDGES : int<br ALIGN="LEFT"/>|apply(chart, grammar)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.app.chartparser_app.TopDownPredictEdgeRule" [color="black", fontcolor="black", label=<{TopDownPredictEdgeRule|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"nltk.parse.chart.TopDownPredictRule" [color="black", fontcolor="black", label=<{TopDownPredictRule|NUM_EDGES : int<br ALIGN="LEFT"/>|apply(chart, grammar, edge)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.parse.transitionparser.Transition" [color="black", fontcolor="black", label=<{Transition|LEFT_ARC : str<br ALIGN="LEFT"/>REDUCE : str<br ALIGN="LEFT"/>RIGHT_ARC : str<br ALIGN="LEFT"/>SHIFT : str<br ALIGN="LEFT"/>|left_arc(conf, relation)<br ALIGN="LEFT"/>reduce(conf)<br ALIGN="LEFT"/>right_arc(conf, relation)<br ALIGN="LEFT"/>shift(conf)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.parse.transitionparser.TransitionParser" [color="black", fontcolor="black", label=<{TransitionParser|ARC_EAGER : str<br ALIGN="LEFT"/>ARC_STANDARD : str<br ALIGN="LEFT"/>|parse(depgraphs, modelFile)<br ALIGN="LEFT"/>train(depgraphs, modelfile)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.tree.Tree" [color="black", fontcolor="black", label=<{Tree|node<br ALIGN="LEFT"/>|chomsky_normal_form(factor, horzMarkov, vertMarkov, childChar, parentChar)<br ALIGN="LEFT"/>collapse_unary(collapsePOS, collapseRoot, joinChar)<br ALIGN="LEFT"/>convert(tree)<br ALIGN="LEFT"/>copy(deep)<br ALIGN="LEFT"/>draw()<br ALIGN="LEFT"/>flatten()<br ALIGN="LEFT"/>freeze(leaf_freezer)<br ALIGN="LEFT"/>fromstring(s, brackets, read_node, read_leaf, node_pattern, leaf_pattern, remove_empty_top_bracketing)<br ALIGN="LEFT"/>height()<br ALIGN="LEFT"/>label()<br ALIGN="LEFT"/>leaf_treeposition(index)<br ALIGN="LEFT"/>leaves()<br ALIGN="LEFT"/>pformat(margin, indent, nodesep, parens, quotes)<br ALIGN="LEFT"/>pformat_latex_qtree()<br ALIGN="LEFT"/>pos()<br ALIGN="LEFT"/>pprint()<br ALIGN="LEFT"/>pretty_print(sentence, highlight, stream)<br ALIGN="LEFT"/>productions()<br ALIGN="LEFT"/>set_label(label)<br ALIGN="LEFT"/>subtrees(filter)<br ALIGN="LEFT"/>treeposition_spanning_leaves(start, end)<br ALIGN="LEFT"/>treepositions(order)<br ALIGN="LEFT"/>un_chomsky_normal_form(expandUnary, childChar, parentChar, unaryChar)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.parse.chart.TreeEdge" [color="black", fontcolor="black", label=<{TreeEdge|<br ALIGN="LEFT"/>|dot()<br ALIGN="LEFT"/>end()<br ALIGN="LEFT"/>from_production(production, index)<br ALIGN="LEFT"/>is_complete()<br ALIGN="LEFT"/>is_incomplete()<br ALIGN="LEFT"/>length()<br ALIGN="LEFT"/>lhs()<br ALIGN="LEFT"/>move_dot_forward(new_end)<br ALIGN="LEFT"/>nextsym()<br ALIGN="LEFT"/>rhs()<br ALIGN="LEFT"/>span()<br ALIGN="LEFT"/>start()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.treeprettyprinter.TreePrettyPrinter" [color="black", fontcolor="black", label=<{TreePrettyPrinter|coords : dict<br ALIGN="LEFT"/>edges<br ALIGN="LEFT"/>highlight : set<br ALIGN="LEFT"/>nodes : dict<br ALIGN="LEFT"/>|nodecoords(tree, sentence, highlight)<br ALIGN="LEFT"/>svg(nodecolor, leafcolor, funccolor)<br ALIGN="LEFT"/>text(nodedist, unicodelines, html, ansi, nodecolor, leafcolor, funccolor, abbreviate, maxwidth)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.draw.tree.TreeSegmentWidget" [color="black", fontcolor="black", label=<{TreeSegmentWidget|<br ALIGN="LEFT"/>|insert_child(index, child)<br ALIGN="LEFT"/>label()<br ALIGN="LEFT"/>remove_child(child)<br ALIGN="LEFT"/>replace_child(oldchild, newchild)<br ALIGN="LEFT"/>set_label(label)<br ALIGN="LEFT"/>subtrees()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.draw.tree.TreeView" [color="black", fontcolor="black", label=<{TreeView|<br ALIGN="LEFT"/>|destroy()<br ALIGN="LEFT"/>mainloop()<br ALIGN="LEFT"/>resize()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.draw.tree.TreeWidget" [color="black", fontcolor="black", label=<{TreeWidget|<br ALIGN="LEFT"/>|bind_click_leaves(callback, button)<br ALIGN="LEFT"/>bind_click_nodes(callback, button)<br ALIGN="LEFT"/>bind_click_trees(callback, button)<br ALIGN="LEFT"/>bind_drag_leaves(callback, button)<br ALIGN="LEFT"/>bind_drag_nodes(callback, button)<br ALIGN="LEFT"/>bind_drag_trees(callback, button)<br ALIGN="LEFT"/>collapsed_tree()<br ALIGN="LEFT"/>expanded_tree()<br ALIGN="LEFT"/>toggle_collapsed(treeseg)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.tokenize.treebank.TreebankWordTokenizer" [color="black", fontcolor="black", label=<{TreebankWordTokenizer|CONTRACTIONS2 : list<br ALIGN="LEFT"/>CONTRACTIONS3 : list<br ALIGN="LEFT"/>CONTRACTIONS4 : list<br ALIGN="LEFT"/>|tokenize(text)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.metrics.association.TrigramAssocMeasures" [color="black", fontcolor="black", label=<{TrigramAssocMeasures|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"nltk.collocations.TrigramCollocationFinder" [color="black", fontcolor="black", label=<{TrigramCollocationFinder|bigram_fd<br ALIGN="LEFT"/>wildcard_fd<br ALIGN="LEFT"/>|bigram_finder()<br ALIGN="LEFT"/>from_words(words, window_size)<br ALIGN="LEFT"/>score_ngram(score_fn, w1, w2, w3)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.tag.sequential.TrigramTagger" [color="black", fontcolor="black", label=<{TrigramTagger|json_tag : str<br ALIGN="LEFT"/>|decode_json_obj(obj)<br ALIGN="LEFT"/>encode_json_obj()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.sem.logic.TruthValueType" [color="black", fontcolor="black", label=<{TruthValueType|<br ALIGN="LEFT"/>|str()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.sem.logic.Type" [color="black", fontcolor="black", label=<{Type|<br ALIGN="LEFT"/>|fromstring(s)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.sem.logic.TypeException" [color="black", fontcolor="red", label=<{TypeException|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"nltk.sem.logic.TypeResolutionException" [color="black", fontcolor="red", label=<{TypeResolutionException|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"nltk.classify.maxent.TypedMaxentFeatureEncoding" [color="black", fontcolor="black", label=<{TypedMaxentFeatureEncoding|<br ALIGN="LEFT"/>|describe(f_id)<br ALIGN="LEFT"/>encode(featureset, label)<br ALIGN="LEFT"/>labels()<br ALIGN="LEFT"/>length()<br ALIGN="LEFT"/>train(train_toks, count_cutoff, labels)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.corpus.reader.udhr.UdhrCorpusReader" [color="black", fontcolor="black", label=<{UdhrCorpusReader|ENCODINGS : list<br ALIGN="LEFT"/>SKIP : set<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"nltk.chunk.regexp.UnChunkRule" [color="black", fontcolor="black", label=<{UnChunkRule|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"nltk.sem.evaluate.Undefined" [color="black", fontcolor="red", label=<{Undefined|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"nltk.ccg.combinator.UndirectedBinaryCombinator" [color="black", fontcolor="black", label=<{UndirectedBinaryCombinator|<br ALIGN="LEFT"/>|<I>can_combine</I>(function, argument)<br ALIGN="LEFT"/><I>combine</I>(function, argument)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.ccg.combinator.UndirectedComposition" [color="black", fontcolor="black", label=<{UndirectedComposition|<br ALIGN="LEFT"/>|can_combine(function, argument)<br ALIGN="LEFT"/>combine(function, argument)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.ccg.combinator.UndirectedFunctionApplication" [color="black", fontcolor="black", label=<{UndirectedFunctionApplication|<br ALIGN="LEFT"/>|can_combine(function, argument)<br ALIGN="LEFT"/>combine(function, argument)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.ccg.combinator.UndirectedSubstitution" [color="black", fontcolor="black", label=<{UndirectedSubstitution|<br ALIGN="LEFT"/>|can_combine(function, argument)<br ALIGN="LEFT"/>combine(function, argument)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.ccg.combinator.UndirectedTypeRaise" [color="black", fontcolor="black", label=<{UndirectedTypeRaise|<br ALIGN="LEFT"/>|can_combine(function, arg)<br ALIGN="LEFT"/>combine(function, arg)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.sem.logic.UnexpectedTokenException" [color="black", fontcolor="red", label=<{UnexpectedTokenException|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"nltk.inference.resolution.UnificationException" [color="black", fontcolor="red", label=<{UnificationException|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"nltk.sem.linearlogic.UnificationException" [color="black", fontcolor="red", label=<{UnificationException|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"nltk.probability.UniformProbDist" [color="black", fontcolor="black", label=<{UniformProbDist|<br ALIGN="LEFT"/>|max()<br ALIGN="LEFT"/>prob(sample)<br ALIGN="LEFT"/>samples()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.tag.sequential.UnigramTagger" [color="black", fontcolor="black", label=<{UnigramTagger|json_tag : str<br ALIGN="LEFT"/>|context(tokens, index, history)<br ALIGN="LEFT"/>decode_json_obj(obj)<br ALIGN="LEFT"/>encode_json_obj()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.inference.nonmonotonic.UniqueNamesProver" [color="black", fontcolor="black", label=<{UniqueNamesProver|<br ALIGN="LEFT"/>|assumptions()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.sem.boxer.UnparseableInputException" [color="black", fontcolor="red", label=<{UnparseableInputException|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"nltk.parse.pchart.UnsortedChartParser" [color="black", fontcolor="black", label=<{UnsortedChartParser|<br ALIGN="LEFT"/>|sort_queue(queue, chart)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.downloader.UpToDateMessage" [color="black", fontcolor="black", label=<{UpToDateMessage|package<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"nltk.sem.evaluate.Valuation" [color="black", fontcolor="black", label=<{Valuation|domain<br ALIGN="LEFT"/>symbols<br ALIGN="LEFT"/>|fromstring(s)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.sem.logic.Variable" [color="black", fontcolor="black", label=<{Variable|name<br ALIGN="LEFT"/>|substitute_bindings(bindings)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.sem.logic.VariableBinderExpression" [color="black", fontcolor="black", label=<{VariableBinderExpression|term<br ALIGN="LEFT"/>variable<br ALIGN="LEFT"/>|alpha_convert(newvar)<br ALIGN="LEFT"/>findtype(variable)<br ALIGN="LEFT"/>free()<br ALIGN="LEFT"/>replace(variable, expression, replace_bound, alpha_convert)<br ALIGN="LEFT"/>visit(function, combinator)<br ALIGN="LEFT"/>visit_structured(function, combinator)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.sem.linearlogic.VariableBindingException" [color="black", fontcolor="red", label=<{VariableBindingException|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"nltk.sem.linearlogic.VariableExpression" [color="black", fontcolor="black", label=<{VariableExpression|<br ALIGN="LEFT"/>|unify(other, bindings)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.cluster.util.VectorSpaceClusterer" [color="black", fontcolor="black", label=<{VectorSpaceClusterer|<br ALIGN="LEFT"/>|classify(vector)<br ALIGN="LEFT"/><I>classify_vectorspace</I>(vector)<br ALIGN="LEFT"/>cluster(vectors, assign_clusters, trace)<br ALIGN="LEFT"/><I>cluster_vectorspace</I>(vectors, trace)<br ALIGN="LEFT"/>likelihood(vector, label)<br ALIGN="LEFT"/>likelihood_vectorspace(vector, cluster)<br ALIGN="LEFT"/>vector(vector)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.corpus.reader.verbnet.VerbnetCorpusReader" [color="black", fontcolor="black", label=<{VerbnetCorpusReader|<br ALIGN="LEFT"/>|classids(lemma, wordnetid, fileid, classid)<br ALIGN="LEFT"/>fileids(vnclass_ids)<br ALIGN="LEFT"/>lemmas(classid)<br ALIGN="LEFT"/>longid(shortid)<br ALIGN="LEFT"/>pprint(vnclass)<br ALIGN="LEFT"/>pprint_description(vnframe, indent)<br ALIGN="LEFT"/>pprint_frame(vnframe, indent)<br ALIGN="LEFT"/>pprint_members(vnclass, indent)<br ALIGN="LEFT"/>pprint_semantics(vnframe, indent)<br ALIGN="LEFT"/>pprint_subclasses(vnclass, indent)<br ALIGN="LEFT"/>pprint_syntax(vnframe, indent)<br ALIGN="LEFT"/>pprint_themroles(vnclass, indent)<br ALIGN="LEFT"/>shortid(longid)<br ALIGN="LEFT"/>vnclass(fileid_or_classid)<br ALIGN="LEFT"/>wordnetids(classid)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.parse.viterbi.ViterbiParser" [color="black", fontcolor="black", label=<{ViterbiParser|<br ALIGN="LEFT"/>|grammar()<br ALIGN="LEFT"/>parse(tokens)<br ALIGN="LEFT"/>trace(trace)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.classify.weka.WekaClassifier" [color="black", fontcolor="black", label=<{WekaClassifier|<br ALIGN="LEFT"/>|classify_many(featuresets)<br ALIGN="LEFT"/>parse_weka_distribution(s)<br ALIGN="LEFT"/>parse_weka_output(lines)<br ALIGN="LEFT"/>prob_classify_many(featuresets)<br ALIGN="LEFT"/>train(model_filename, featuresets, classifier, options, quiet)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.tokenize.regexp.WhitespaceTokenizer" [color="black", fontcolor="black", label=<{WhitespaceTokenizer|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"nltk.probability.WittenBellProbDist" [color="black", fontcolor="black", label=<{WittenBellProbDist|<br ALIGN="LEFT"/>|<I>discount</I>()<br ALIGN="LEFT"/>freqdist()<br ALIGN="LEFT"/>max()<br ALIGN="LEFT"/>prob(sample)<br ALIGN="LEFT"/>samples()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.tag.brill.Word" [color="black", fontcolor="black", label=<{Word|json_tag : str<br ALIGN="LEFT"/>|extract_property(tokens, index)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.corpus.reader.wordlist.WordListCorpusReader" [color="black", fontcolor="black", label=<{WordListCorpusReader|<br ALIGN="LEFT"/>|raw(fileids)<br ALIGN="LEFT"/>words(fileids)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.corpus.reader.wordnet.WordNetCorpusReader" [color="black", fontcolor="black", label=<{WordNetCorpusReader|ADJ : str<br ALIGN="LEFT"/>ADJ_SAT : str<br ALIGN="LEFT"/>ADV : str<br ALIGN="LEFT"/>MORPHOLOGICAL_SUBSTITUTIONS : dict<br ALIGN="LEFT"/>NOUN : str<br ALIGN="LEFT"/>VERB : str<br ALIGN="LEFT"/>|all_lemma_names(pos, lang)<br ALIGN="LEFT"/>all_synsets(pos)<br ALIGN="LEFT"/>get_version()<br ALIGN="LEFT"/>ic(corpus, weight_senses_equally, smoothing)<br ALIGN="LEFT"/>jcn_similarity(synset1, synset2, ic, verbose)<br ALIGN="LEFT"/>langs()<br ALIGN="LEFT"/>lch_similarity(synset1, synset2, verbose, simulate_root)<br ALIGN="LEFT"/>lemma(name, lang)<br ALIGN="LEFT"/>lemma_count(lemma)<br ALIGN="LEFT"/>lemma_from_key(key)<br ALIGN="LEFT"/>lemmas(lemma, pos, lang)<br ALIGN="LEFT"/>lin_similarity(synset1, synset2, ic, verbose)<br ALIGN="LEFT"/>morphy(form, pos)<br ALIGN="LEFT"/>of2ss(of)<br ALIGN="LEFT"/>path_similarity(synset1, synset2, verbose, simulate_root)<br ALIGN="LEFT"/>res_similarity(synset1, synset2, ic, verbose)<br ALIGN="LEFT"/>ss2of(ss)<br ALIGN="LEFT"/>synset(name)<br ALIGN="LEFT"/>synsets(lemma, pos, lang)<br ALIGN="LEFT"/>wup_similarity(synset1, synset2, verbose, simulate_root)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.corpus.reader.wordnet.WordNetError" [color="black", fontcolor="red", label=<{WordNetError|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"nltk.corpus.reader.wordnet.WordNetICCorpusReader" [color="black", fontcolor="black", label=<{WordNetICCorpusReader|<br ALIGN="LEFT"/>|ic(icfile)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.stem.wordnet.WordNetLemmatizer" [color="black", fontcolor="black", label=<{WordNetLemmatizer|<br ALIGN="LEFT"/>|lemmatize(word, pos)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.tokenize.regexp.WordPunctTokenizer" [color="black", fontcolor="black", label=<{WordPunctTokenizer|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"nltk.corpus.reader.xmldocs.XMLCorpusReader" [color="black", fontcolor="black", label=<{XMLCorpusReader|<br ALIGN="LEFT"/>|raw(fileids)<br ALIGN="LEFT"/>words(fileid)<br ALIGN="LEFT"/>xml(fileid)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.corpus.reader.xmldocs.XMLCorpusView" [color="black", fontcolor="black", label=<{XMLCorpusView|handle_elt : NoneType<br ALIGN="LEFT"/>|handle_elt(elt, context)<br ALIGN="LEFT"/>read_block(stream, tagspec, elt_handler)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.corpus.reader.nkjp.XML_Tool" [color="black", fontcolor="black", label=<{XML_Tool|read_file<br ALIGN="LEFT"/>write_file : _TemporaryFileWrapper<br ALIGN="LEFT"/>|build_preprocessed_file()<br ALIGN="LEFT"/>remove_preprocessed_file()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.corpus.reader.ycoe.YCOECorpusReader" [color="black", fontcolor="black", label=<{YCOECorpusReader|<br ALIGN="LEFT"/>|documents(fileids)<br ALIGN="LEFT"/>fileids(documents)<br ALIGN="LEFT"/>paras(documents)<br ALIGN="LEFT"/>parsed_sents(documents)<br ALIGN="LEFT"/>sents(documents)<br ALIGN="LEFT"/>tagged_paras(documents)<br ALIGN="LEFT"/>tagged_sents(documents)<br ALIGN="LEFT"/>tagged_words(documents)<br ALIGN="LEFT"/>words(documents)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.corpus.reader.ycoe.YCOEParseCorpusReader" [color="black", fontcolor="black", label=<{YCOEParseCorpusReader|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"nltk.corpus.reader.ycoe.YCOETaggedCorpusReader" [color="black", fontcolor="black", label=<{YCOETaggedCorpusReader|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"nltk.data.ZipFilePathPointer" [color="black", fontcolor="black", label=<{ZipFilePathPointer|entry<br ALIGN="LEFT"/>zipfile<br ALIGN="LEFT"/>|file_size()<br ALIGN="LEFT"/>join(fileid)<br ALIGN="LEFT"/>open(encoding)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.app.nemo_app.Zone" [color="black", fontcolor="black", label=<{Zone|colorCycle : cycle<br ALIGN="LEFT"/>fld : Text<br ALIGN="LEFT"/>image : PhotoImage<br ALIGN="LEFT"/>imageDimmed : PhotoImage<br ALIGN="LEFT"/>img : Label<br ALIGN="LEFT"/>txt : Text<br ALIGN="LEFT"/>|initScrollText(frm, txt, contents)<br ALIGN="LEFT"/>refresh()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.cluster.util._DendrogramNode" [color="black", fontcolor="black", label=<{_DendrogramNode|<br ALIGN="LEFT"/>|groups(n)<br ALIGN="LEFT"/>leaves(values)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.downloader.DownloaderGUI._DownloadThread" [color="black", fontcolor="black", label=<{_DownloadThread|abort<br ALIGN="LEFT"/>data_server<br ALIGN="LEFT"/>items<br ALIGN="LEFT"/>lock<br ALIGN="LEFT"/>message_queue<br ALIGN="LEFT"/>|run()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.stem.snowball._LanguageSpecificStemmer" [color="black", fontcolor="black", label=<{_LanguageSpecificStemmer|stopwords : set<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"nltk.stem.snowball._ScandinavianStemmer" [color="black", fontcolor="black", label=<{_ScandinavianStemmer|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"nltk.stem.snowball._StandardStemmer" [color="black", fontcolor="black", label=<{_StandardStemmer|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"nltk.test.doctest_nose_plugin._UnicodeOutputChecker" [color="black", fontcolor="black", label=<{_UnicodeOutputChecker|<br ALIGN="LEFT"/>|check_output(want, got, optionflags)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.featstruct._UnificationFailure" [color="black", fontcolor="black", label=<{_UnificationFailure|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"nltk.featstruct._UnificationFailureError" [color="black", fontcolor="red", label=<{_UnificationFailureError|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"nltk.corpus.reader.wordnet._WordNetObject" [color="black", fontcolor="black", label=<{_WordNetObject|<br ALIGN="LEFT"/>|also_sees()<br ALIGN="LEFT"/>attributes()<br ALIGN="LEFT"/>causes()<br ALIGN="LEFT"/>entailments()<br ALIGN="LEFT"/>hypernyms()<br ALIGN="LEFT"/>hyponyms()<br ALIGN="LEFT"/>instance_hypernyms()<br ALIGN="LEFT"/>instance_hyponyms()<br ALIGN="LEFT"/>member_holonyms()<br ALIGN="LEFT"/>member_meronyms()<br ALIGN="LEFT"/>part_holonyms()<br ALIGN="LEFT"/>part_meronyms()<br ALIGN="LEFT"/>region_domains()<br ALIGN="LEFT"/>similar_tos()<br ALIGN="LEFT"/>substance_holonyms()<br ALIGN="LEFT"/>substance_meronyms()<br ALIGN="LEFT"/>topic_domains()<br ALIGN="LEFT"/>usage_domains()<br ALIGN="LEFT"/>verb_groups()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"nltk.app.chartparser_app.BottomUpEdgeRule" -> "nltk.app.chartparser_app.EdgeRule" [arrowhead="empty", arrowtail="none"];
"nltk.app.chartparser_app.BottomUpEdgeRule" -> "nltk.parse.chart.BottomUpPredictRule" [arrowhead="empty", arrowtail="none"];
"nltk.app.chartparser_app.BottomUpLeftCornerEdgeRule" -> "nltk.app.chartparser_app.EdgeRule" [arrowhead="empty", arrowtail="none"];
"nltk.app.chartparser_app.BottomUpLeftCornerEdgeRule" -> "nltk.parse.chart.BottomUpPredictCombineRule" [arrowhead="empty", arrowtail="none"];
"nltk.app.chartparser_app.EdgeList" -> "nltk.draw.util.ColorizedList" [arrowhead="empty", arrowtail="none"];
"nltk.app.chartparser_app.FundamentalEdgeRule" -> "nltk.app.chartparser_app.EdgeRule" [arrowhead="empty", arrowtail="none"];
"nltk.app.chartparser_app.FundamentalEdgeRule" -> "nltk.parse.chart.SingleEdgeFundamentalRule" [arrowhead="empty", arrowtail="none"];
"nltk.app.chartparser_app.TopDownPredictEdgeRule" -> "nltk.app.chartparser_app.EdgeRule" [arrowhead="empty", arrowtail="none"];
"nltk.app.chartparser_app.TopDownPredictEdgeRule" -> "nltk.parse.chart.TopDownPredictRule" [arrowhead="empty", arrowtail="none"];
"nltk.app.nemo_app.FindZone" -> "nltk.app.nemo_app.Zone" [arrowhead="empty", arrowtail="none"];
"nltk.app.nemo_app.ReplaceZone" -> "nltk.app.nemo_app.Zone" [arrowhead="empty", arrowtail="none"];
"nltk.ccg.api.CCGVar" -> "nltk.ccg.api.AbstractCCGCategory" [arrowhead="empty", arrowtail="none"];
"nltk.ccg.api.FunctionalCategory" -> "nltk.ccg.api.AbstractCCGCategory" [arrowhead="empty", arrowtail="none"];
"nltk.ccg.api.PrimitiveCategory" -> "nltk.ccg.api.AbstractCCGCategory" [arrowhead="empty", arrowtail="none"];
"nltk.ccg.chart.BackwardTypeRaiseRule" -> "nltk.parse.chart.AbstractChartRule" [arrowhead="empty", arrowtail="none"];
"nltk.ccg.chart.BinaryCombinatorRule" -> "nltk.parse.chart.AbstractChartRule" [arrowhead="empty", arrowtail="none"];
"nltk.ccg.chart.CCGChart" -> "nltk.parse.chart.Chart" [arrowhead="empty", arrowtail="none"];
"nltk.ccg.chart.CCGChartParser" -> "nltk.parse.api.ParserI" [arrowhead="empty", arrowtail="none"];
"nltk.ccg.chart.CCGEdge" -> "nltk.parse.chart.EdgeI" [arrowhead="empty", arrowtail="none"];
"nltk.ccg.chart.CCGLeafEdge" -> "nltk.parse.chart.EdgeI" [arrowhead="empty", arrowtail="none"];
"nltk.ccg.chart.ForwardTypeRaiseRule" -> "nltk.parse.chart.AbstractChartRule" [arrowhead="empty", arrowtail="none"];
"nltk.ccg.combinator.BackwardCombinator" -> "nltk.ccg.combinator.DirectedBinaryCombinator" [arrowhead="empty", arrowtail="none"];
"nltk.ccg.combinator.ForwardCombinator" -> "nltk.ccg.combinator.DirectedBinaryCombinator" [arrowhead="empty", arrowtail="none"];
"nltk.ccg.combinator.UndirectedComposition" -> "nltk.ccg.combinator.UndirectedBinaryCombinator" [arrowhead="empty", arrowtail="none"];
"nltk.ccg.combinator.UndirectedFunctionApplication" -> "nltk.ccg.combinator.UndirectedBinaryCombinator" [arrowhead="empty", arrowtail="none"];
"nltk.ccg.combinator.UndirectedSubstitution" -> "nltk.ccg.combinator.UndirectedBinaryCombinator" [arrowhead="empty", arrowtail="none"];
"nltk.ccg.combinator.UndirectedTypeRaise" -> "nltk.ccg.combinator.UndirectedBinaryCombinator" [arrowhead="empty", arrowtail="none"];
"nltk.chunk.api.ChunkParserI" -> "nltk.parse.api.ParserI" [arrowhead="empty", arrowtail="none"];
"nltk.chunk.named_entity.NEChunkParser" -> "nltk.chunk.api.ChunkParserI" [arrowhead="empty", arrowtail="none"];
"nltk.chunk.named_entity.NEChunkParserTagger" -> "nltk.tag.sequential.ClassifierBasedTagger" [arrowhead="empty", arrowtail="none"];
"nltk.chunk.regexp.ChinkRule" -> "nltk.chunk.regexp.RegexpChunkRule" [arrowhead="empty", arrowtail="none"];
"nltk.chunk.regexp.ChunkRule" -> "nltk.chunk.regexp.RegexpChunkRule" [arrowhead="empty", arrowtail="none"];
"nltk.chunk.regexp.ChunkRuleWithContext" -> "nltk.chunk.regexp.RegexpChunkRule" [arrowhead="empty", arrowtail="none"];
"nltk.chunk.regexp.ExpandLeftRule" -> "nltk.chunk.regexp.RegexpChunkRule" [arrowhead="empty", arrowtail="none"];
"nltk.chunk.regexp.ExpandRightRule" -> "nltk.chunk.regexp.RegexpChunkRule" [arrowhead="empty", arrowtail="none"];
"nltk.chunk.regexp.MergeRule" -> "nltk.chunk.regexp.RegexpChunkRule" [arrowhead="empty", arrowtail="none"];
"nltk.chunk.regexp.RegexpChunkParser" -> "nltk.chunk.api.ChunkParserI" [arrowhead="empty", arrowtail="none"];
"nltk.chunk.regexp.RegexpParser" -> "nltk.chunk.api.ChunkParserI" [arrowhead="empty", arrowtail="none"];
"nltk.chunk.regexp.SplitRule" -> "nltk.chunk.regexp.RegexpChunkRule" [arrowhead="empty", arrowtail="none"];
"nltk.chunk.regexp.UnChunkRule" -> "nltk.chunk.regexp.RegexpChunkRule" [arrowhead="empty", arrowtail="none"];
"nltk.classify.decisiontree.DecisionTreeClassifier" -> "nltk.classify.api.ClassifierI" [arrowhead="empty", arrowtail="none"];
"nltk.classify.maxent.BinaryMaxentFeatureEncoding" -> "nltk.classify.maxent.MaxentFeatureEncodingI" [arrowhead="empty", arrowtail="none"];
"nltk.classify.maxent.FunctionBackedMaxentFeatureEncoding" -> "nltk.classify.maxent.MaxentFeatureEncodingI" [arrowhead="empty", arrowtail="none"];
"nltk.classify.maxent.GISEncoding" -> "nltk.classify.maxent.BinaryMaxentFeatureEncoding" [arrowhead="empty", arrowtail="none"];
"nltk.classify.maxent.MaxentClassifier" -> "nltk.classify.api.ClassifierI" [arrowhead="empty", arrowtail="none"];
"nltk.classify.maxent.TadmEventMaxentFeatureEncoding" -> "nltk.classify.maxent.BinaryMaxentFeatureEncoding" [arrowhead="empty", arrowtail="none"];
"nltk.classify.maxent.TadmMaxentClassifier" -> "nltk.classify.maxent.MaxentClassifier" [arrowhead="empty", arrowtail="none"];
"nltk.classify.maxent.TypedMaxentFeatureEncoding" -> "nltk.classify.maxent.MaxentFeatureEncodingI" [arrowhead="empty", arrowtail="none"];
"nltk.classify.naivebayes.NaiveBayesClassifier" -> "nltk.classify.api.ClassifierI" [arrowhead="empty", arrowtail="none"];
"nltk.classify.positivenaivebayes.PositiveNaiveBayesClassifier" -> "nltk.classify.naivebayes.NaiveBayesClassifier" [arrowhead="empty", arrowtail="none"];
"nltk.classify.scikitlearn.SklearnClassifier" -> "nltk.classify.api.ClassifierI" [arrowhead="empty", arrowtail="none"];
"nltk.classify.senna.Senna" -> "nltk.tag.api.TaggerI" [arrowhead="empty", arrowtail="none"];
"nltk.classify.weka.WekaClassifier" -> "nltk.classify.api.ClassifierI" [arrowhead="empty", arrowtail="none"];
"nltk.cluster.em.EMClusterer" -> "nltk.cluster.util.VectorSpaceClusterer" [arrowhead="empty", arrowtail="none"];
"nltk.cluster.gaac.GAAClusterer" -> "nltk.cluster.util.VectorSpaceClusterer" [arrowhead="empty", arrowtail="none"];
"nltk.cluster.kmeans.KMeansClusterer" -> "nltk.cluster.util.VectorSpaceClusterer" [arrowhead="empty", arrowtail="none"];
"nltk.cluster.util.VectorSpaceClusterer" -> "nltk.cluster.api.ClusterI" [arrowhead="empty", arrowtail="none"];
"nltk.collocations.BigramCollocationFinder" -> "nltk.collocations.AbstractCollocationFinder" [arrowhead="empty", arrowtail="none"];
"nltk.collocations.QuadgramCollocationFinder" -> "nltk.collocations.AbstractCollocationFinder" [arrowhead="empty", arrowtail="none"];
"nltk.collocations.TrigramCollocationFinder" -> "nltk.collocations.AbstractCollocationFinder" [arrowhead="empty", arrowtail="none"];
"nltk.corpus.reader.aligned.AlignedCorpusReader" -> "nltk.corpus.reader.api.CorpusReader" [arrowhead="empty", arrowtail="none"];
"nltk.corpus.reader.aligned.AlignedSentCorpusView" -> "nltk.corpus.reader.util.StreamBackedCorpusView" [arrowhead="empty", arrowtail="none"];
"nltk.corpus.reader.api.SyntaxCorpusReader" -> "nltk.corpus.reader.api.CorpusReader" [arrowhead="empty", arrowtail="none"];
"nltk.corpus.reader.bnc.BNCCorpusReader" -> "nltk.corpus.reader.xmldocs.XMLCorpusReader" [arrowhead="empty", arrowtail="none"];
"nltk.corpus.reader.bnc.BNCWordView" -> "nltk.corpus.reader.xmldocs.XMLCorpusView" [arrowhead="empty", arrowtail="none"];
"nltk.corpus.reader.bracket_parse.AlpinoCorpusReader" -> "nltk.corpus.reader.bracket_parse.BracketParseCorpusReader" [arrowhead="empty", arrowtail="none"];
"nltk.corpus.reader.bracket_parse.BracketParseCorpusReader" -> "nltk.corpus.reader.api.SyntaxCorpusReader" [arrowhead="empty", arrowtail="none"];
"nltk.corpus.reader.bracket_parse.CategorizedBracketParseCorpusReader" -> "nltk.corpus.reader.api.CategorizedCorpusReader" [arrowhead="empty", arrowtail="none"];
"nltk.corpus.reader.bracket_parse.CategorizedBracketParseCorpusReader" -> "nltk.corpus.reader.bracket_parse.BracketParseCorpusReader" [arrowhead="empty", arrowtail="none"];
"nltk.corpus.reader.chasen.ChasenCorpusReader" -> "nltk.corpus.reader.api.CorpusReader" [arrowhead="empty", arrowtail="none"];
"nltk.corpus.reader.chasen.ChasenCorpusView" -> "nltk.corpus.reader.util.StreamBackedCorpusView" [arrowhead="empty", arrowtail="none"];
"nltk.corpus.reader.childes.CHILDESCorpusReader" -> "nltk.corpus.reader.xmldocs.XMLCorpusReader" [arrowhead="empty", arrowtail="none"];
"nltk.corpus.reader.chunked.ChunkedCorpusReader" -> "nltk.corpus.reader.api.CorpusReader" [arrowhead="empty", arrowtail="none"];
"nltk.corpus.reader.chunked.ChunkedCorpusView" -> "nltk.corpus.reader.util.StreamBackedCorpusView" [arrowhead="empty", arrowtail="none"];
"nltk.corpus.reader.cmudict.CMUDictCorpusReader" -> "nltk.corpus.reader.api.CorpusReader" [arrowhead="empty", arrowtail="none"];
"nltk.corpus.reader.conll.ConllChunkCorpusReader" -> "nltk.corpus.reader.conll.ConllCorpusReader" [arrowhead="empty", arrowtail="none"];
"nltk.corpus.reader.conll.ConllCorpusReader" -> "nltk.corpus.reader.api.CorpusReader" [arrowhead="empty", arrowtail="none"];
"nltk.corpus.reader.dependency.DependencyCorpusReader" -> "nltk.corpus.reader.api.SyntaxCorpusReader" [arrowhead="empty", arrowtail="none"];
"nltk.corpus.reader.dependency.DependencyCorpusView" -> "nltk.corpus.reader.util.StreamBackedCorpusView" [arrowhead="empty", arrowtail="none"];
"nltk.corpus.reader.framenet.FramenetCorpusReader" -> "nltk.corpus.reader.xmldocs.XMLCorpusReader" [arrowhead="empty", arrowtail="none"];
"nltk.corpus.reader.framenet.PrettyDict" -> "nltk.corpus.reader.framenet.AttrDict" [arrowhead="empty", arrowtail="none"];
"nltk.corpus.reader.framenet.PrettyLazyMap" -> "nltk.util.LazyMap" [arrowhead="empty", arrowtail="none"];
"nltk.corpus.reader.ieer.IEERCorpusReader" -> "nltk.corpus.reader.api.CorpusReader" [arrowhead="empty", arrowtail="none"];
"nltk.corpus.reader.indian.IndianCorpusReader" -> "nltk.corpus.reader.api.CorpusReader" [arrowhead="empty", arrowtail="none"];
"nltk.corpus.reader.indian.IndianCorpusView" -> "nltk.corpus.reader.util.StreamBackedCorpusView" [arrowhead="empty", arrowtail="none"];
"nltk.corpus.reader.ipipan.IPIPANCorpusReader" -> "nltk.corpus.reader.api.CorpusReader" [arrowhead="empty", arrowtail="none"];
"nltk.corpus.reader.ipipan.IPIPANCorpusView" -> "nltk.corpus.reader.util.StreamBackedCorpusView" [arrowhead="empty", arrowtail="none"];
"nltk.corpus.reader.knbc.KNBCorpusReader" -> "nltk.corpus.reader.api.SyntaxCorpusReader" [arrowhead="empty", arrowtail="none"];
"nltk.corpus.reader.lin.LinThesaurusCorpusReader" -> "nltk.corpus.reader.api.CorpusReader" [arrowhead="empty", arrowtail="none"];
"nltk.corpus.reader.nkjp.NKJPCorpusReader" -> "nltk.corpus.reader.xmldocs.XMLCorpusReader" [arrowhead="empty", arrowtail="none"];
"nltk.corpus.reader.nkjp.NKJPCorpus_Header_View" -> "nltk.corpus.reader.xmldocs.XMLCorpusView" [arrowhead="empty", arrowtail="none"];
"nltk.corpus.reader.nkjp.NKJPCorpus_Morph_View" -> "nltk.corpus.reader.xmldocs.XMLCorpusView" [arrowhead="empty", arrowtail="none"];
"nltk.corpus.reader.nkjp.NKJPCorpus_Segmentation_View" -> "nltk.corpus.reader.xmldocs.XMLCorpusView" [arrowhead="empty", arrowtail="none"];
"nltk.corpus.reader.nkjp.NKJPCorpus_Text_View" -> "nltk.corpus.reader.xmldocs.XMLCorpusView" [arrowhead="empty", arrowtail="none"];
"nltk.corpus.reader.nombank.NombankChainTreePointer" -> "nltk.corpus.reader.nombank.NombankPointer" [arrowhead="empty", arrowtail="none"];
"nltk.corpus.reader.nombank.NombankCorpusReader" -> "nltk.corpus.reader.api.CorpusReader" [arrowhead="empty", arrowtail="none"];
"nltk.corpus.reader.nombank.NombankSplitTreePointer" -> "nltk.corpus.reader.nombank.NombankPointer" [arrowhead="empty", arrowtail="none"];
"nltk.corpus.reader.nombank.NombankTreePointer" -> "nltk.corpus.reader.nombank.NombankPointer" [arrowhead="empty", arrowtail="none"];
"nltk.corpus.reader.nps_chat.NPSChatCorpusReader" -> "nltk.corpus.reader.xmldocs.XMLCorpusReader" [arrowhead="empty", arrowtail="none"];
"nltk.corpus.reader.pl196x.Pl196xCorpusReader" -> "nltk.corpus.reader.api.CategorizedCorpusReader" [arrowhead="empty", arrowtail="none"];
"nltk.corpus.reader.pl196x.Pl196xCorpusReader" -> "nltk.corpus.reader.xmldocs.XMLCorpusReader" [arrowhead="empty", arrowtail="none"];
"nltk.corpus.reader.pl196x.TEICorpusView" -> "nltk.corpus.reader.util.StreamBackedCorpusView" [arrowhead="empty", arrowtail="none"];
"nltk.corpus.reader.plaintext.CategorizedPlaintextCorpusReader" -> "nltk.corpus.reader.api.CategorizedCorpusReader" [arrowhead="empty", arrowtail="none"];
"nltk.corpus.reader.plaintext.CategorizedPlaintextCorpusReader" -> "nltk.corpus.reader.plaintext.PlaintextCorpusReader" [arrowhead="empty", arrowtail="none"];
"nltk.corpus.reader.plaintext.EuroparlCorpusReader" -> "nltk.corpus.reader.plaintext.PlaintextCorpusReader" [arrowhead="empty", arrowtail="none"];
"nltk.corpus.reader.plaintext.PlaintextCorpusReader" -> "nltk.corpus.reader.api.CorpusReader" [arrowhead="empty", arrowtail="none"];
"nltk.corpus.reader.plaintext.PortugueseCategorizedPlaintextCorpusReader" -> "nltk.corpus.reader.plaintext.CategorizedPlaintextCorpusReader" [arrowhead="empty", arrowtail="none"];
"nltk.corpus.reader.ppattach.PPAttachmentCorpusReader" -> "nltk.corpus.reader.api.CorpusReader" [arrowhead="empty", arrowtail="none"];
"nltk.corpus.reader.propbank.PropbankChainTreePointer" -> "nltk.corpus.reader.propbank.PropbankPointer" [arrowhead="empty", arrowtail="none"];
"nltk.corpus.reader.propbank.PropbankCorpusReader" -> "nltk.corpus.reader.api.CorpusReader" [arrowhead="empty", arrowtail="none"];
"nltk.corpus.reader.propbank.PropbankSplitTreePointer" -> "nltk.corpus.reader.propbank.PropbankPointer" [arrowhead="empty", arrowtail="none"];
"nltk.corpus.reader.propbank.PropbankTreePointer" -> "nltk.corpus.reader.propbank.PropbankPointer" [arrowhead="empty", arrowtail="none"];
"nltk.corpus.reader.rte.RTECorpusReader" -> "nltk.corpus.reader.xmldocs.XMLCorpusReader" [arrowhead="empty", arrowtail="none"];
"nltk.corpus.reader.semcor.SemcorCorpusReader" -> "nltk.corpus.reader.xmldocs.XMLCorpusReader" [arrowhead="empty", arrowtail="none"];
"nltk.corpus.reader.semcor.SemcorWordView" -> "nltk.corpus.reader.xmldocs.XMLCorpusView" [arrowhead="empty", arrowtail="none"];
"nltk.corpus.reader.senseval.SensevalCorpusReader" -> "nltk.corpus.reader.api.CorpusReader" [arrowhead="empty", arrowtail="none"];
"nltk.corpus.reader.senseval.SensevalCorpusView" -> "nltk.corpus.reader.util.StreamBackedCorpusView" [arrowhead="empty", arrowtail="none"];
"nltk.corpus.reader.sentiwordnet.SentiWordNetCorpusReader" -> "nltk.corpus.reader.api.CorpusReader" [arrowhead="empty", arrowtail="none"];
"nltk.corpus.reader.sinica_treebank.SinicaTreebankCorpusReader" -> "nltk.corpus.reader.api.SyntaxCorpusReader" [arrowhead="empty", arrowtail="none"];
"nltk.corpus.reader.string_category.StringCategoryCorpusReader" -> "nltk.corpus.reader.api.CorpusReader" [arrowhead="empty", arrowtail="none"];
"nltk.corpus.reader.switchboard.SwitchboardCorpusReader" -> "nltk.corpus.reader.api.CorpusReader" [arrowhead="empty", arrowtail="none"];
"nltk.corpus.reader.tagged.CategorizedTaggedCorpusReader" -> "nltk.corpus.reader.api.CategorizedCorpusReader" [arrowhead="empty", arrowtail="none"];
"nltk.corpus.reader.tagged.CategorizedTaggedCorpusReader" -> "nltk.corpus.reader.tagged.TaggedCorpusReader" [arrowhead="empty", arrowtail="none"];
"nltk.corpus.reader.tagged.MacMorphoCorpusReader" -> "nltk.corpus.reader.tagged.TaggedCorpusReader" [arrowhead="empty", arrowtail="none"];
"nltk.corpus.reader.tagged.TaggedCorpusReader" -> "nltk.corpus.reader.api.CorpusReader" [arrowhead="empty", arrowtail="none"];
"nltk.corpus.reader.tagged.TaggedCorpusView" -> "nltk.corpus.reader.util.StreamBackedCorpusView" [arrowhead="empty", arrowtail="none"];
"nltk.corpus.reader.tagged.TimitTaggedCorpusReader" -> "nltk.corpus.reader.tagged.TaggedCorpusReader" [arrowhead="empty", arrowtail="none"];
"nltk.corpus.reader.timit.TimitCorpusReader" -> "nltk.corpus.reader.api.CorpusReader" [arrowhead="empty", arrowtail="none"];
"nltk.corpus.reader.toolbox.ToolboxCorpusReader" -> "nltk.corpus.reader.api.CorpusReader" [arrowhead="empty", arrowtail="none"];
"nltk.corpus.reader.udhr.UdhrCorpusReader" -> "nltk.corpus.reader.plaintext.PlaintextCorpusReader" [arrowhead="empty", arrowtail="none"];
"nltk.corpus.reader.util.ConcatenatedCorpusView" -> "nltk.util.AbstractLazySequence" [arrowhead="empty", arrowtail="none"];
"nltk.corpus.reader.util.PickleCorpusView" -> "nltk.corpus.reader.util.StreamBackedCorpusView" [arrowhead="empty", arrowtail="none"];
"nltk.corpus.reader.util.StreamBackedCorpusView" -> "nltk.util.AbstractLazySequence" [arrowhead="empty", arrowtail="none"];
"nltk.corpus.reader.verbnet.VerbnetCorpusReader" -> "nltk.corpus.reader.xmldocs.XMLCorpusReader" [arrowhead="empty", arrowtail="none"];
"nltk.corpus.reader.wordlist.SwadeshCorpusReader" -> "nltk.corpus.reader.wordlist.WordListCorpusReader" [arrowhead="empty", arrowtail="none"];
"nltk.corpus.reader.wordlist.WordListCorpusReader" -> "nltk.corpus.reader.api.CorpusReader" [arrowhead="empty", arrowtail="none"];
"nltk.corpus.reader.wordnet.Lemma" -> "nltk.corpus.reader.wordnet._WordNetObject" [arrowhead="empty", arrowtail="none"];
"nltk.corpus.reader.wordnet.Synset" -> "nltk.corpus.reader.wordnet._WordNetObject" [arrowhead="empty", arrowtail="none"];
"nltk.corpus.reader.wordnet.WordNetCorpusReader" -> "nltk.corpus.reader.api.CorpusReader" [arrowhead="empty", arrowtail="none"];
"nltk.corpus.reader.wordnet.WordNetICCorpusReader" -> "nltk.corpus.reader.api.CorpusReader" [arrowhead="empty", arrowtail="none"];
"nltk.corpus.reader.xmldocs.XMLCorpusReader" -> "nltk.corpus.reader.api.CorpusReader" [arrowhead="empty", arrowtail="none"];
"nltk.corpus.reader.xmldocs.XMLCorpusView" -> "nltk.corpus.reader.util.StreamBackedCorpusView" [arrowhead="empty", arrowtail="none"];
"nltk.corpus.reader.ycoe.YCOECorpusReader" -> "nltk.corpus.reader.api.CorpusReader" [arrowhead="empty", arrowtail="none"];
"nltk.corpus.reader.ycoe.YCOEParseCorpusReader" -> "nltk.corpus.reader.bracket_parse.BracketParseCorpusReader" [arrowhead="empty", arrowtail="none"];
"nltk.corpus.reader.ycoe.YCOETaggedCorpusReader" -> "nltk.corpus.reader.tagged.TaggedCorpusReader" [arrowhead="empty", arrowtail="none"];
"nltk.data.FileSystemPathPointer" -> "nltk.data.PathPointer" [arrowhead="empty", arrowtail="none"];
"nltk.data.GzipFileSystemPathPointer" -> "nltk.data.FileSystemPathPointer" [arrowhead="empty", arrowtail="none"];
"nltk.data.ZipFilePathPointer" -> "nltk.data.PathPointer" [arrowhead="empty", arrowtail="none"];
"nltk.downloader.ErrorMessage" -> "nltk.downloader.DownloaderMessage" [arrowhead="empty", arrowtail="none"];
"nltk.downloader.FinishCollectionMessage" -> "nltk.downloader.DownloaderMessage" [arrowhead="empty", arrowtail="none"];
"nltk.downloader.FinishDownloadMessage" -> "nltk.downloader.DownloaderMessage" [arrowhead="empty", arrowtail="none"];
"nltk.downloader.FinishPackageMessage" -> "nltk.downloader.DownloaderMessage" [arrowhead="empty", arrowtail="none"];
"nltk.downloader.FinishUnzipMessage" -> "nltk.downloader.DownloaderMessage" [arrowhead="empty", arrowtail="none"];
"nltk.downloader.ProgressMessage" -> "nltk.downloader.DownloaderMessage" [arrowhead="empty", arrowtail="none"];
"nltk.downloader.SelectDownloadDirMessage" -> "nltk.downloader.DownloaderMessage" [arrowhead="empty", arrowtail="none"];
"nltk.downloader.StaleMessage" -> "nltk.downloader.DownloaderMessage" [arrowhead="empty", arrowtail="none"];
"nltk.downloader.StartCollectionMessage" -> "nltk.downloader.DownloaderMessage" [arrowhead="empty", arrowtail="none"];
"nltk.downloader.StartDownloadMessage" -> "nltk.downloader.DownloaderMessage" [arrowhead="empty", arrowtail="none"];
"nltk.downloader.StartPackageMessage" -> "nltk.downloader.DownloaderMessage" [arrowhead="empty", arrowtail="none"];
"nltk.downloader.StartUnzipMessage" -> "nltk.downloader.DownloaderMessage" [arrowhead="empty", arrowtail="none"];
"nltk.downloader.UpToDateMessage" -> "nltk.downloader.DownloaderMessage" [arrowhead="empty", arrowtail="none"];
"nltk.draw.cfg.ProductionList" -> "nltk.draw.util.ColorizedList" [arrowhead="empty", arrowtail="none"];
"nltk.draw.tree.TreeSegmentWidget" -> "nltk.draw.util.CanvasWidget" [arrowhead="empty", arrowtail="none"];
"nltk.draw.tree.TreeWidget" -> "nltk.draw.util.CanvasWidget" [arrowhead="empty", arrowtail="none"];
"nltk.draw.util.AbstractContainerWidget" -> "nltk.draw.util.CanvasWidget" [arrowhead="empty", arrowtail="none"];
"nltk.draw.util.BoxWidget" -> "nltk.draw.util.AbstractContainerWidget" [arrowhead="empty", arrowtail="none"];
"nltk.draw.util.BracketWidget" -> "nltk.draw.util.AbstractContainerWidget" [arrowhead="empty", arrowtail="none"];
"nltk.draw.util.OvalWidget" -> "nltk.draw.util.AbstractContainerWidget" [arrowhead="empty", arrowtail="none"];
"nltk.draw.util.ParenWidget" -> "nltk.draw.util.AbstractContainerWidget" [arrowhead="empty", arrowtail="none"];
"nltk.draw.util.ScrollWatcherWidget" -> "nltk.draw.util.CanvasWidget" [arrowhead="empty", arrowtail="none"];
"nltk.draw.util.SequenceWidget" -> "nltk.draw.util.CanvasWidget" [arrowhead="empty", arrowtail="none"];
"nltk.draw.util.SpaceWidget" -> "nltk.draw.util.CanvasWidget" [arrowhead="empty", arrowtail="none"];
"nltk.draw.util.StackWidget" -> "nltk.draw.util.CanvasWidget" [arrowhead="empty", arrowtail="none"];
"nltk.draw.util.SymbolWidget" -> "nltk.draw.util.TextWidget" [arrowhead="empty", arrowtail="none"];
"nltk.draw.util.TextWidget" -> "nltk.draw.util.CanvasWidget" [arrowhead="empty", arrowtail="none"];
"nltk.featstruct.FeatDict" -> "nltk.featstruct.FeatStruct" [arrowhead="empty", arrowtail="none"];
"nltk.featstruct.FeatList" -> "nltk.featstruct.FeatStruct" [arrowhead="empty", arrowtail="none"];
"nltk.featstruct.FeatStruct" -> "nltk.sem.logic.SubstituteBindingsI" [arrowhead="empty", arrowtail="none"];
"nltk.featstruct.FeatureValueConcat" -> "nltk.featstruct.SubstituteBindingsSequence" [arrowhead="empty", arrowtail="none"];
"nltk.featstruct.FeatureValueSet" -> "nltk.featstruct.SubstituteBindingsSequence" [arrowhead="empty", arrowtail="none"];
"nltk.featstruct.FeatureValueTuple" -> "nltk.featstruct.SubstituteBindingsSequence" [arrowhead="empty", arrowtail="none"];
"nltk.featstruct.FeatureValueUnion" -> "nltk.featstruct.SubstituteBindingsSequence" [arrowhead="empty", arrowtail="none"];
"nltk.featstruct.RangeFeature" -> "nltk.featstruct.Feature" [arrowhead="empty", arrowtail="none"];
"nltk.featstruct.SlashFeature" -> "nltk.featstruct.Feature" [arrowhead="empty", arrowtail="none"];
"nltk.featstruct.SubstituteBindingsSequence" -> "nltk.sem.logic.SubstituteBindingsI" [arrowhead="empty", arrowtail="none"];
"nltk.grammar.DependencyProduction" -> "nltk.grammar.Production" [arrowhead="empty", arrowtail="none"];
"nltk.grammar.FeatStructNonterminal" -> "nltk.featstruct.FeatDict" [arrowhead="empty", arrowtail="none"];
"nltk.grammar.FeatStructNonterminal" -> "nltk.grammar.Nonterminal" [arrowhead="empty", arrowtail="none"];
"nltk.grammar.FeatureGrammar" -> "nltk.grammar.CFG" [arrowhead="empty", arrowtail="none"];
"nltk.grammar.PCFG" -> "nltk.grammar.CFG" [arrowhead="empty", arrowtail="none"];
"nltk.grammar.ProbabilisticProduction" -> "nltk.grammar.Production" [arrowhead="empty", arrowtail="none"];
"nltk.grammar.ProbabilisticProduction" -> "nltk.probability.ImmutableProbabilisticMixIn" [arrowhead="empty", arrowtail="none"];
"nltk.inference.api.BaseModelBuilderCommand" -> "nltk.inference.api.BaseTheoremToolCommand" [arrowhead="empty", arrowtail="none"];
"nltk.inference.api.BaseModelBuilderCommand" -> "nltk.inference.api.ModelBuilderCommand" [arrowhead="empty", arrowtail="none"];
"nltk.inference.api.BaseProverCommand" -> "nltk.inference.api.BaseTheoremToolCommand" [arrowhead="empty", arrowtail="none"];
"nltk.inference.api.BaseProverCommand" -> "nltk.inference.api.ProverCommand" [arrowhead="empty", arrowtail="none"];
"nltk.inference.api.BaseTheoremToolCommand" -> "nltk.inference.api.TheoremToolCommand" [arrowhead="empty", arrowtail="none"];
"nltk.inference.api.ModelBuilderCommand" -> "nltk.inference.api.TheoremToolCommand" [arrowhead="empty", arrowtail="none"];
"nltk.inference.api.ModelBuilderCommandDecorator" -> "nltk.inference.api.ModelBuilderCommand" [arrowhead="empty", arrowtail="none"];
"nltk.inference.api.ModelBuilderCommandDecorator" -> "nltk.inference.api.TheoremToolCommandDecorator" [arrowhead="empty", arrowtail="none"];
"nltk.inference.api.ParallelProverBuilder" -> "nltk.inference.api.ModelBuilder" [arrowhead="empty", arrowtail="none"];
"nltk.inference.api.ParallelProverBuilder" -> "nltk.inference.api.Prover" [arrowhead="empty", arrowtail="none"];
"nltk.inference.api.ParallelProverBuilderCommand" -> "nltk.inference.api.BaseModelBuilderCommand" [arrowhead="empty", arrowtail="none"];
"nltk.inference.api.ParallelProverBuilderCommand" -> "nltk.inference.api.BaseProverCommand" [arrowhead="empty", arrowtail="none"];
"nltk.inference.api.ProverCommand" -> "nltk.inference.api.TheoremToolCommand" [arrowhead="empty", arrowtail="none"];
"nltk.inference.api.ProverCommandDecorator" -> "nltk.inference.api.ProverCommand" [arrowhead="empty", arrowtail="none"];
"nltk.inference.api.ProverCommandDecorator" -> "nltk.inference.api.TheoremToolCommandDecorator" [arrowhead="empty", arrowtail="none"];
"nltk.inference.api.TheoremToolCommandDecorator" -> "nltk.inference.api.TheoremToolCommand" [arrowhead="empty", arrowtail="none"];
"nltk.inference.discourse.CfgReadingCommand" -> "nltk.inference.discourse.ReadingCommand" [arrowhead="empty", arrowtail="none"];
"nltk.inference.discourse.DrtGlueReadingCommand" -> "nltk.inference.discourse.ReadingCommand" [arrowhead="empty", arrowtail="none"];
"nltk.inference.mace.Mace" -> "nltk.inference.api.ModelBuilder" [arrowhead="empty", arrowtail="none"];
"nltk.inference.mace.Mace" -> "nltk.inference.prover9.Prover9Parent" [arrowhead="empty", arrowtail="none"];
"nltk.inference.mace.MaceCommand" -> "nltk.inference.api.BaseModelBuilderCommand" [arrowhead="empty", arrowtail="none"];
"nltk.inference.mace.MaceCommand" -> "nltk.inference.prover9.Prover9CommandParent" [arrowhead="empty", arrowtail="none"];
"nltk.inference.nonmonotonic.ClosedDomainProver" -> "nltk.inference.api.ProverCommandDecorator" [arrowhead="empty", arrowtail="none"];
"nltk.inference.nonmonotonic.ClosedWorldProver" -> "nltk.inference.api.ProverCommandDecorator" [arrowhead="empty", arrowtail="none"];
"nltk.inference.nonmonotonic.UniqueNamesProver" -> "nltk.inference.api.ProverCommandDecorator" [arrowhead="empty", arrowtail="none"];
"nltk.inference.prover9.Prover9" -> "nltk.inference.api.Prover" [arrowhead="empty", arrowtail="none"];
"nltk.inference.prover9.Prover9" -> "nltk.inference.prover9.Prover9Parent" [arrowhead="empty", arrowtail="none"];
"nltk.inference.prover9.Prover9Command" -> "nltk.inference.api.BaseProverCommand" [arrowhead="empty", arrowtail="none"];
"nltk.inference.prover9.Prover9Command" -> "nltk.inference.prover9.Prover9CommandParent" [arrowhead="empty", arrowtail="none"];
"nltk.inference.prover9.Prover9FatalException" -> "nltk.inference.prover9.Prover9Exception" [arrowhead="empty", arrowtail="none"];
"nltk.inference.prover9.Prover9LimitExceededException" -> "nltk.inference.prover9.Prover9Exception" [arrowhead="empty", arrowtail="none"];
"nltk.inference.resolution.ResolutionProver" -> "nltk.inference.api.Prover" [arrowhead="empty", arrowtail="none"];
"nltk.inference.resolution.ResolutionProverCommand" -> "nltk.inference.api.BaseProverCommand" [arrowhead="empty", arrowtail="none"];
"nltk.inference.tableau.TableauProver" -> "nltk.inference.api.Prover" [arrowhead="empty", arrowtail="none"];
"nltk.inference.tableau.TableauProverCommand" -> "nltk.inference.api.BaseProverCommand" [arrowhead="empty", arrowtail="none"];
"nltk.metrics.association.BigramAssocMeasures" -> "nltk.metrics.association.NgramAssocMeasures" [arrowhead="empty", arrowtail="none"];
"nltk.metrics.association.QuadgramAssocMeasures" -> "nltk.metrics.association.NgramAssocMeasures" [arrowhead="empty", arrowtail="none"];
"nltk.metrics.association.TrigramAssocMeasures" -> "nltk.metrics.association.NgramAssocMeasures" [arrowhead="empty", arrowtail="none"];
"nltk.parse.bllip.BllipParser" -> "nltk.parse.api.ParserI" [arrowhead="empty", arrowtail="none"];
"nltk.parse.chart.AbstractChartRule" -> "nltk.parse.chart.ChartRuleI" [arrowhead="empty", arrowtail="none"];
"nltk.parse.chart.BottomUpChartParser" -> "nltk.parse.chart.ChartParser" [arrowhead="empty", arrowtail="none"];
"nltk.parse.chart.BottomUpLeftCornerChartParser" -> "nltk.parse.chart.ChartParser" [arrowhead="empty", arrowtail="none"];
"nltk.parse.chart.BottomUpPredictCombineRule" -> "nltk.parse.chart.BottomUpPredictRule" [arrowhead="empty", arrowtail="none"];
"nltk.parse.chart.BottomUpPredictRule" -> "nltk.parse.chart.AbstractChartRule" [arrowhead="empty", arrowtail="none"];
"nltk.parse.chart.CachedTopDownPredictRule" -> "nltk.parse.chart.TopDownPredictRule" [arrowhead="empty", arrowtail="none"];
"nltk.parse.chart.ChartParser" -> "nltk.parse.api.ParserI" [arrowhead="empty", arrowtail="none"];
"nltk.parse.chart.EmptyPredictRule" -> "nltk.parse.chart.AbstractChartRule" [arrowhead="empty", arrowtail="none"];
"nltk.parse.chart.FilteredBottomUpPredictCombineRule" -> "nltk.parse.chart.BottomUpPredictCombineRule" [arrowhead="empty", arrowtail="none"];
"nltk.parse.chart.FilteredSingleEdgeFundamentalRule" -> "nltk.parse.chart.SingleEdgeFundamentalRule" [arrowhead="empty", arrowtail="none"];
"nltk.parse.chart.FundamentalRule" -> "nltk.parse.chart.AbstractChartRule" [arrowhead="empty", arrowtail="none"];
"nltk.parse.chart.LeafEdge" -> "nltk.parse.chart.EdgeI" [arrowhead="empty", arrowtail="none"];
"nltk.parse.chart.LeafInitRule" -> "nltk.parse.chart.AbstractChartRule" [arrowhead="empty", arrowtail="none"];
"nltk.parse.chart.LeftCornerChartParser" -> "nltk.parse.chart.ChartParser" [arrowhead="empty", arrowtail="none"];
"nltk.parse.chart.SingleEdgeFundamentalRule" -> "nltk.parse.chart.FundamentalRule" [arrowhead="empty", arrowtail="none"];
"nltk.parse.chart.SteppingChartParser" -> "nltk.parse.chart.ChartParser" [arrowhead="empty", arrowtail="none"];
"nltk.parse.chart.TopDownChartParser" -> "nltk.parse.chart.ChartParser" [arrowhead="empty", arrowtail="none"];
"nltk.parse.chart.TopDownInitRule" -> "nltk.parse.chart.AbstractChartRule" [arrowhead="empty", arrowtail="none"];
"nltk.parse.chart.TopDownPredictRule" -> "nltk.parse.chart.AbstractChartRule" [arrowhead="empty", arrowtail="none"];
"nltk.parse.chart.TreeEdge" -> "nltk.parse.chart.EdgeI" [arrowhead="empty", arrowtail="none"];
"nltk.parse.earleychart.CompleteFundamentalRule" -> "nltk.parse.chart.SingleEdgeFundamentalRule" [arrowhead="empty", arrowtail="none"];
"nltk.parse.earleychart.CompleterRule" -> "nltk.parse.earleychart.CompleteFundamentalRule" [arrowhead="empty", arrowtail="none"];
"nltk.parse.earleychart.EarleyChartParser" -> "nltk.parse.earleychart.IncrementalChartParser" [arrowhead="empty", arrowtail="none"];
"nltk.parse.earleychart.FeatureCompleteFundamentalRule" -> "nltk.parse.featurechart.FeatureSingleEdgeFundamentalRule" [arrowhead="empty", arrowtail="none"];
"nltk.parse.earleychart.FeatureCompleterRule" -> "nltk.parse.earleychart.CompleterRule" [arrowhead="empty", arrowtail="none"];
"nltk.parse.earleychart.FeatureEarleyChartParser" -> "nltk.parse.earleychart.FeatureIncrementalChartParser" [arrowhead="empty", arrowtail="none"];
"nltk.parse.earleychart.FeatureIncrementalBottomUpChartParser" -> "nltk.parse.earleychart.FeatureIncrementalChartParser" [arrowhead="empty", arrowtail="none"];
"nltk.parse.earleychart.FeatureIncrementalBottomUpLeftCornerChartParser" -> "nltk.parse.earleychart.FeatureIncrementalChartParser" [arrowhead="empty", arrowtail="none"];
"nltk.parse.earleychart.FeatureIncrementalChart" -> "nltk.parse.earleychart.IncrementalChart" [arrowhead="empty", arrowtail="none"];
"nltk.parse.earleychart.FeatureIncrementalChart" -> "nltk.parse.featurechart.FeatureChart" [arrowhead="empty", arrowtail="none"];
"nltk.parse.earleychart.FeatureIncrementalChartParser" -> "nltk.parse.earleychart.IncrementalChartParser" [arrowhead="empty", arrowtail="none"];
"nltk.parse.earleychart.FeatureIncrementalChartParser" -> "nltk.parse.featurechart.FeatureChartParser" [arrowhead="empty", arrowtail="none"];
"nltk.parse.earleychart.FeatureIncrementalTopDownChartParser" -> "nltk.parse.earleychart.FeatureIncrementalChartParser" [arrowhead="empty", arrowtail="none"];
"nltk.parse.earleychart.FeaturePredictorRule" -> "nltk.parse.featurechart.FeatureTopDownPredictRule" [arrowhead="empty", arrowtail="none"];
"nltk.parse.earleychart.FeatureScannerRule" -> "nltk.parse.earleychart.ScannerRule" [arrowhead="empty", arrowtail="none"];
"nltk.parse.earleychart.FilteredCompleteFundamentalRule" -> "nltk.parse.chart.FilteredSingleEdgeFundamentalRule" [arrowhead="empty", arrowtail="none"];
"nltk.parse.earleychart.IncrementalBottomUpChartParser" -> "nltk.parse.earleychart.IncrementalChartParser" [arrowhead="empty", arrowtail="none"];
"nltk.parse.earleychart.IncrementalBottomUpLeftCornerChartParser" -> "nltk.parse.earleychart.IncrementalChartParser" [arrowhead="empty", arrowtail="none"];
"nltk.parse.earleychart.IncrementalChart" -> "nltk.parse.chart.Chart" [arrowhead="empty", arrowtail="none"];
"nltk.parse.earleychart.IncrementalChartParser" -> "nltk.parse.chart.ChartParser" [arrowhead="empty", arrowtail="none"];
"nltk.parse.earleychart.IncrementalLeftCornerChartParser" -> "nltk.parse.earleychart.IncrementalChartParser" [arrowhead="empty", arrowtail="none"];
"nltk.parse.earleychart.IncrementalTopDownChartParser" -> "nltk.parse.earleychart.IncrementalChartParser" [arrowhead="empty", arrowtail="none"];
"nltk.parse.earleychart.PredictorRule" -> "nltk.parse.chart.CachedTopDownPredictRule" [arrowhead="empty", arrowtail="none"];
"nltk.parse.earleychart.ScannerRule" -> "nltk.parse.earleychart.CompleteFundamentalRule" [arrowhead="empty", arrowtail="none"];
"nltk.parse.featurechart.FeatureBottomUpChartParser" -> "nltk.parse.featurechart.FeatureChartParser" [arrowhead="empty", arrowtail="none"];
"nltk.parse.featurechart.FeatureBottomUpLeftCornerChartParser" -> "nltk.parse.featurechart.FeatureChartParser" [arrowhead="empty", arrowtail="none"];
"nltk.parse.featurechart.FeatureBottomUpPredictCombineRule" -> "nltk.parse.chart.BottomUpPredictCombineRule" [arrowhead="empty", arrowtail="none"];
"nltk.parse.featurechart.FeatureBottomUpPredictRule" -> "nltk.parse.chart.BottomUpPredictRule" [arrowhead="empty", arrowtail="none"];
"nltk.parse.featurechart.FeatureChart" -> "nltk.parse.chart.Chart" [arrowhead="empty", arrowtail="none"];
"nltk.parse.featurechart.FeatureChartParser" -> "nltk.parse.chart.ChartParser" [arrowhead="empty", arrowtail="none"];
"nltk.parse.featurechart.FeatureEmptyPredictRule" -> "nltk.parse.chart.EmptyPredictRule" [arrowhead="empty", arrowtail="none"];
"nltk.parse.featurechart.FeatureFundamentalRule" -> "nltk.parse.chart.FundamentalRule" [arrowhead="empty", arrowtail="none"];
"nltk.parse.featurechart.FeatureSingleEdgeFundamentalRule" -> "nltk.parse.chart.SingleEdgeFundamentalRule" [arrowhead="empty", arrowtail="none"];
"nltk.parse.featurechart.FeatureTopDownChartParser" -> "nltk.parse.featurechart.FeatureChartParser" [arrowhead="empty", arrowtail="none"];
"nltk.parse.featurechart.FeatureTopDownInitRule" -> "nltk.parse.chart.TopDownInitRule" [arrowhead="empty", arrowtail="none"];
"nltk.parse.featurechart.FeatureTopDownPredictRule" -> "nltk.parse.chart.CachedTopDownPredictRule" [arrowhead="empty", arrowtail="none"];
"nltk.parse.featurechart.FeatureTreeEdge" -> "nltk.parse.chart.TreeEdge" [arrowhead="empty", arrowtail="none"];
"nltk.parse.featurechart.InstantiateVarsChart" -> "nltk.parse.featurechart.FeatureChart" [arrowhead="empty", arrowtail="none"];
"nltk.parse.malt.MaltParser" -> "nltk.parse.api.ParserI" [arrowhead="empty", arrowtail="none"];
"nltk.parse.nonprojectivedependencyparser.DemoScorer" -> "nltk.parse.nonprojectivedependencyparser.DependencyScorerI" [arrowhead="empty", arrowtail="none"];
"nltk.parse.nonprojectivedependencyparser.NaiveBayesDependencyScorer" -> "nltk.parse.nonprojectivedependencyparser.DependencyScorerI" [arrowhead="empty", arrowtail="none"];
"nltk.parse.pchart.BottomUpProbabilisticChartParser" -> "nltk.parse.api.ParserI" [arrowhead="empty", arrowtail="none"];
"nltk.parse.pchart.InsideChartParser" -> "nltk.parse.pchart.BottomUpProbabilisticChartParser" [arrowhead="empty", arrowtail="none"];
"nltk.parse.pchart.LongestChartParser" -> "nltk.parse.pchart.BottomUpProbabilisticChartParser" [arrowhead="empty", arrowtail="none"];
"nltk.parse.pchart.ProbabilisticBottomUpInitRule" -> "nltk.parse.chart.AbstractChartRule" [arrowhead="empty", arrowtail="none"];
"nltk.parse.pchart.ProbabilisticBottomUpPredictRule" -> "nltk.parse.chart.AbstractChartRule" [arrowhead="empty", arrowtail="none"];
"nltk.parse.pchart.ProbabilisticFundamentalRule" -> "nltk.parse.chart.AbstractChartRule" [arrowhead="empty", arrowtail="none"];
"nltk.parse.pchart.ProbabilisticLeafEdge" -> "nltk.parse.chart.LeafEdge" [arrowhead="empty", arrowtail="none"];
"nltk.parse.pchart.ProbabilisticTreeEdge" -> "nltk.parse.chart.TreeEdge" [arrowhead="empty", arrowtail="none"];
"nltk.parse.pchart.RandomChartParser" -> "nltk.parse.pchart.BottomUpProbabilisticChartParser" [arrowhead="empty", arrowtail="none"];
"nltk.parse.pchart.SingleEdgeProbabilisticFundamentalRule" -> "nltk.parse.chart.AbstractChartRule" [arrowhead="empty", arrowtail="none"];
"nltk.parse.pchart.UnsortedChartParser" -> "nltk.parse.pchart.BottomUpProbabilisticChartParser" [arrowhead="empty", arrowtail="none"];
"nltk.parse.recursivedescent.RecursiveDescentParser" -> "nltk.parse.api.ParserI" [arrowhead="empty", arrowtail="none"];
"nltk.parse.recursivedescent.SteppingRecursiveDescentParser" -> "nltk.parse.recursivedescent.RecursiveDescentParser" [arrowhead="empty", arrowtail="none"];
"nltk.parse.shiftreduce.ShiftReduceParser" -> "nltk.parse.api.ParserI" [arrowhead="empty", arrowtail="none"];
"nltk.parse.shiftreduce.SteppingShiftReduceParser" -> "nltk.parse.shiftreduce.ShiftReduceParser" [arrowhead="empty", arrowtail="none"];
"nltk.parse.stanford.StanfordParser" -> "nltk.parse.api.ParserI" [arrowhead="empty", arrowtail="none"];
"nltk.parse.transitionparser.TransitionParser" -> "nltk.parse.api.ParserI" [arrowhead="empty", arrowtail="none"];
"nltk.parse.viterbi.ViterbiParser" -> "nltk.parse.api.ParserI" [arrowhead="empty", arrowtail="none"];
"nltk.probability.ConditionalProbDist" -> "nltk.probability.ConditionalProbDistI" [arrowhead="empty", arrowtail="none"];
"nltk.probability.CrossValidationProbDist" -> "nltk.probability.ProbDistI" [arrowhead="empty", arrowtail="none"];
"nltk.probability.DictionaryConditionalProbDist" -> "nltk.probability.ConditionalProbDistI" [arrowhead="empty", arrowtail="none"];
"nltk.probability.DictionaryProbDist" -> "nltk.probability.ProbDistI" [arrowhead="empty", arrowtail="none"];
"nltk.probability.ELEProbDist" -> "nltk.probability.LidstoneProbDist" [arrowhead="empty", arrowtail="none"];
"nltk.probability.HeldoutProbDist" -> "nltk.probability.ProbDistI" [arrowhead="empty", arrowtail="none"];
"nltk.probability.ImmutableProbabilisticMixIn" -> "nltk.probability.ProbabilisticMixIn" [arrowhead="empty", arrowtail="none"];
"nltk.probability.KneserNeyProbDist" -> "nltk.probability.ProbDistI" [arrowhead="empty", arrowtail="none"];
"nltk.probability.LaplaceProbDist" -> "nltk.probability.LidstoneProbDist" [arrowhead="empty", arrowtail="none"];
"nltk.probability.LidstoneProbDist" -> "nltk.probability.ProbDistI" [arrowhead="empty", arrowtail="none"];
"nltk.probability.MLEProbDist" -> "nltk.probability.ProbDistI" [arrowhead="empty", arrowtail="none"];
"nltk.probability.MutableProbDist" -> "nltk.probability.ProbDistI" [arrowhead="empty", arrowtail="none"];
"nltk.probability.RandomProbDist" -> "nltk.probability.ProbDistI" [arrowhead="empty", arrowtail="none"];
"nltk.probability.SimpleGoodTuringProbDist" -> "nltk.probability.ProbDistI" [arrowhead="empty", arrowtail="none"];
"nltk.probability.UniformProbDist" -> "nltk.probability.ProbDistI" [arrowhead="empty", arrowtail="none"];
"nltk.probability.WittenBellProbDist" -> "nltk.probability.ProbDistI" [arrowhead="empty", arrowtail="none"];
"nltk.sem.boxer.BoxerCard" -> "nltk.sem.boxer.BoxerIndexed" [arrowhead="empty", arrowtail="none"];
"nltk.sem.boxer.BoxerDrs" -> "nltk.sem.boxer.AbstractBoxerDrs" [arrowhead="empty", arrowtail="none"];
"nltk.sem.boxer.BoxerDrsParser" -> "nltk.sem.drt.DrtParser" [arrowhead="empty", arrowtail="none"];
"nltk.sem.boxer.BoxerEq" -> "nltk.sem.boxer.BoxerIndexed" [arrowhead="empty", arrowtail="none"];
"nltk.sem.boxer.BoxerIndexed" -> "nltk.sem.boxer.AbstractBoxerDrs" [arrowhead="empty", arrowtail="none"];
"nltk.sem.boxer.BoxerNamed" -> "nltk.sem.boxer.BoxerIndexed" [arrowhead="empty", arrowtail="none"];
"nltk.sem.boxer.BoxerNot" -> "nltk.sem.boxer.AbstractBoxerDrs" [arrowhead="empty", arrowtail="none"];
"nltk.sem.boxer.BoxerOr" -> "nltk.sem.boxer.BoxerIndexed" [arrowhead="empty", arrowtail="none"];
"nltk.sem.boxer.BoxerOutputDrsParser" -> "nltk.sem.drt.DrtParser" [arrowhead="empty", arrowtail="none"];
"nltk.sem.boxer.BoxerPred" -> "nltk.sem.boxer.BoxerIndexed" [arrowhead="empty", arrowtail="none"];
"nltk.sem.boxer.BoxerProp" -> "nltk.sem.boxer.BoxerIndexed" [arrowhead="empty", arrowtail="none"];
"nltk.sem.boxer.BoxerRel" -> "nltk.sem.boxer.BoxerIndexed" [arrowhead="empty", arrowtail="none"];
"nltk.sem.boxer.BoxerWhq" -> "nltk.sem.boxer.BoxerIndexed" [arrowhead="empty", arrowtail="none"];
"nltk.sem.drt.DRS" -> "nltk.sem.drt.DrtExpression" [arrowhead="empty", arrowtail="none"];
"nltk.sem.drt.DRS" -> "nltk.sem.logic.Expression" [arrowhead="empty", arrowtail="none"];
"nltk.sem.drt.DrtAbstractVariableExpression" -> "nltk.sem.drt.DrtExpression" [arrowhead="empty", arrowtail="none"];
"nltk.sem.drt.DrtAbstractVariableExpression" -> "nltk.sem.logic.AbstractVariableExpression" [arrowhead="empty", arrowtail="none"];
"nltk.sem.drt.DrtApplicationExpression" -> "nltk.sem.drt.DrtExpression" [arrowhead="empty", arrowtail="none"];
"nltk.sem.drt.DrtApplicationExpression" -> "nltk.sem.logic.ApplicationExpression" [arrowhead="empty", arrowtail="none"];
"nltk.sem.drt.DrtBinaryExpression" -> "nltk.sem.drt.DrtExpression" [arrowhead="empty", arrowtail="none"];
"nltk.sem.drt.DrtBinaryExpression" -> "nltk.sem.logic.BinaryExpression" [arrowhead="empty", arrowtail="none"];
"nltk.sem.drt.DrtBooleanExpression" -> "nltk.sem.drt.DrtBinaryExpression" [arrowhead="empty", arrowtail="none"];
"nltk.sem.drt.DrtBooleanExpression" -> "nltk.sem.logic.BooleanExpression" [arrowhead="empty", arrowtail="none"];
"nltk.sem.drt.DrtConcatenation" -> "nltk.sem.drt.DrtBooleanExpression" [arrowhead="empty", arrowtail="none"];
"nltk.sem.drt.DrtConstantExpression" -> "nltk.sem.drt.DrtAbstractVariableExpression" [arrowhead="empty", arrowtail="none"];
"nltk.sem.drt.DrtConstantExpression" -> "nltk.sem.logic.ConstantExpression" [arrowhead="empty", arrowtail="none"];
"nltk.sem.drt.DrtEqualityExpression" -> "nltk.sem.drt.DrtBinaryExpression" [arrowhead="empty", arrowtail="none"];
"nltk.sem.drt.DrtEqualityExpression" -> "nltk.sem.logic.EqualityExpression" [arrowhead="empty", arrowtail="none"];
"nltk.sem.drt.DrtEventVariableExpression" -> "nltk.sem.drt.DrtIndividualVariableExpression" [arrowhead="empty", arrowtail="none"];
"nltk.sem.drt.DrtEventVariableExpression" -> "nltk.sem.logic.EventVariableExpression" [arrowhead="empty", arrowtail="none"];
"nltk.sem.drt.DrtFunctionVariableExpression" -> "nltk.sem.drt.DrtAbstractVariableExpression" [arrowhead="empty", arrowtail="none"];
"nltk.sem.drt.DrtFunctionVariableExpression" -> "nltk.sem.logic.FunctionVariableExpression" [arrowhead="empty", arrowtail="none"];
"nltk.sem.drt.DrtIndividualVariableExpression" -> "nltk.sem.drt.DrtAbstractVariableExpression" [arrowhead="empty", arrowtail="none"];
"nltk.sem.drt.DrtIndividualVariableExpression" -> "nltk.sem.logic.IndividualVariableExpression" [arrowhead="empty", arrowtail="none"];
"nltk.sem.drt.DrtLambdaExpression" -> "nltk.sem.drt.DrtExpression" [arrowhead="empty", arrowtail="none"];
"nltk.sem.drt.DrtLambdaExpression" -> "nltk.sem.logic.LambdaExpression" [arrowhead="empty", arrowtail="none"];
"nltk.sem.drt.DrtNegatedExpression" -> "nltk.sem.drt.DrtExpression" [arrowhead="empty", arrowtail="none"];
"nltk.sem.drt.DrtNegatedExpression" -> "nltk.sem.logic.NegatedExpression" [arrowhead="empty", arrowtail="none"];
"nltk.sem.drt.DrtOrExpression" -> "nltk.sem.drt.DrtBooleanExpression" [arrowhead="empty", arrowtail="none"];
"nltk.sem.drt.DrtOrExpression" -> "nltk.sem.logic.OrExpression" [arrowhead="empty", arrowtail="none"];
"nltk.sem.drt.DrtParser" -> "nltk.sem.logic.LogicParser" [arrowhead="empty", arrowtail="none"];
"nltk.sem.drt.DrtProposition" -> "nltk.sem.drt.DrtExpression" [arrowhead="empty", arrowtail="none"];
"nltk.sem.drt.DrtProposition" -> "nltk.sem.logic.Expression" [arrowhead="empty", arrowtail="none"];
"nltk.sem.drt.DrtTokens" -> "nltk.sem.logic.Tokens" [arrowhead="empty", arrowtail="none"];
"nltk.sem.drt.PossibleAntecedents" -> "nltk.sem.drt.DrtExpression" [arrowhead="empty", arrowtail="none"];
"nltk.sem.drt.PossibleAntecedents" -> "nltk.sem.logic.Expression" [arrowhead="empty", arrowtail="none"];
"nltk.sem.evaluate.Undefined" -> "nltk.sem.evaluate.Error" [arrowhead="empty", arrowtail="none"];
"nltk.sem.glue.DrtGlue" -> "nltk.sem.glue.Glue" [arrowhead="empty", arrowtail="none"];
"nltk.sem.glue.DrtGlueDict" -> "nltk.sem.glue.GlueDict" [arrowhead="empty", arrowtail="none"];
"nltk.sem.glue.DrtGlueFormula" -> "nltk.sem.glue.GlueFormula" [arrowhead="empty", arrowtail="none"];
"nltk.sem.linearlogic.ApplicationExpression" -> "nltk.sem.linearlogic.Expression" [arrowhead="empty", arrowtail="none"];
"nltk.sem.linearlogic.AtomicExpression" -> "nltk.sem.linearlogic.Expression" [arrowhead="empty", arrowtail="none"];
"nltk.sem.linearlogic.ConstantExpression" -> "nltk.sem.linearlogic.AtomicExpression" [arrowhead="empty", arrowtail="none"];
"nltk.sem.linearlogic.ImpExpression" -> "nltk.sem.linearlogic.Expression" [arrowhead="empty", arrowtail="none"];
"nltk.sem.linearlogic.LinearLogicParser" -> "nltk.sem.logic.LogicParser" [arrowhead="empty", arrowtail="none"];
"nltk.sem.linearlogic.VariableExpression" -> "nltk.sem.linearlogic.AtomicExpression" [arrowhead="empty", arrowtail="none"];
"nltk.sem.logic.AbstractVariableExpression" -> "nltk.sem.logic.Expression" [arrowhead="empty", arrowtail="none"];
"nltk.sem.logic.AllExpression" -> "nltk.sem.logic.QuantifiedExpression" [arrowhead="empty", arrowtail="none"];
"nltk.sem.logic.AndExpression" -> "nltk.sem.logic.BooleanExpression" [arrowhead="empty", arrowtail="none"];
"nltk.sem.logic.AnyType" -> "nltk.sem.logic.BasicType" [arrowhead="empty", arrowtail="none"];
"nltk.sem.logic.AnyType" -> "nltk.sem.logic.ComplexType" [arrowhead="empty", arrowtail="none"];
"nltk.sem.logic.ApplicationExpression" -> "nltk.sem.logic.Expression" [arrowhead="empty", arrowtail="none"];
"nltk.sem.logic.BasicType" -> "nltk.sem.logic.Type" [arrowhead="empty", arrowtail="none"];
"nltk.sem.logic.BinaryExpression" -> "nltk.sem.logic.Expression" [arrowhead="empty", arrowtail="none"];
"nltk.sem.logic.BooleanExpression" -> "nltk.sem.logic.BinaryExpression" [arrowhead="empty", arrowtail="none"];
"nltk.sem.logic.ComplexType" -> "nltk.sem.logic.Type" [arrowhead="empty", arrowtail="none"];
"nltk.sem.logic.ConstantExpression" -> "nltk.sem.logic.AbstractVariableExpression" [arrowhead="empty", arrowtail="none"];
"nltk.sem.logic.EntityType" -> "nltk.sem.logic.BasicType" [arrowhead="empty", arrowtail="none"];
"nltk.sem.logic.EqualityExpression" -> "nltk.sem.logic.BinaryExpression" [arrowhead="empty", arrowtail="none"];
"nltk.sem.logic.EventType" -> "nltk.sem.logic.BasicType" [arrowhead="empty", arrowtail="none"];
"nltk.sem.logic.EventVariableExpression" -> "nltk.sem.logic.IndividualVariableExpression" [arrowhead="empty", arrowtail="none"];
"nltk.sem.logic.ExistsExpression" -> "nltk.sem.logic.QuantifiedExpression" [arrowhead="empty", arrowtail="none"];
"nltk.sem.logic.ExpectedMoreTokensException" -> "nltk.sem.logic.LogicalExpressionException" [arrowhead="empty", arrowtail="none"];
"nltk.sem.logic.Expression" -> "nltk.sem.logic.SubstituteBindingsI" [arrowhead="empty", arrowtail="none"];
"nltk.sem.logic.FunctionVariableExpression" -> "nltk.sem.logic.AbstractVariableExpression" [arrowhead="empty", arrowtail="none"];
"nltk.sem.logic.IffExpression" -> "nltk.sem.logic.BooleanExpression" [arrowhead="empty", arrowtail="none"];
"nltk.sem.logic.IllegalTypeException" -> "nltk.sem.logic.TypeException" [arrowhead="empty", arrowtail="none"];
"nltk.sem.logic.ImpExpression" -> "nltk.sem.logic.BooleanExpression" [arrowhead="empty", arrowtail="none"];
"nltk.sem.logic.InconsistentTypeHierarchyException" -> "nltk.sem.logic.TypeException" [arrowhead="empty", arrowtail="none"];
"nltk.sem.logic.IndividualVariableExpression" -> "nltk.sem.logic.AbstractVariableExpression" [arrowhead="empty", arrowtail="none"];
"nltk.sem.logic.LambdaExpression" -> "nltk.sem.logic.VariableBinderExpression" [arrowhead="empty", arrowtail="none"];
"nltk.sem.logic.NegatedExpression" -> "nltk.sem.logic.Expression" [arrowhead="empty", arrowtail="none"];
"nltk.sem.logic.OrExpression" -> "nltk.sem.logic.BooleanExpression" [arrowhead="empty", arrowtail="none"];
"nltk.sem.logic.QuantifiedExpression" -> "nltk.sem.logic.VariableBinderExpression" [arrowhead="empty", arrowtail="none"];
"nltk.sem.logic.TruthValueType" -> "nltk.sem.logic.BasicType" [arrowhead="empty", arrowtail="none"];
"nltk.sem.logic.TypeResolutionException" -> "nltk.sem.logic.TypeException" [arrowhead="empty", arrowtail="none"];
"nltk.sem.logic.UnexpectedTokenException" -> "nltk.sem.logic.LogicalExpressionException" [arrowhead="empty", arrowtail="none"];
"nltk.sem.logic.VariableBinderExpression" -> "nltk.sem.logic.Expression" [arrowhead="empty", arrowtail="none"];
"nltk.stem.isri.ISRIStemmer" -> "nltk.stem.api.StemmerI" [arrowhead="empty", arrowtail="none"];
"nltk.stem.lancaster.LancasterStemmer" -> "nltk.stem.api.StemmerI" [arrowhead="empty", arrowtail="none"];
"nltk.stem.porter.PorterStemmer" -> "nltk.stem.api.StemmerI" [arrowhead="empty", arrowtail="none"];
"nltk.stem.regexp.RegexpStemmer" -> "nltk.stem.api.StemmerI" [arrowhead="empty", arrowtail="none"];
"nltk.stem.rslp.RSLPStemmer" -> "nltk.stem.api.StemmerI" [arrowhead="empty", arrowtail="none"];
"nltk.stem.snowball.DanishStemmer" -> "nltk.stem.snowball._ScandinavianStemmer" [arrowhead="empty", arrowtail="none"];
"nltk.stem.snowball.DutchStemmer" -> "nltk.stem.snowball._StandardStemmer" [arrowhead="empty", arrowtail="none"];
"nltk.stem.snowball.EnglishStemmer" -> "nltk.stem.snowball._StandardStemmer" [arrowhead="empty", arrowtail="none"];
"nltk.stem.snowball.FinnishStemmer" -> "nltk.stem.snowball._StandardStemmer" [arrowhead="empty", arrowtail="none"];
"nltk.stem.snowball.FrenchStemmer" -> "nltk.stem.snowball._StandardStemmer" [arrowhead="empty", arrowtail="none"];
"nltk.stem.snowball.GermanStemmer" -> "nltk.stem.snowball._StandardStemmer" [arrowhead="empty", arrowtail="none"];
"nltk.stem.snowball.HungarianStemmer" -> "nltk.stem.snowball._LanguageSpecificStemmer" [arrowhead="empty", arrowtail="none"];
"nltk.stem.snowball.ItalianStemmer" -> "nltk.stem.snowball._StandardStemmer" [arrowhead="empty", arrowtail="none"];
"nltk.stem.snowball.NorwegianStemmer" -> "nltk.stem.snowball._ScandinavianStemmer" [arrowhead="empty", arrowtail="none"];
"nltk.stem.snowball.PorterStemmer" -> "nltk.stem.porter.PorterStemmer" [arrowhead="empty", arrowtail="none"];
"nltk.stem.snowball.PorterStemmer" -> "nltk.stem.snowball._LanguageSpecificStemmer" [arrowhead="empty", arrowtail="none"];
"nltk.stem.snowball.PortugueseStemmer" -> "nltk.stem.snowball._StandardStemmer" [arrowhead="empty", arrowtail="none"];
"nltk.stem.snowball.RomanianStemmer" -> "nltk.stem.snowball._StandardStemmer" [arrowhead="empty", arrowtail="none"];
"nltk.stem.snowball.RussianStemmer" -> "nltk.stem.snowball._LanguageSpecificStemmer" [arrowhead="empty", arrowtail="none"];
"nltk.stem.snowball.SnowballStemmer" -> "nltk.stem.api.StemmerI" [arrowhead="empty", arrowtail="none"];
"nltk.stem.snowball.SpanishStemmer" -> "nltk.stem.snowball._StandardStemmer" [arrowhead="empty", arrowtail="none"];
"nltk.stem.snowball.SwedishStemmer" -> "nltk.stem.snowball._ScandinavianStemmer" [arrowhead="empty", arrowtail="none"];
"nltk.stem.snowball._LanguageSpecificStemmer" -> "nltk.stem.api.StemmerI" [arrowhead="empty", arrowtail="none"];
"nltk.stem.snowball._ScandinavianStemmer" -> "nltk.stem.snowball._LanguageSpecificStemmer" [arrowhead="empty", arrowtail="none"];
"nltk.stem.snowball._StandardStemmer" -> "nltk.stem.snowball._LanguageSpecificStemmer" [arrowhead="empty", arrowtail="none"];
"nltk.tag.api.FeaturesetTaggerI" -> "nltk.tag.api.TaggerI" [arrowhead="empty", arrowtail="none"];
"nltk.tag.brill.BrillTagger" -> "nltk.tag.api.TaggerI" [arrowhead="empty", arrowtail="none"];
"nltk.tag.brill.Pos" -> "nltk.tbl.feature.Feature" [arrowhead="empty", arrowtail="none"];
"nltk.tag.brill.Word" -> "nltk.tbl.feature.Feature" [arrowhead="empty", arrowtail="none"];
"nltk.tag.crf.CRFTagger" -> "nltk.tag.api.TaggerI" [arrowhead="empty", arrowtail="none"];
"nltk.tag.hmm.HiddenMarkovModelTagger" -> "nltk.tag.api.TaggerI" [arrowhead="empty", arrowtail="none"];
"nltk.tag.hunpos.HunposTagger" -> "nltk.tag.api.TaggerI" [arrowhead="empty", arrowtail="none"];
"nltk.tag.senna.SennaChunkTagger" -> "nltk.classify.senna.Senna" [arrowhead="empty", arrowtail="none"];
"nltk.tag.senna.SennaNERTagger" -> "nltk.classify.senna.Senna" [arrowhead="empty", arrowtail="none"];
"nltk.tag.senna.SennaTagger" -> "nltk.classify.senna.Senna" [arrowhead="empty", arrowtail="none"];
"nltk.tag.sequential.AffixTagger" -> "nltk.tag.sequential.ContextTagger" [arrowhead="empty", arrowtail="none"];
"nltk.tag.sequential.BigramTagger" -> "nltk.tag.sequential.NgramTagger" [arrowhead="empty", arrowtail="none"];
"nltk.tag.sequential.ClassifierBasedPOSTagger" -> "nltk.tag.sequential.ClassifierBasedTagger" [arrowhead="empty", arrowtail="none"];
"nltk.tag.sequential.ClassifierBasedTagger" -> "nltk.tag.api.FeaturesetTaggerI" [arrowhead="empty", arrowtail="none"];
"nltk.tag.sequential.ClassifierBasedTagger" -> "nltk.tag.sequential.SequentialBackoffTagger" [arrowhead="empty", arrowtail="none"];
"nltk.tag.sequential.ContextTagger" -> "nltk.tag.sequential.SequentialBackoffTagger" [arrowhead="empty", arrowtail="none"];
"nltk.tag.sequential.DefaultTagger" -> "nltk.tag.sequential.SequentialBackoffTagger" [arrowhead="empty", arrowtail="none"];
"nltk.tag.sequential.NgramTagger" -> "nltk.tag.sequential.ContextTagger" [arrowhead="empty", arrowtail="none"];
"nltk.tag.sequential.RegexpTagger" -> "nltk.tag.sequential.SequentialBackoffTagger" [arrowhead="empty", arrowtail="none"];
"nltk.tag.sequential.SequentialBackoffTagger" -> "nltk.tag.api.TaggerI" [arrowhead="empty", arrowtail="none"];
"nltk.tag.sequential.TrigramTagger" -> "nltk.tag.sequential.NgramTagger" [arrowhead="empty", arrowtail="none"];
"nltk.tag.sequential.UnigramTagger" -> "nltk.tag.sequential.NgramTagger" [arrowhead="empty", arrowtail="none"];
"nltk.tag.stanford.NERTagger" -> "nltk.tag.stanford.StanfordTagger" [arrowhead="empty", arrowtail="none"];
"nltk.tag.stanford.POSTagger" -> "nltk.tag.stanford.StanfordTagger" [arrowhead="empty", arrowtail="none"];
"nltk.tag.stanford.StanfordTagger" -> "nltk.tag.api.TaggerI" [arrowhead="empty", arrowtail="none"];
"nltk.tag.tnt.TnT" -> "nltk.tag.api.TaggerI" [arrowhead="empty", arrowtail="none"];
"nltk.tbl.rule.Rule" -> "nltk.tbl.rule.TagRule" [arrowhead="empty", arrowtail="none"];
"nltk.tbl.template.Template" -> "nltk.tbl.template.BrillTemplateI" [arrowhead="empty", arrowtail="none"];
"nltk.test.doctest_nose_plugin.DoctestFix" -> "nltk.test.doctest_nose_plugin.DoctestPluginHelper" [arrowhead="empty", arrowtail="none"];
"nltk.text.TextCollection" -> "nltk.text.Text" [arrowhead="empty", arrowtail="none"];
"nltk.tokenize.api.StringTokenizer" -> "nltk.tokenize.api.TokenizerI" [arrowhead="empty", arrowtail="none"];
"nltk.tokenize.punkt.PunktSentenceTokenizer" -> "nltk.tokenize.api.TokenizerI" [arrowhead="empty", arrowtail="none"];
"nltk.tokenize.punkt.PunktSentenceTokenizer" -> "nltk.tokenize.punkt.PunktBaseClass" [arrowhead="empty", arrowtail="none"];
"nltk.tokenize.punkt.PunktTrainer" -> "nltk.tokenize.punkt.PunktBaseClass" [arrowhead="empty", arrowtail="none"];
"nltk.tokenize.regexp.BlanklineTokenizer" -> "nltk.tokenize.regexp.RegexpTokenizer" [arrowhead="empty", arrowtail="none"];
"nltk.tokenize.regexp.RegexpTokenizer" -> "nltk.tokenize.api.TokenizerI" [arrowhead="empty", arrowtail="none"];
"nltk.tokenize.regexp.WhitespaceTokenizer" -> "nltk.tokenize.regexp.RegexpTokenizer" [arrowhead="empty", arrowtail="none"];
"nltk.tokenize.regexp.WordPunctTokenizer" -> "nltk.tokenize.regexp.RegexpTokenizer" [arrowhead="empty", arrowtail="none"];
"nltk.tokenize.sexpr.SExprTokenizer" -> "nltk.tokenize.api.TokenizerI" [arrowhead="empty", arrowtail="none"];
"nltk.tokenize.simple.CharTokenizer" -> "nltk.tokenize.api.StringTokenizer" [arrowhead="empty", arrowtail="none"];
"nltk.tokenize.simple.LineTokenizer" -> "nltk.tokenize.api.TokenizerI" [arrowhead="empty", arrowtail="none"];
"nltk.tokenize.simple.SpaceTokenizer" -> "nltk.tokenize.api.StringTokenizer" [arrowhead="empty", arrowtail="none"];
"nltk.tokenize.simple.TabTokenizer" -> "nltk.tokenize.api.StringTokenizer" [arrowhead="empty", arrowtail="none"];
"nltk.tokenize.stanford.StanfordTokenizer" -> "nltk.tokenize.api.TokenizerI" [arrowhead="empty", arrowtail="none"];
"nltk.tokenize.texttiling.TextTilingTokenizer" -> "nltk.tokenize.api.TokenizerI" [arrowhead="empty", arrowtail="none"];
"nltk.tokenize.treebank.TreebankWordTokenizer" -> "nltk.tokenize.api.TokenizerI" [arrowhead="empty", arrowtail="none"];
"nltk.toolbox.ToolboxData" -> "nltk.toolbox.StandardFormat" [arrowhead="empty", arrowtail="none"];
"nltk.toolbox.ToolboxSettings" -> "nltk.toolbox.StandardFormat" [arrowhead="empty", arrowtail="none"];
"nltk.tree.AbstractParentedTree" -> "nltk.tree.Tree" [arrowhead="empty", arrowtail="none"];
"nltk.tree.ImmutableMultiParentedTree" -> "nltk.tree.ImmutableTree" [arrowhead="empty", arrowtail="none"];
"nltk.tree.ImmutableMultiParentedTree" -> "nltk.tree.MultiParentedTree" [arrowhead="empty", arrowtail="none"];
"nltk.tree.ImmutableParentedTree" -> "nltk.tree.ImmutableTree" [arrowhead="empty", arrowtail="none"];
"nltk.tree.ImmutableParentedTree" -> "nltk.tree.ParentedTree" [arrowhead="empty", arrowtail="none"];
"nltk.tree.ImmutableProbabilisticTree" -> "nltk.probability.ProbabilisticMixIn" [arrowhead="empty", arrowtail="none"];
"nltk.tree.ImmutableProbabilisticTree" -> "nltk.tree.ImmutableTree" [arrowhead="empty", arrowtail="none"];
"nltk.tree.ImmutableTree" -> "nltk.tree.Tree" [arrowhead="empty", arrowtail="none"];
"nltk.tree.MultiParentedTree" -> "nltk.tree.AbstractParentedTree" [arrowhead="empty", arrowtail="none"];
"nltk.tree.ParentedTree" -> "nltk.tree.AbstractParentedTree" [arrowhead="empty", arrowtail="none"];
"nltk.tree.ProbabilisticTree" -> "nltk.probability.ProbabilisticMixIn" [arrowhead="empty", arrowtail="none"];
"nltk.tree.ProbabilisticTree" -> "nltk.tree.Tree" [arrowhead="empty", arrowtail="none"];
"nltk.util.LazyConcatenation" -> "nltk.util.AbstractLazySequence" [arrowhead="empty", arrowtail="none"];
"nltk.util.LazyEnumerate" -> "nltk.util.LazyZip" [arrowhead="empty", arrowtail="none"];
"nltk.util.LazyMap" -> "nltk.util.AbstractLazySequence" [arrowhead="empty", arrowtail="none"];
"nltk.util.LazySubsequence" -> "nltk.util.AbstractLazySequence" [arrowhead="empty", arrowtail="none"];
"nltk.util.LazyZip" -> "nltk.util.LazyMap" [arrowhead="empty", arrowtail="none"];
"nltk.app.chartparser_app.ChartMatrixView" -> "nltk.app.chartparser_app.ChartComparer" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="_left_matrix", style="solid"];
"nltk.app.chartparser_app.ChartMatrixView" -> "nltk.app.chartparser_app.ChartComparer" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="_right_matrix", style="solid"];
"nltk.app.chartparser_app.ChartMatrixView" -> "nltk.app.chartparser_app.ChartComparer" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="_out_matrix", style="solid"];
"nltk.app.chartparser_app.ChartMatrixView" -> "nltk.app.chartparser_app.ChartParserApp" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="_matrix", style="solid"];
"nltk.app.chartparser_app.ChartResultsView" -> "nltk.app.chartparser_app.ChartParserApp" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="_results", style="solid"];
"nltk.app.chartparser_app.ChartView" -> "nltk.app.chartparser_app.ChartParserApp" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="_cv", style="solid"];
"nltk.app.chartparser_app.EdgeList" -> "nltk.app.chartparser_app.ChartMatrixView" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="_list", style="solid"];
"nltk.app.collocations_app.CollocationsModel" -> "nltk.app.collocations_app.CollocationsView" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="model", style="solid"];
"nltk.app.concordance_app.ConcordanceSearchModel" -> "nltk.app.concordance_app.ConcordanceSearchView" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="model", style="solid"];
"nltk.ccg.api.PrimitiveCategory" -> "nltk.ccg.lexicon.CCGLexicon" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="_start", style="solid"];
"nltk.chunk.named_entity.NEChunkParserTagger" -> "nltk.chunk.named_entity.NEChunkParser" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="_tagger", style="solid"];
"nltk.chunk.regexp.RegexpChunkParser" -> "nltk.app.chunkparser_app.RegexpChunkApp" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="chunker", style="solid"];
"nltk.chunk.regexp.RegexpChunkParser" -> "nltk.app.chunkparser_app.RegexpChunkApp" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="chunker", style="solid"];
"nltk.chunk.util.ChunkScore" -> "nltk.app.chunkparser_app.RegexpChunkApp" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="_eval_score", style="solid"];
"nltk.chunk.util.ChunkScore" -> "nltk.app.chunkparser_app.RegexpChunkApp" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="_eval_score", style="solid"];
"nltk.classify.decisiontree.DecisionTreeClassifier" -> "nltk.classify.decisiontree.DecisionTreeClassifier" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="_default", style="solid"];
"nltk.classify.naivebayes.NaiveBayesClassifier" -> "nltk.parse.nonprojectivedependencyparser.NaiveBayesDependencyScorer" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="classifier", style="solid"];
"nltk.cluster.util.Dendrogram" -> "nltk.cluster.gaac.GAAClusterer" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="_dendrogram", style="solid"];
"nltk.corpus.reader.framenet.AttrDict" -> "nltk.corpus.reader.framenet.FramenetCorpusReader" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="_semtypes", style="solid"];
"nltk.corpus.reader.nkjp.NKJPCorpus_Text_View" -> "nltk.corpus.reader.nkjp.NKJPCorpus_Segmentation_View" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="text_view", style="solid"];
"nltk.corpus.reader.nkjp.XML_Tool" -> "nltk.corpus.reader.nkjp.NKJPCorpus_Morph_View" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="xml_tool", style="solid"];
"nltk.corpus.reader.nkjp.XML_Tool" -> "nltk.corpus.reader.nkjp.NKJPCorpus_Segmentation_View" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="xml_tool", style="solid"];
"nltk.corpus.reader.nkjp.XML_Tool" -> "nltk.corpus.reader.nkjp.NKJPCorpus_Text_View" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="xml_tool", style="solid"];
"nltk.corpus.reader.util.StreamBackedCorpusView" -> "nltk.corpus.reader.plaintext.PlaintextCorpusReader" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="CorpusView", style="solid"];
"nltk.corpus.reader.ycoe.YCOEParseCorpusReader" -> "nltk.corpus.reader.ycoe.YCOECorpusReader" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="_psd_reader", style="solid"];
"nltk.corpus.reader.ycoe.YCOETaggedCorpusReader" -> "nltk.corpus.reader.ycoe.YCOECorpusReader" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="_pos_reader", style="solid"];
"nltk.data.SeekableUnicodeStreamReader" -> "nltk.corpus.reader.util.StreamBackedCorpusView" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="_stream", style="solid"];
"nltk.draw.cfg.ProductionList" -> "nltk.draw.cfg.CFGDemo" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="_prodlist", style="solid"];
"nltk.draw.table.MultiListbox" -> "nltk.draw.table.Table" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="_mlb", style="solid"];
"nltk.draw.table.Table" -> "nltk.downloader.DownloaderGUI" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="_table", style="solid"];
"nltk.draw.tree.TreeSegmentWidget" -> "nltk.app.rdparser_app.RecursiveDescentApp" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="_tree", style="solid"];
"nltk.draw.tree.TreeSegmentWidget" -> "nltk.draw.cfg.CFGDemo" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="_treelet", style="solid"];
"nltk.draw.tree.TreeSegmentWidget" -> "nltk.draw.cfg.CFGDemo" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="_tree", style="solid"];
"nltk.draw.tree.TreeSegmentWidget" -> "nltk.draw.tree.TreeWidget" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="_treeseg", style="solid"];
"nltk.draw.util.CanvasFrame" -> "nltk.app.chartparser_app.ChartResultsView" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="_cframe", style="solid"];
"nltk.draw.util.CanvasFrame" -> "nltk.app.rdparser_app.RecursiveDescentApp" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="_cframe", style="solid"];
"nltk.draw.util.CanvasFrame" -> "nltk.app.srparser_app.ShiftReduceApp" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="_cframe", style="solid"];
"nltk.draw.util.CanvasFrame" -> "nltk.draw.cfg.CFGDemo" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="_workspace", style="solid"];
"nltk.draw.util.CanvasFrame" -> "nltk.draw.tree.TreeView" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="_cframe", style="solid"];
"nltk.draw.util.CanvasFrame" -> "nltk.sem.drt_glue_demo.DrtGlueDemo" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="_cframe", style="solid"];
"nltk.draw.util.MutableOptionMenu" -> "nltk.app.chartparser_app.ChartComparer" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="_left_selector", style="solid"];
"nltk.draw.util.MutableOptionMenu" -> "nltk.app.chartparser_app.ChartComparer" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="_right_selector", style="solid"];
"nltk.draw.util.ScrollWatcherWidget" -> "nltk.draw.util.CanvasFrame" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="_scrollwatcher", style="solid"];
"nltk.draw.util.TextWidget" -> "nltk.app.rdparser_app.RecursiveDescentApp" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="_tree", style="solid"];
"nltk.draw.util.TextWidget" -> "nltk.app.srparser_app.ShiftReduceApp" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="_stacklabel", style="solid"];
"nltk.draw.util.TextWidget" -> "nltk.app.srparser_app.ShiftReduceApp" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="_rtextlabel", style="solid"];
"nltk.draw.util.TextWidget" -> "nltk.draw.cfg.CFGDemo" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="_treelet", style="solid"];
"nltk.draw.util.TextWidget" -> "nltk.draw.tree.TreeWidget" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="_treeseg", style="solid"];
"nltk.grammar.CFG" -> "nltk.draw.cfg.CFGEditor" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="_cfg", style="solid"];
"nltk.grammar.ProbabilisticDependencyGrammar" -> "nltk.parse.projectivedependencyparser.ProbabilisticProjectiveDependencyParser" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="_grammar", style="solid"];
"nltk.inference.discourse.CfgReadingCommand" -> "nltk.inference.discourse.DiscourseTester" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="_reading_command", style="solid"];
"nltk.inference.prover9.Prover9" -> "nltk.sem.glue.Glue" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="prover", style="solid"];
"nltk.internals.Counter" -> "nltk.sem.boxer.BoxerOutputDrsParser" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="_label_counter", style="solid"];
"nltk.internals.ElementWrapper" -> "nltk.downloader.Downloader" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="_index", style="solid"];
"nltk.parse.chart.Chart" -> "nltk.app.chartparser_app.ChartComparer" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="_emptychart", style="solid"];
"nltk.parse.chart.Chart" -> "nltk.app.chartparser_app.ChartComparer" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="_left_chart", style="solid"];
"nltk.parse.chart.Chart" -> "nltk.app.chartparser_app.ChartComparer" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="_right_chart", style="solid"];
"nltk.parse.chart.Chart" -> "nltk.app.chartparser_app.ChartComparer" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="_out_chart", style="solid"];
"nltk.parse.chart.Chart" -> "nltk.app.chartparser_app.ChartComparer" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="_out_chart", style="solid"];
"nltk.parse.chart.Chart" -> "nltk.app.chartparser_app.ChartComparer" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="_out_chart", style="solid"];
"nltk.parse.chart.Chart" -> "nltk.app.chartparser_app.ChartParserApp" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="_chart", style="solid"];
"nltk.parse.chart.Chart" -> "nltk.parse.chart.SteppingChartParser" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="_chart", style="solid"];
"nltk.parse.chart.ChartParser" -> "nltk.inference.discourse.CfgReadingCommand" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="_parser", style="solid"];
"nltk.parse.chart.ChartParser" -> "nltk.parse.util.TestGrammar" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="cp", style="solid"];
"nltk.parse.chart.SteppingChartParser" -> "nltk.app.chartparser_app.ChartParserApp" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="_cp", style="solid"];
"nltk.parse.dependencygraph.DependencyGraph" -> "nltk.parse.nonprojectivedependencyparser.NonprojectiveDependencyParser" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="_graph", style="solid"];
"nltk.parse.earleychart.CompleteFundamentalRule" -> "nltk.parse.earleychart.CompleterRule" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="_fundamental_rule", style="solid"];
"nltk.parse.earleychart.CompleteFundamentalRule" -> "nltk.parse.earleychart.ScannerRule" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="_fundamental_rule", style="solid"];
"nltk.parse.earleychart.FeatureCompleteFundamentalRule" -> "nltk.parse.earleychart.FeatureCompleterRule" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="_fundamental_rule", style="solid"];
"nltk.parse.earleychart.FeatureCompleteFundamentalRule" -> "nltk.parse.earleychart.FeatureScannerRule" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="_fundamental_rule", style="solid"];
"nltk.parse.featurechart.FeatureChartParser" -> "nltk.inference.discourse.CfgReadingCommand" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="_parser", style="solid"];
"nltk.parse.featurechart.FeatureChartParser" -> "nltk.parse.util.TestGrammar" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="cp", style="solid"];
"nltk.parse.featurechart.FeatureFundamentalRule" -> "nltk.parse.featurechart.FeatureSingleEdgeFundamentalRule" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="_fundamental_rule", style="solid"];
"nltk.parse.malt.MaltParser" -> "nltk.sem.glue.Glue" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="depparser", style="solid"];
"nltk.parse.pchart.InsideChartParser" -> "nltk.inference.discourse.CfgReadingCommand" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="_parser", style="solid"];
"nltk.parse.pchart.InsideChartParser" -> "nltk.parse.util.TestGrammar" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="cp", style="solid"];
"nltk.parse.pchart.ProbabilisticFundamentalRule" -> "nltk.parse.pchart.SingleEdgeProbabilisticFundamentalRule" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="_fundamental_rule", style="solid"];
"nltk.parse.recursivedescent.SteppingRecursiveDescentParser" -> "nltk.app.rdparser_app.RecursiveDescentApp" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="_parser", style="solid"];
"nltk.parse.shiftreduce.SteppingShiftReduceParser" -> "nltk.app.srparser_app.ShiftReduceApp" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="_parser", style="solid"];
"nltk.probability.ConditionalFreqDist" -> "nltk.tag.tnt.TnT" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="_bi", style="solid"];
"nltk.probability.ConditionalFreqDist" -> "nltk.tag.tnt.TnT" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="_tri", style="solid"];
"nltk.probability.ConditionalFreqDist" -> "nltk.tag.tnt.TnT" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="_wd", style="solid"];
"nltk.probability.ConditionalFreqDist" -> "nltk.tag.tnt.TnT" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="_eos", style="solid"];
"nltk.probability.ConditionalFreqDist" -> "nltk.text.ContextIndex" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="_word_to_contexts", style="solid"];
"nltk.probability.ConditionalFreqDist" -> "nltk.text.ContextIndex" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="_context_to_words", style="solid"];
"nltk.probability.DictionaryConditionalProbDist" -> "nltk.tag.hmm.HiddenMarkovModelTagger" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="_transitions", style="solid"];
"nltk.probability.DictionaryConditionalProbDist" -> "nltk.tag.hmm.HiddenMarkovModelTagger" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="_outputs", style="solid"];
"nltk.probability.FreqDist" -> "nltk.tag.tnt.TnT" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="_uni", style="solid"];
"nltk.probability.FreqDist" -> "nltk.text.Text" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="_vocab", style="solid"];
"nltk.probability.FreqDist" -> "nltk.tokenize.punkt.PunktTrainer" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="_type_fdist", style="solid"];
"nltk.probability.FreqDist" -> "nltk.tokenize.punkt.PunktTrainer" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="_type_fdist", style="solid"];
"nltk.probability.FreqDist" -> "nltk.tokenize.punkt.PunktTrainer" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="_collocation_fdist", style="solid"];
"nltk.probability.FreqDist" -> "nltk.tokenize.punkt.PunktTrainer" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="_collocation_fdist", style="solid"];
"nltk.probability.FreqDist" -> "nltk.tokenize.punkt.PunktTrainer" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="_sent_starter_fdist", style="solid"];
"nltk.probability.FreqDist" -> "nltk.tokenize.punkt.PunktTrainer" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="_sent_starter_fdist", style="solid"];
"nltk.sem.drt.DRS" -> "nltk.sem.drt.DRS" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="consequent", style="solid"];
"nltk.sem.drt.DrtConstantExpression" -> "nltk.sem.drt_glue_demo.DrtGlueDemo" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="_error", style="solid"];
"nltk.sem.drt.DrtEventVariableExpression" -> "nltk.sem.drt_glue_demo.DrtGlueDemo" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="_error", style="solid"];
"nltk.sem.drt.DrtFunctionVariableExpression" -> "nltk.sem.drt.DRS" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="consequent", style="solid"];
"nltk.sem.drt.DrtFunctionVariableExpression" -> "nltk.sem.drt_glue_demo.DrtGlueDemo" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="_error", style="solid"];
"nltk.sem.drt.DrtIndividualVariableExpression" -> "nltk.sem.drt.DRS" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="consequent", style="solid"];
"nltk.sem.drt.DrtIndividualVariableExpression" -> "nltk.sem.drt_glue_demo.DrtGlueDemo" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="_error", style="solid"];
"nltk.sem.drt.DrtNegatedExpression" -> "nltk.sem.drt.DRS" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="consequent", style="solid"];
"nltk.sem.drt.DrtParser" -> "nltk.sem.drt.DrtExpression" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="_drt_parser", style="solid"];
"nltk.sem.drt_glue_demo.DrsWidget" -> "nltk.sem.drt_glue_demo.DrtGlueDemo" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="_drsWidget", style="solid"];
"nltk.sem.drt_glue_demo.DrsWidget" -> "nltk.sem.drt_glue_demo.DrtGlueDemo" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="_drsWidget", style="solid"];
"nltk.sem.glue.DrtGlue" -> "nltk.inference.discourse.DrtGlueReadingCommand" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="_glue", style="solid"];
"nltk.sem.glue.DrtGlue" -> "nltk.sem.drt_glue_demo.DrtGlueDemo" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="_glue", style="solid"];
"nltk.sem.linearlogic.ConstantExpression" -> "nltk.sem.glue.GlueFormula" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="glue", style="solid"];
"nltk.sem.linearlogic.ImpExpression" -> "nltk.sem.glue.GlueFormula" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="glue", style="solid"];
"nltk.sem.linearlogic.LinearLogicParser" -> "nltk.sem.linearlogic.Expression" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="_linear_logic_parser", style="solid"];
"nltk.sem.linearlogic.VariableExpression" -> "nltk.sem.glue.GlueFormula" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="glue", style="solid"];
"nltk.sem.logic.AnyType" -> "nltk.sem.logic.ConstantExpression" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="type", style="solid"];
"nltk.sem.logic.AnyType" -> "nltk.sem.logic.EventVariableExpression" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="type", style="solid"];
"nltk.sem.logic.AnyType" -> "nltk.sem.logic.FunctionVariableExpression" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="type", style="solid"];
"nltk.sem.logic.AnyType" -> "nltk.sem.logic.IndividualVariableExpression" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="type", style="solid"];
"nltk.sem.logic.ComplexType" -> "nltk.sem.logic.ConstantExpression" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="type", style="solid"];
"nltk.sem.logic.ComplexType" -> "nltk.sem.logic.EventVariableExpression" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="type", style="solid"];
"nltk.sem.logic.ComplexType" -> "nltk.sem.logic.FunctionVariableExpression" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="type", style="solid"];
"nltk.sem.logic.ComplexType" -> "nltk.sem.logic.IndividualVariableExpression" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="type", style="solid"];
"nltk.sem.logic.EntityType" -> "nltk.sem.logic.ConstantExpression" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="type", style="solid"];
"nltk.sem.logic.EntityType" -> "nltk.sem.logic.EventVariableExpression" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="type", style="solid"];
"nltk.sem.logic.EntityType" -> "nltk.sem.logic.FunctionVariableExpression" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="type", style="solid"];
"nltk.sem.logic.EntityType" -> "nltk.sem.logic.IndividualVariableExpression" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="type", style="solid"];
"nltk.sem.logic.LogicParser" -> "nltk.sem.logic.Expression" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="_logic_parser", style="solid"];
"nltk.sem.logic.LogicParser" -> "nltk.sem.logic.Expression" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="_type_checking_logic_parser", style="solid"];
"nltk.sem.logic.TruthValueType" -> "nltk.sem.logic.ConstantExpression" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="type", style="solid"];
"nltk.sem.logic.TruthValueType" -> "nltk.sem.logic.EventVariableExpression" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="type", style="solid"];
"nltk.sem.logic.TruthValueType" -> "nltk.sem.logic.FunctionVariableExpression" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="type", style="solid"];
"nltk.sem.logic.TruthValueType" -> "nltk.sem.logic.IndividualVariableExpression" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="type", style="solid"];
"nltk.sem.logic.Variable" -> "nltk.sem.drt.DRS" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="label", style="solid"];
"nltk.tag.sequential.RegexpTagger" -> "nltk.parse.malt.MaltParser" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="tagger", style="solid"];
"nltk.text.ConcordanceIndex" -> "nltk.text.Text" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="_concordance_index", style="solid"];
"nltk.text.ContextIndex" -> "nltk.text.Text" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="_word_context_index", style="solid"];
"nltk.text.ContextIndex" -> "nltk.text.Text" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="_word_context_index", style="solid"];
"nltk.text.Text" -> "nltk.test.unit.test_2x_compat.TestTextTransliteration" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="txt", style="solid"];
"nltk.text.TokenSearcher" -> "nltk.text.Text" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="_token_searcher", style="solid"];
"nltk.tokenize.punkt.PunktParameters" -> "nltk.tokenize.punkt.PunktSentenceTokenizer" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="_params", style="solid"];
"nltk.tokenize.regexp.WhitespaceTokenizer" -> "nltk.corpus.reader.senseval.SensevalCorpusView" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="_word_tokenizer", style="solid"];
"nltk.tokenize.simple.LineTokenizer" -> "nltk.test.unit.test_corpus_views.TestCorpusViews" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="linetok", style="solid"];
"nltk.tree.Tree" -> "nltk.parse.recursivedescent.SteppingRecursiveDescentParser" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="_tree", style="solid"];
"nltk.util.OrderedDict" -> "nltk.classify.maxent.TadmEventMaxentFeatureEncoding" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="_mapping", style="solid"];
"nltk.util.OrderedDict" -> "nltk.classify.maxent.TadmEventMaxentFeatureEncoding" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="_label_mapping", style="solid"];
"nltk.util.OrderedDict" -> "nltk.treeprettyprinter.TreePrettyPrinter" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="edges", style="solid"];
"nltk.align.api.Alignment" -> "nltk.align.api.AlignedSent" [arrowhead="odiamond", arrowtail="none", fontcolor="green", label="_alignment", style="solid"];
"nltk.ccg.combinator.BackwardCombinator" -> "nltk.ccg.chart.BackwardTypeRaiseRule" [arrowhead="odiamond", arrowtail="none", fontcolor="green", label="_combinator", style="solid"];
"nltk.ccg.combinator.ForwardCombinator" -> "nltk.ccg.chart.ForwardTypeRaiseRule" [arrowhead="odiamond", arrowtail="none", fontcolor="green", label="_combinator", style="solid"];
"nltk.data.FileSystemPathPointer" -> "nltk.corpus.reader.api.CorpusReader" [arrowhead="odiamond", arrowtail="none", fontcolor="green", label="_root", style="solid"];
"nltk.data.LazyLoader" -> "nltk.corpus.reader.plaintext.PlaintextCorpusReader" [arrowhead="odiamond", arrowtail="none", fontcolor="green", label="_sent_tokenizer", style="solid"];
"nltk.data.OpenOnDemandZipFile" -> "nltk.data.ZipFilePathPointer" [arrowhead="odiamond", arrowtail="none", fontcolor="green", label="_zipfile", style="solid"];
"nltk.data.ZipFilePathPointer" -> "nltk.corpus.reader.api.CorpusReader" [arrowhead="odiamond", arrowtail="none", fontcolor="green", label="_root", style="solid"];
"nltk.featstruct.FeatList" -> "nltk.featstruct.FeatStructReader" [arrowhead="odiamond", arrowtail="none", fontcolor="green", label="_flist_class", style="solid"];
"nltk.featstruct.FeatStruct" -> "nltk.featstruct.FeatStructReader" [arrowhead="odiamond", arrowtail="none", fontcolor="green", label="_fdict_class", style="solid"];
"nltk.featstruct.Feature" -> "nltk.featstruct.FeatStructReader" [arrowhead="odiamond", arrowtail="none", fontcolor="green", label="_prefix_feature", style="solid"];
"nltk.featstruct.Feature" -> "nltk.featstruct.FeatStructReader" [arrowhead="odiamond", arrowtail="none", fontcolor="green", label="_slash_feature", style="solid"];
"nltk.featstruct.SlashFeature" -> "nltk.featstruct.FeatStructReader" [arrowhead="odiamond", arrowtail="none", fontcolor="green", label="_prefix_feature", style="solid"];
"nltk.featstruct.SlashFeature" -> "nltk.featstruct.FeatStructReader" [arrowhead="odiamond", arrowtail="none", fontcolor="green", label="_slash_feature", style="solid"];
"nltk.parse.chart.BottomUpPredictCombineRule" -> "nltk.parse.chart.SteppingChartParser" [arrowhead="odiamond", arrowtail="none", fontcolor="green", label="_current_chartrule", style="solid"];
"nltk.parse.chart.Chart" -> "nltk.parse.chart.ChartParser" [arrowhead="odiamond", arrowtail="none", fontcolor="green", label="_chart_class", style="solid"];
"nltk.parse.chart.EmptyPredictRule" -> "nltk.parse.chart.SteppingChartParser" [arrowhead="odiamond", arrowtail="none", fontcolor="green", label="_current_chartrule", style="solid"];
"nltk.parse.chart.LeafInitRule" -> "nltk.parse.chart.SteppingChartParser" [arrowhead="odiamond", arrowtail="none", fontcolor="green", label="_current_chartrule", style="solid"];
"nltk.parse.chart.SingleEdgeFundamentalRule" -> "nltk.parse.chart.SteppingChartParser" [arrowhead="odiamond", arrowtail="none", fontcolor="green", label="_current_chartrule", style="solid"];
"nltk.parse.earleychart.IncrementalChart" -> "nltk.parse.earleychart.IncrementalChartParser" [arrowhead="odiamond", arrowtail="none", fontcolor="green", label="_chart_class", style="solid"];
"nltk.probability.FreqDist" -> "nltk.collocations.AbstractCollocationFinder" [arrowhead="odiamond", arrowtail="none", fontcolor="green", label="ngram_fd", style="solid"];
"nltk.sem.boxer.NltkDrtBoxerDrsInterpreter" -> "nltk.sem.boxer.Boxer" [arrowhead="odiamond", arrowtail="none", fontcolor="green", label="_boxer_drs_interpreter", style="solid"];
"nltk.sem.linearlogic.BindingDict" -> "nltk.sem.linearlogic.ApplicationExpression" [arrowhead="odiamond", arrowtail="none", fontcolor="green", label="bindings", style="solid"];
"nltk.sem.logic.LogicParser" -> "nltk.featstruct.FeatStructReader" [arrowhead="odiamond", arrowtail="none", fontcolor="green", label="_logic_parser", style="solid"];
"nltk.tokenize.punkt.PunktLanguageVars" -> "nltk.tokenize.punkt.PunktBaseClass" [arrowhead="odiamond", arrowtail="none", fontcolor="green", label="_lang_vars", style="solid"];
"nltk.tokenize.punkt.PunktParameters" -> "nltk.tokenize.punkt.PunktBaseClass" [arrowhead="odiamond", arrowtail="none", fontcolor="green", label="_params", style="solid"];
"nltk.tokenize.punkt.PunktToken" -> "nltk.tokenize.punkt.PunktBaseClass" [arrowhead="odiamond", arrowtail="none", fontcolor="green", label="_Token", style="solid"];
"nltk.tokenize.regexp.RegexpTokenizer" -> "nltk.corpus.reader.aligned.AlignedCorpusReader" [arrowhead="odiamond", arrowtail="none", fontcolor="green", label="_sent_tokenizer", style="solid"];
"nltk.tokenize.regexp.RegexpTokenizer" -> "nltk.corpus.reader.tagged.TaggedCorpusReader" [arrowhead="odiamond", arrowtail="none", fontcolor="green", label="_sent_tokenizer", style="solid"];
"nltk.tokenize.regexp.WhitespaceTokenizer" -> "nltk.corpus.reader.aligned.AlignedCorpusReader" [arrowhead="odiamond", arrowtail="none", fontcolor="green", label="_word_tokenizer", style="solid"];
"nltk.tokenize.regexp.WhitespaceTokenizer" -> "nltk.corpus.reader.tagged.TaggedCorpusReader" [arrowhead="odiamond", arrowtail="none", fontcolor="green", label="_word_tokenizer", style="solid"];
"nltk.tokenize.regexp.WordPunctTokenizer" -> "nltk.corpus.reader.plaintext.PlaintextCorpusReader" [arrowhead="odiamond", arrowtail="none", fontcolor="green", label="_word_tokenizer", style="solid"];
"nltk.tree.Tree" -> "nltk.corpus.reader.conll.ConllCorpusReader" [arrowhead="odiamond", arrowtail="none", fontcolor="green", label="_tree_class", style="solid"];
}
